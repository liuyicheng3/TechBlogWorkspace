{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"27aa8fc6a4fd4146edd797dfcbb167a00bbf8664","modified":1489756360000},{"_id":"themes/hexo-theme-next/.DS_Store","hash":"f09a86bb4ce7d04901ec1bb4cb55bee99909840c","modified":1489759579000},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1489756015000},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1489756015000},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1489756015000},{"_id":"themes/hexo-theme-next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1489756015000},{"_id":"themes/hexo-theme-next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1489756015000},{"_id":"themes/hexo-theme-next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1489756015000},{"_id":"themes/hexo-theme-next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1489756015000},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1489756015000},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1489756015000},{"_id":"themes/hexo-theme-next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1489756015000},{"_id":"themes/hexo-theme-next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1489756015000},{"_id":"themes/hexo-theme-next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1489756015000},{"_id":"themes/hexo-theme-next/_config.yml","hash":"1c7150916f6a43cf46e28bc8acd255cb401e15f3","modified":1489759709000},{"_id":"themes/hexo-theme-next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1489756015000},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1489756015000},{"_id":"themes/hexo-theme-next/package.json","hash":"7e87b2621104b39a30488654c2a8a0c6a563574b","modified":1489756015000},{"_id":"source/_posts/.DS_Store","hash":"05f55c4bbbcea21a6e4032a99939d87156793f59","modified":1489757502000},{"_id":"source/_posts/AS导入工程配置.md","hash":"b16bc768e602046e5ab4b2ce0f004bd65a8d5062","modified":1489757229000},{"_id":"source/_posts/Android分包.md","hash":"ee0f82c77f5d71dbd4601802dc803cd7a6570237","modified":1489757160000},{"_id":"source/_posts/Gradle小结.md","hash":"54e0e15f45d22296bd952471e7a9ca5fe9108058","modified":1489757446000},{"_id":"source/_posts/Xcode 和Android  studio 快捷键及设置对比.md","hash":"eb317879f8abbb6e349c04f720c3d85323b0ff5a","modified":1489757696000},{"_id":"source/_posts/android模块化实践.md","hash":"a645d5a0451ca00f9cd6dfde2e6ca3f0680aa682","modified":1489757196000},{"_id":"source/_posts/deep_link_design.md","hash":"e876f6f5a1c5719f699388e684ebf53f2967c27b","modified":1489757266000},{"_id":"source/_posts/git_guide.md","hash":"e3952914bf530e76858afde4113f221d2d470569","modified":1489757310000},{"_id":"source/_posts/gradle坑.md","hash":"1624be3d3a925d24da2cb040a037c7975debe37c","modified":1489757377000},{"_id":"source/_posts/never_forget.md","hash":"b00765cbdd99e1d18d24a2c5be4a9787869fd5a3","modified":1489757601000},{"_id":"source/_posts/ios学习笔记.md","hash":"ed609d5d2774595372ec6f45fa20b01dd658c464","modified":1489757545000},{"_id":"source/_posts/okhttp.md","hash":"99891fc30530ec6afbb8fd663e6f089efd392821","modified":1489757644000},{"_id":"source/_posts/动态往apk写入信息.md","hash":"fd3c54b6c3f6b18c0f80a17d0f9c4811ae525934","modified":1489726821000},{"_id":"source/_posts/性能优化篇.md","hash":"50d03fbb771851cc72ebb5cd1fbf3157fabbfd74","modified":1489757123000},{"_id":"source/_posts/混淆写法.md","hash":"64462e9327883e46dfeb6d8ebf2762c06b6b669c","modified":1489757001000},{"_id":"source/_posts/热补丁_part0.md","hash":"d24cfe0efac0cd0e1457d9b658b7daa13bb739e7","modified":1489757070000},{"_id":"themes/hexo-theme-next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/config","hash":"a33539305f85ea695520b496f67659d5751acff8","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/index","hash":"9cbcf29d7ce1d35ce552e7b3eff241c4952a4d46","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/packed-refs","hash":"f834a58defdb1370a8c87a22959c1b5796f149e1","modified":1489756015000},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1489756015000},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"7462c3017dae88e5f80ff308db0b95baf960c83f","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/.DS_Store","hash":"b8e5951c497e1060bfccf7be197be3bad8cb1885","modified":1489759711000},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1489756015000},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1489756015000},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/logs/HEAD","hash":"7fec182c6bf2d6767deda48c343f2b458febc88f","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"b16fcbf0efd20c018d7545257a8533c497ea7647","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"cf0e192eedaa1a1bbbab9e7a7e6979c4e24cda31","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"911b99ba0445b2c07373128d87a4ef2eb7de341a","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/refs/heads/master","hash":"533ae954cefa2c28a5098c31d0004dfe28d1b399","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_components/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"2d1075f4cabcb3956b7b84a8e210f5a66f0a5562","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/exturl.swig","hash":"8e20dd2078d7dfdf4a5a6daa142bb94d002300f5","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/localsearch.swig","hash":"f4dbd4c896e6510ded8ebe05394c28f8a86e71bf","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"28a7f84242ca816a6452a0a79669ca963d824607","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"e13c9ccf70d593bdf3b8cc1d768f595abd610e6e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/logs/refs/heads/master","hash":"7fec182c6bf2d6767deda48c343f2b458febc88f","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"1eb34b9c1f6d541605ff23333eeb133e1c4daf17","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-db8380a31c84a7f5890f15e7f043256176657aa0.idx","hash":"cecc3655019d441a02821f72e3b0dd74238f2b30","modified":1489756014000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/logs/refs/remotes/origin/HEAD","hash":"7fec182c6bf2d6767deda48c343f2b458febc88f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"755b04edbbfbdd981a783edb09c9cc34cb79cea7","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"8c0276883398651336853d5ec0e9da267a00dd86","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"dd310c2d999185e881db007360176ee2f811df10","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-db8380a31c84a7f5890f15e7f043256176657aa0.pack","hash":"56eadafb5345ec7707545df50f44c80058779c9c","modified":1489756014000},{"_id":"source/_posts/EventBus版本升级.md","hash":"368139636a9872953aaf66b8cc3c0e0d2938fd86","modified":1520084947000},{"_id":"public/2015/11/01/AS导入工程配置/index.html","hash":"82fc0e72eb25ea320f574f4fc85f992fb52710ec","modified":1520085898714},{"_id":"public/2015/11/01/Xcode 和Android  studio 快捷键及设置对比/index.html","hash":"0fc4db724122ac162929c156ae16646d59820770","modified":1520085898722},{"_id":"public/2015/11/01/deep_link_design/index.html","hash":"b15803f576154991b2245dabb5200eeb4939d7e9","modified":1520085898723},{"_id":"public/2015/11/01/android模块化实践/index.html","hash":"06b9d09b490b181c9696282a73af63b9a64b1ba9","modified":1520085898723},{"_id":"public/2015/11/01/git_guide/index.html","hash":"85a154f1833c9a1df585e5c7cd261e9e39cd1078","modified":1520085898723},{"_id":"public/2015/11/01/gradle坑/index.html","hash":"5beefc5006d23ed788bc739c75bd95792cd51444","modified":1520085898829},{"_id":"public/2015/11/01/Android分包/index.html","hash":"278add28e9f34b335e69dd55309e8f53b69f91e4","modified":1520085898830},{"_id":"public/2015/11/01/混淆写法/index.html","hash":"72cbd69a9fa8a8682dc82d39ed95e68954f8ade3","modified":1520085898830},{"_id":"public/archives/index.html","hash":"731cd49a583f805341b99dc6c558154bad6074a5","modified":1520085898830},{"_id":"public/2015/11/01/never_forget/index.html","hash":"7c6b05ae7dd03b2ae46e1fd85f626f232fcda082","modified":1520085898830},{"_id":"public/archives/2015/index.html","hash":"c139d7b8265c4c5cf14580e4bbea49eddfa7498b","modified":1520085898830},{"_id":"public/archives/2015/page/2/index.html","hash":"aadefa8246f3e60f932b25c47f8eaa51cf413ac4","modified":1520085898830},{"_id":"public/archives/page/2/index.html","hash":"c093af882e68cd319a7cac864d07df7355b4b78b","modified":1520085898830},{"_id":"public/archives/2015/11/index.html","hash":"bfb591bae812668d3c78a7b7f6e5e7b7ad61eed4","modified":1520085898830},{"_id":"public/categories/android/index.html","hash":"578f9eb5687aa42b9dc5caf4c2a9f18ac377ea0b","modified":1520085898830},{"_id":"public/categories/Android/index.html","hash":"22dbb36dabf1220cb4c0b63ea22890bc5e7a6472","modified":1520085898830},{"_id":"public/categories/工具/index.html","hash":"4ba7a089f5e27bebbfd697a106d5260076a75df1","modified":1520085898830},{"_id":"public/categories/其它/index.html","hash":"970e20755ad3e5f2ab7390d12a335a88f24abdda","modified":1520085898830},{"_id":"public/categories/iOS/index.html","hash":"c9153484785f9252c284972ef5ccecab3db9f60e","modified":1520085898830},{"_id":"public/categories/Android快速打包/index.html","hash":"cf2e63bd82dc66c6439d8e2a1584301ddca9d93b","modified":1520085898830},{"_id":"public/tags/打包/index.html","hash":"b0640899020048ab74c7ad5e3d1b225f8d49f868","modified":1520085898830},{"_id":"public/tags/工具/index.html","hash":"a224e3c5f6f9d8339f65fb3f95afebadbae76a4f","modified":1520085898830},{"_id":"public/tags/Android/index.html","hash":"a2dee07a03ceec55bd40fb9ae2fbfac21c420e8b","modified":1520085898830},{"_id":"public/categories/打包/index.html","hash":"22f31af8bc1709658e5f0fb6fdf9dd5ac8628dfc","modified":1520085898830},{"_id":"public/tags/模块化/index.html","hash":"920572ad3832b41dd2acb8b1950d9f774fcd1158","modified":1520085898830},{"_id":"public/tags/github/index.html","hash":"d5877c528ad4e99713f5bd19ca3a3998b330f2e6","modified":1520085898830},{"_id":"public/tags/其他/index.html","hash":"b398a7bfeab8597bc6e17e9a6797ca762474e724","modified":1520085898830},{"_id":"public/tags/网络层/index.html","hash":"f640877e3f3247a5e1eb5289b8e4b608b08c542f","modified":1520085898830},{"_id":"public/tags/ios入门/index.html","hash":"80e83fcb2cffe5eeddf201a6f2e158771d1e66d6","modified":1520085898830},{"_id":"public/archives/2015/11/page/2/index.html","hash":"90e8e7488a5a4c89205267a4832c7561006ecbfc","modified":1520085898830},{"_id":"public/tags/性能/index.html","hash":"4eeebc6bd04d7b8ee4c3de6f84b33dadf7808e73","modified":1520085898831},{"_id":"public/tags/热补丁/index.html","hash":"da1c611138e8bdf9f1ccd922af49064886fca356","modified":1520085898831},{"_id":"public/2015/11/01/ios学习笔记/index.html","hash":"507d98198af7dd3a09537e15b83cc2efebdb3b0a","modified":1520085898831},{"_id":"public/2015/11/01/okhttp/index.html","hash":"c28a379f7a7969a62b3c70bf6c67fd3ef4f55efe","modified":1520085898831},{"_id":"public/2015/11/01/动态往apk写入信息/index.html","hash":"5a33260f37e72b7356ab5cb57978e35882f85f16","modified":1520085898831},{"_id":"public/2015/11/01/性能优化篇/index.html","hash":"a06a946121397e0911d5422aefff5417af500ff0","modified":1520085898831},{"_id":"public/2015/11/01/热补丁_part0/index.html","hash":"5b6f8145166d0e4ed50f539cce1036e291ab6b52","modified":1520085898831},{"_id":"public/2015/11/01/Gradle小结/index.html","hash":"b38273ce2bb2230388c68130bc1b98e39332a000","modified":1520085898831},{"_id":"public/index.html","hash":"e51438356b08a432b887f45569e21a3082bb68b0","modified":1520085898831},{"_id":"public/page/2/index.html","hash":"c1b9349e2c7d6215df574a303e082ce8d82099da","modified":1520085898831},{"_id":"public/archives/2018/index.html","hash":"c0b46db740c76afaaa8b4b02a0c2de05163a729e","modified":1520085898833},{"_id":"public/archives/2018/03/index.html","hash":"ec52ce6089f91fbbd6133b6926088bbdd38400cf","modified":1520085898833},{"_id":"public/2018/03/03/EventBus版本升级/index.html","hash":"7debc08fcf583c9b828af9a751d56e12c0e9dcf5","modified":1520085898833}],"Category":[{"name":"Android","_id":"cj0dwk7bh00021rjja80ocw5o"},{"name":"android","_id":"cj0dwk7c0000e1rjj5vnerph7"},{"name":"工具","_id":"cj0dwk7c4000k1rjja11kwbcr"},{"name":"其它","_id":"cj0dwk7cn00151rjjrk001ex6"},{"name":"iOS","_id":"cj0dwk7co001c1rjjf6yti5zs"},{"name":"Android快速打包","_id":"cj0dwk7cr001i1rjjmq069nyg"},{"name":"打包","_id":"cj0dwk7cs001n1rjjc6n83fti"}],"Data":[],"Page":[],"Post":[{"title":"AS工程导入","date":"2015-11-01T12:10:33.000Z","_content":"\n\n# 1.工程导入\n## 1.1 普通eclipse  工程导入\n直接import，AS会提示转成eclipse工程\n## 1.2 github上的工程导入  \n用AS打开top level的settings.gradle选择进行配置导入   \nps：如果这一步直接导入的话就会报   Could not find method android() for arguments   \n\n可能遇到的问题：  \n\n1. 配置sdk位置（顶层build.gradle同级）\nlocal.properties（建议从已有工程拷贝一个）  \nsdk.dir=/Users/lyc/codeTools/android-sdk  \n\n2. 配置模块的build.gradle的gradletoolVersion版本\nbuildToolsVersion '23.0.2'\n\n建议从已有工程的里面找一个可用的版本填上去\n\n查看自己已经有哪些版本的buildTools的方法，\n\n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B01.png?raw=true)  \n\n3. modle配置模块的工程compileSdkVersionversion\n为一个已有版本的\n\n \n\n\n4. 配置\ndependencies中的com.android.support的版本，要求是于compileSdkVersionversion的版本一直\n，但是这个不好处理\n\ncompile 'com.android.support:design:25.1.1'\ncompile 'com.android.support:appcompat-v7:25.1.1'\ncompile 'com.android.support:cardview-v7:25.1.1'\n\n英文有子序列号\n建议按照以下方法写\ncompile 'com.android.support:cardview-v7:25.+'\n这样就会取本版本号下面最大的一个\n\n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B02.png?raw=true)   \n\n5.配置本地Gradel版本  \n这个常见于直接从别人那里拷贝的工程（也就是带有gradle/wrapper/**）的工程\n\n    distributionBase=GRADLE_USER_HOME\n    distributionPath=wrapper/dists\n    zipStoreBase=GRADLE_USER_HOME\n    zipStorePath=wrapper/dists\n    distributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip \ngradle会去找这个版本的gradle，如果找不到就会重新下载  \ngradle的默认下载目录在用户目录的.gradle/wrapper/dists文件夹中（隐藏的）  里面会有所有已经下载的gradle 版本，可以把它改成一个已经有的版本就行\n\n## 1.3 本地工程导入  \n直接import\n\n\n\n\n","source":"_posts/AS导入工程配置.md","raw":"title: AS工程导入\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n---\n\n\n# 1.工程导入\n## 1.1 普通eclipse  工程导入\n直接import，AS会提示转成eclipse工程\n## 1.2 github上的工程导入  \n用AS打开top level的settings.gradle选择进行配置导入   \nps：如果这一步直接导入的话就会报   Could not find method android() for arguments   \n\n可能遇到的问题：  \n\n1. 配置sdk位置（顶层build.gradle同级）\nlocal.properties（建议从已有工程拷贝一个）  \nsdk.dir=/Users/lyc/codeTools/android-sdk  \n\n2. 配置模块的build.gradle的gradletoolVersion版本\nbuildToolsVersion '23.0.2'\n\n建议从已有工程的里面找一个可用的版本填上去\n\n查看自己已经有哪些版本的buildTools的方法，\n\n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B01.png?raw=true)  \n\n3. modle配置模块的工程compileSdkVersionversion\n为一个已有版本的\n\n \n\n\n4. 配置\ndependencies中的com.android.support的版本，要求是于compileSdkVersionversion的版本一直\n，但是这个不好处理\n\ncompile 'com.android.support:design:25.1.1'\ncompile 'com.android.support:appcompat-v7:25.1.1'\ncompile 'com.android.support:cardview-v7:25.1.1'\n\n英文有子序列号\n建议按照以下方法写\ncompile 'com.android.support:cardview-v7:25.+'\n这样就会取本版本号下面最大的一个\n\n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B02.png?raw=true)   \n\n5.配置本地Gradel版本  \n这个常见于直接从别人那里拷贝的工程（也就是带有gradle/wrapper/**）的工程\n\n    distributionBase=GRADLE_USER_HOME\n    distributionPath=wrapper/dists\n    zipStoreBase=GRADLE_USER_HOME\n    zipStorePath=wrapper/dists\n    distributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip \ngradle会去找这个版本的gradle，如果找不到就会重新下载  \ngradle的默认下载目录在用户目录的.gradle/wrapper/dists文件夹中（隐藏的）  里面会有所有已经下载的gradle 版本，可以把它改成一个已经有的版本就行\n\n## 1.3 本地工程导入  \n直接import\n\n\n\n\n","slug":"AS导入工程配置","published":1,"updated":"2017-03-17T13:27:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7b900001rjjh5cesaxq","content":"<h1 id=\"1-工程导入\"><a href=\"#1-工程导入\" class=\"headerlink\" title=\"1.工程导入\"></a>1.工程导入</h1><h2 id=\"1-1-普通eclipse-工程导入\"><a href=\"#1-1-普通eclipse-工程导入\" class=\"headerlink\" title=\"1.1 普通eclipse  工程导入\"></a>1.1 普通eclipse  工程导入</h2><p>直接import，AS会提示转成eclipse工程</p>\n<h2 id=\"1-2-github上的工程导入\"><a href=\"#1-2-github上的工程导入\" class=\"headerlink\" title=\"1.2 github上的工程导入\"></a>1.2 github上的工程导入</h2><p>用AS打开top level的settings.gradle选择进行配置导入<br>ps：如果这一步直接导入的话就会报   Could not find method android() for arguments   </p>\n<p>可能遇到的问题：  </p>\n<ol>\n<li><p>配置sdk位置（顶层build.gradle同级）<br>local.properties（建议从已有工程拷贝一个）<br>sdk.dir=/Users/lyc/codeTools/android-sdk  </p>\n</li>\n<li><p>配置模块的build.gradle的gradletoolVersion版本<br>buildToolsVersion ‘23.0.2’</p>\n</li>\n</ol>\n<p>建议从已有工程的里面找一个可用的版本填上去</p>\n<p>查看自己已经有哪些版本的buildTools的方法，</p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B01.png?raw=true\" alt=\"see\">  </p>\n<ol>\n<li>modle配置模块的工程compileSdkVersionversion<br>为一个已有版本的</li>\n</ol>\n<ol>\n<li>配置<br>dependencies中的com.android.support的版本，要求是于compileSdkVersionversion的版本一直<br>，但是这个不好处理</li>\n</ol>\n<p>compile ‘com.android.support:design:25.1.1’<br>compile ‘com.android.support:appcompat-v7:25.1.1’<br>compile ‘com.android.support:cardview-v7:25.1.1’</p>\n<p>英文有子序列号<br>建议按照以下方法写<br>compile ‘com.android.support:cardview-v7:25.+’<br>这样就会取本版本号下面最大的一个</p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B02.png?raw=true\" alt=\"see\">   </p>\n<p>5.配置本地Gradel版本<br>这个常见于直接从别人那里拷贝的工程（也就是带有gradle/wrapper/**）的工程</p>\n<pre><code>distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip \n</code></pre><p>gradle会去找这个版本的gradle，如果找不到就会重新下载<br>gradle的默认下载目录在用户目录的.gradle/wrapper/dists文件夹中（隐藏的）  里面会有所有已经下载的gradle 版本，可以把它改成一个已经有的版本就行</p>\n<h2 id=\"1-3-本地工程导入\"><a href=\"#1-3-本地工程导入\" class=\"headerlink\" title=\"1.3 本地工程导入\"></a>1.3 本地工程导入</h2><p>直接import</p>\n","excerpt":"","more":"<h1 id=\"1-工程导入\"><a href=\"#1-工程导入\" class=\"headerlink\" title=\"1.工程导入\"></a>1.工程导入</h1><h2 id=\"1-1-普通eclipse-工程导入\"><a href=\"#1-1-普通eclipse-工程导入\" class=\"headerlink\" title=\"1.1 普通eclipse  工程导入\"></a>1.1 普通eclipse  工程导入</h2><p>直接import，AS会提示转成eclipse工程</p>\n<h2 id=\"1-2-github上的工程导入\"><a href=\"#1-2-github上的工程导入\" class=\"headerlink\" title=\"1.2 github上的工程导入\"></a>1.2 github上的工程导入</h2><p>用AS打开top level的settings.gradle选择进行配置导入<br>ps：如果这一步直接导入的话就会报   Could not find method android() for arguments   </p>\n<p>可能遇到的问题：  </p>\n<ol>\n<li><p>配置sdk位置（顶层build.gradle同级）<br>local.properties（建议从已有工程拷贝一个）<br>sdk.dir=/Users/lyc/codeTools/android-sdk  </p>\n</li>\n<li><p>配置模块的build.gradle的gradletoolVersion版本<br>buildToolsVersion ‘23.0.2’</p>\n</li>\n</ol>\n<p>建议从已有工程的里面找一个可用的版本填上去</p>\n<p>查看自己已经有哪些版本的buildTools的方法，</p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B01.png?raw=true\" alt=\"see\">  </p>\n<ol>\n<li>modle配置模块的工程compileSdkVersionversion<br>为一个已有版本的</li>\n</ol>\n<ol>\n<li>配置<br>dependencies中的com.android.support的版本，要求是于compileSdkVersionversion的版本一直<br>，但是这个不好处理</li>\n</ol>\n<p>compile ‘com.android.support:design:25.1.1’<br>compile ‘com.android.support:appcompat-v7:25.1.1’<br>compile ‘com.android.support:cardview-v7:25.1.1’</p>\n<p>英文有子序列号<br>建议按照以下方法写<br>compile ‘com.android.support:cardview-v7:25.+’<br>这样就会取本版本号下面最大的一个</p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B02.png?raw=true\" alt=\"see\">   </p>\n<p>5.配置本地Gradel版本<br>这个常见于直接从别人那里拷贝的工程（也就是带有gradle/wrapper/**）的工程</p>\n<pre><code>distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip \n</code></pre><p>gradle会去找这个版本的gradle，如果找不到就会重新下载<br>gradle的默认下载目录在用户目录的.gradle/wrapper/dists文件夹中（隐藏的）  里面会有所有已经下载的gradle 版本，可以把它改成一个已经有的版本就行</p>\n<h2 id=\"1-3-本地工程导入\"><a href=\"#1-3-本地工程导入\" class=\"headerlink\" title=\"1.3 本地工程导入\"></a>1.3 本地工程导入</h2><p>直接import</p>\n"},{"title":"Android分包","date":"2015-11-01T12:10:33.000Z","_content":"\n\n## 第一步：  gradle引入以及配置\n\ncompile 'com.android.support:multidex:1.0.1'\n\ndefaultConfig {\n    minSdkVersion 14\n    targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n    versionCode 5210\n    versionName \"5.2.1\"\n    //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:\"googleMarket\" ]\n    multiDexEnabled true\n    multiDexKeepProguard file('multiDexKeep.pro')\n    // resConfigs \"en\", \"zh_CN\", \"zh_TW\" 暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n}\n\n## 第二步：修改Application  \n\n@Override\nprotected void attachBaseContext(Context base) {\n    super.attachBaseContext(base);\n    MultiDex.install(base);\n}\n\n## 第三步：保证关键类在主dex中 \n\n 就是通过multiDexKeep.pro文件控制的\n#确保个推 sdk 在主 dex 中\n-dontwarn com.igexin.**\n-keep class com.igexin.**{*;}","source":"_posts/Android分包.md","raw":"title: Android分包\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n- 打包\n---\n\n\n## 第一步：  gradle引入以及配置\n\ncompile 'com.android.support:multidex:1.0.1'\n\ndefaultConfig {\n    minSdkVersion 14\n    targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n    versionCode 5210\n    versionName \"5.2.1\"\n    //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:\"googleMarket\" ]\n    multiDexEnabled true\n    multiDexKeepProguard file('multiDexKeep.pro')\n    // resConfigs \"en\", \"zh_CN\", \"zh_TW\" 暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n}\n\n## 第二步：修改Application  \n\n@Override\nprotected void attachBaseContext(Context base) {\n    super.attachBaseContext(base);\n    MultiDex.install(base);\n}\n\n## 第三步：保证关键类在主dex中 \n\n 就是通过multiDexKeep.pro文件控制的\n#确保个推 sdk 在主 dex 中\n-dontwarn com.igexin.**\n-keep class com.igexin.**{*;}","slug":"Android分包","published":1,"updated":"2017-03-17T13:26:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7be00011rjjm4l2x5c1","content":"<h2 id=\"第一步：-gradle引入以及配置\"><a href=\"#第一步：-gradle引入以及配置\" class=\"headerlink\" title=\"第一步：  gradle引入以及配置\"></a>第一步：  gradle引入以及配置</h2><p>compile ‘com.android.support:multidex:1.0.1’</p>\n<p>defaultConfig {<br>    minSdkVersion 14<br>    targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限<br>    versionCode 5210<br>    versionName “5.2.1”<br>    //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:”googleMarket” ]<br>    multiDexEnabled true<br>    multiDexKeepProguard file(‘multiDexKeep.pro’)<br>    // resConfigs “en”, “zh_CN”, “zh_TW” 暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制<br>}</p>\n<h2 id=\"第二步：修改Application\"><a href=\"#第二步：修改Application\" class=\"headerlink\" title=\"第二步：修改Application\"></a>第二步：修改Application</h2><p>@Override<br>protected void attachBaseContext(Context base) {<br>    super.attachBaseContext(base);<br>    MultiDex.install(base);<br>}</p>\n<h2 id=\"第三步：保证关键类在主dex中\"><a href=\"#第三步：保证关键类在主dex中\" class=\"headerlink\" title=\"第三步：保证关键类在主dex中\"></a>第三步：保证关键类在主dex中</h2><p> 就是通过multiDexKeep.pro文件控制的</p>\n<p>#确保个推 sdk 在主 dex 中<br>-dontwarn com.igexin.<strong><br>-keep class com.igexin.</strong>{*;}</p>\n","excerpt":"","more":"<h2 id=\"第一步：-gradle引入以及配置\"><a href=\"#第一步：-gradle引入以及配置\" class=\"headerlink\" title=\"第一步：  gradle引入以及配置\"></a>第一步：  gradle引入以及配置</h2><p>compile ‘com.android.support:multidex:1.0.1’</p>\n<p>defaultConfig {<br>    minSdkVersion 14<br>    targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限<br>    versionCode 5210<br>    versionName “5.2.1”<br>    //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:”googleMarket” ]<br>    multiDexEnabled true<br>    multiDexKeepProguard file(‘multiDexKeep.pro’)<br>    // resConfigs “en”, “zh_CN”, “zh_TW” 暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制<br>}</p>\n<h2 id=\"第二步：修改Application\"><a href=\"#第二步：修改Application\" class=\"headerlink\" title=\"第二步：修改Application\"></a>第二步：修改Application</h2><p>@Override<br>protected void attachBaseContext(Context base) {<br>    super.attachBaseContext(base);<br>    MultiDex.install(base);<br>}</p>\n<h2 id=\"第三步：保证关键类在主dex中\"><a href=\"#第三步：保证关键类在主dex中\" class=\"headerlink\" title=\"第三步：保证关键类在主dex中\"></a>第三步：保证关键类在主dex中</h2><p> 就是通过multiDexKeep.pro文件控制的</p>\n<p>#确保个推 sdk 在主 dex 中<br>-dontwarn com.igexin.<strong><br>-keep class com.igexin.</strong>{*;}</p>\n"},{"title":"Gradle配置中介","date":"2015-11-01T12:10:33.000Z","_content":"\n\n\nbuildGradle配置分析  \nTopicLevel的gradle    \n\n    buildscript {\n        repositories {\n            jcenter()\n        }\n        dependencies {\n            classpath 'com.android.tools.build:gradle:2.2.2'\n    \n            // NOTE: Do not place your application dependencies here; they belong\n            // in the individual module build.gradle files\n        }\n    }\n    allprojects {\n        repositories {\n            jcenter()\n        }\n    }\n    task clean(type: Delete) {\n        delete rootProject.buildDir\n    }\n\n\n\n\nMudule level的build.gradle  \n    \n    apply plugin: 'com.android.application'\n    \n    android {\n        compileSdkVersion 20\n        buildToolsVersion \"24.0.0\"\n    \n    \n        compileOptions{\n            sourceCompatibility JavaVersion.VERSION_1_8\n            targetCompatibility JavaVersion.VERSION_1_8\n        }\n    \n        defaultConfig {\n            applicationId \"com.lyc.study\"\n            minSdkVersion 15\n            targetSdkVersion 20\n            versionCode 1\n            versionName \"1.0\"\n            jackOptions{\n                enabled true\n            }\n        }\n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            }\n        }\n    }\n    \n    dependencies {\n        compile fileTree(include: ['*.jar'], dir: 'libs')\n        compile 'com.android.support:support-v4:+'\n        compile 'com.android.support:support-annotations:22.2.0'\n        compile 'com.android.support:support-v13:20.1.1'\n    }\n\n\n以上是标准的打包方式,下面是常用的我们自定义的内容   \n        \n        dependencies {\n            compile fileTree(include: '*.jar', dir: 'libs')\n            compile project(':google_services')\n    \n            // compile 'com.android.support:multidex:1.0.1'\n            compile 'top.zibin:Luban:1.0.9'\n            debugCompile 'com.bugtags.library:bugtags-lib:latest.integration'\n            \n            testCompile 'junit:junit:4.12'\n           \n        }\n        \n        android {\n            compileSdkVersion 21\n            buildToolsVersion '23.0.2'\n        \n            sourceSets {\n                main {\n                    manifest.srcFile 'AndroidManifest.xml'\n                    java.srcDirs = ['src']\n                    resources.srcDirs = ['src']\n                    aidl.srcDirs = ['src']\n                    renderscript.srcDirs = ['src']\n                    res.srcDirs = ['res']\n                    assets.srcDirs = ['assets']\n                    jniLibs.srcDirs = ['libs']\n                }\n        \n                test.setRoot('test')\n              \n                debug.setRoot('build-types/debug')\n                release.setRoot('build-types/release')\n            }\n        \n            signingConfigs {\n                debug {\n                    // 请配置好pub.key及其密码，或者改为使用debug.keystore\n                    storeFile file('pub.key') // storeFile file('debug.keystore')\n                    storePassword STORE_PASSWORD\n                    keyAlias KEY_ALIAS\n                    keyPassword KEY_PASSWORD\n                }\n                release {\n                    storeFile file('pub.key')\n                    storePassword STORE_PASSWORD\n                    keyAlias KEY_ALIAS\n                    keyPassword KEY_PASSWORD\n                }\n            }\n        \n            buildTypes {\n                debug {\n                    buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"Not yet\\\"\"\n                    buildConfigField \"boolean\", \"DEVELOP_MODE\", \"true\"\n                    signingConfig signingConfigs.debug\n        \n                    ndk{\n                        abiFilters 'armeabi', 'armeabi-v7a', 'x86' //,'arm64-v8a', 'x86_64', 'mips', 'mips64'\n                    }\n                }\n                release {\n                    buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"2016/12/22\\\"\" // TODO 发布时修改为当天日期\n                    buildConfigField \"boolean\", \"DEVELOP_MODE\", \"false\" // 关闭开发者模式\n                    proguardFiles 'proguard.cfg'\n                    minifyEnabled true\n                    shrinkResources true\n                    debuggable false\n                    jniDebuggable false\n                    signingConfig signingConfigs.release\n        \n                    applicationVariants.all { variant ->\n                        variant.outputs.each { output ->\n                            def outputFile = output.outputFile\n                            if (outputFile != null && outputFile.name.endsWith('.apk')) {\n                                // APK命名格式 Going-release.apk TODO 发布时使用\n                                def fileName = \"Going-v${defaultConfig.versionName}-${defaultConfig.versionCode}-release.apk\"\n        //                         def fileName = \"Going.apk\"\n                                output.outputFile = new File(outputFile.parent, fileName)\n                            }\n                        }\n                    }\n                }\n            }\n        \n            defaultConfig {\n                minSdkVersion 14\n                targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n                versionCode 5220\n                versionName \"5.2.2\"\n                //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:\"googleMarket\" ]\n                multiDexEnabled false\n                multiDexKeepProguard file('multiDexKeep.pro')\n                resConfigs \"en\", \"zh_CN\", \"zh_TW\" //暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n            }\n        \n            productFlavors {\n                  own {}\n                  googleMarket {}\n  \n                  tencent {}\n                  baidu {}\n        \n       \n            }\n        \n        //    productFlavors.all { flavor ->\n        //        flavor.manifestPlaceholders = [ UMENG_CHANNEL_VALUE:name ]\n        //    }\n        \n            packagingOptions {\n                exclude 'META-INF/LICENSE.txt'\n            }\n        \n            // 可以适当的打开Lint，检查是否存在隐藏问题\n            lintOptions {\n                checkReleaseBuilds false\n                abortOnError false\n            }\n        \n            android.dexOptions {\n                jumboMode = true\n                javaMaxHeapSize \"2g\"\n                maxProcessCount 8\n            }\n        \n        }\n        \n        // 替换编码方式，否则编译可能有中文乱码\n        tasks.withType(org.gradle.api.tasks.compile.JavaCompile) {\n            options.encoding = \"UTF-8\"\n        }\n\n\n\n\n相对于标准的我们在 android Task中新增了sourceSets这个Task制定了一些文件夹的目录，如果工程目录是标注的就不需要设置了\n\n\n在build.gradle同级新建一个gradle.properties\n里面可以用来存放build.gradle里面的一些参数\nSTORE_PASSWORD=nico\nKEY_ALIAS=nick\nKEY_PASSWORD=nico\n\n\n这个地方对应的脚本是signingConfigs》debug里面的参数 \n\n\n buildTypes 》debug 中的buildConfigField参数则会在编译时候  \n \n ![gradle01](https://github.com/liuyicheng3/learning-summary/blob/master/images/gradle%E5%88%86%E6%9E%9001.png?raw=true)\n \n                buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"Not yet\\\"\"\n                buildConfigField \"boolean\", \"DEVELOP_MODE\", \"true\"\n\n会在\n\n        public final class BuildConfig {\n          public static final boolean DEBUG = Boolean.parseBoolean(\"true\");\n          public static final String APPLICATION_ID = \"im.ecloud.ecalendar\";\n          public static final String BUILD_TYPE = \"debug\";\n          public static final String FLAVOR = \"own\";\n          public static final int VERSION_CODE = 5220;\n          public static final String VERSION_NAME = \"5.2.2\";\n          // Fields from build type: debug\n          public static final boolean DEVELOP_MODE = true;\n          public static final String RELEASE_TIME = \"Not yet\";\n        }\n\n\n可以参考友盟的多渠道打包（github）\n\n\n一个介绍gradle比较好的网站\nhttp://stormzhang.com/posts/\n\n\nhttps://segmentfault.com/a/1190000006915937\n\n这两个网站都是一系列的教程，建议一个一个的看\n","source":"_posts/Gradle小结.md","raw":"title: Gradle配置中介\ndate: 2015-11-01 20:10:33\ncategories:\n- android\ntags:\n- 工具\n- 打包\n\n---\n\n\n\nbuildGradle配置分析  \nTopicLevel的gradle    \n\n    buildscript {\n        repositories {\n            jcenter()\n        }\n        dependencies {\n            classpath 'com.android.tools.build:gradle:2.2.2'\n    \n            // NOTE: Do not place your application dependencies here; they belong\n            // in the individual module build.gradle files\n        }\n    }\n    allprojects {\n        repositories {\n            jcenter()\n        }\n    }\n    task clean(type: Delete) {\n        delete rootProject.buildDir\n    }\n\n\n\n\nMudule level的build.gradle  \n    \n    apply plugin: 'com.android.application'\n    \n    android {\n        compileSdkVersion 20\n        buildToolsVersion \"24.0.0\"\n    \n    \n        compileOptions{\n            sourceCompatibility JavaVersion.VERSION_1_8\n            targetCompatibility JavaVersion.VERSION_1_8\n        }\n    \n        defaultConfig {\n            applicationId \"com.lyc.study\"\n            minSdkVersion 15\n            targetSdkVersion 20\n            versionCode 1\n            versionName \"1.0\"\n            jackOptions{\n                enabled true\n            }\n        }\n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            }\n        }\n    }\n    \n    dependencies {\n        compile fileTree(include: ['*.jar'], dir: 'libs')\n        compile 'com.android.support:support-v4:+'\n        compile 'com.android.support:support-annotations:22.2.0'\n        compile 'com.android.support:support-v13:20.1.1'\n    }\n\n\n以上是标准的打包方式,下面是常用的我们自定义的内容   \n        \n        dependencies {\n            compile fileTree(include: '*.jar', dir: 'libs')\n            compile project(':google_services')\n    \n            // compile 'com.android.support:multidex:1.0.1'\n            compile 'top.zibin:Luban:1.0.9'\n            debugCompile 'com.bugtags.library:bugtags-lib:latest.integration'\n            \n            testCompile 'junit:junit:4.12'\n           \n        }\n        \n        android {\n            compileSdkVersion 21\n            buildToolsVersion '23.0.2'\n        \n            sourceSets {\n                main {\n                    manifest.srcFile 'AndroidManifest.xml'\n                    java.srcDirs = ['src']\n                    resources.srcDirs = ['src']\n                    aidl.srcDirs = ['src']\n                    renderscript.srcDirs = ['src']\n                    res.srcDirs = ['res']\n                    assets.srcDirs = ['assets']\n                    jniLibs.srcDirs = ['libs']\n                }\n        \n                test.setRoot('test')\n              \n                debug.setRoot('build-types/debug')\n                release.setRoot('build-types/release')\n            }\n        \n            signingConfigs {\n                debug {\n                    // 请配置好pub.key及其密码，或者改为使用debug.keystore\n                    storeFile file('pub.key') // storeFile file('debug.keystore')\n                    storePassword STORE_PASSWORD\n                    keyAlias KEY_ALIAS\n                    keyPassword KEY_PASSWORD\n                }\n                release {\n                    storeFile file('pub.key')\n                    storePassword STORE_PASSWORD\n                    keyAlias KEY_ALIAS\n                    keyPassword KEY_PASSWORD\n                }\n            }\n        \n            buildTypes {\n                debug {\n                    buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"Not yet\\\"\"\n                    buildConfigField \"boolean\", \"DEVELOP_MODE\", \"true\"\n                    signingConfig signingConfigs.debug\n        \n                    ndk{\n                        abiFilters 'armeabi', 'armeabi-v7a', 'x86' //,'arm64-v8a', 'x86_64', 'mips', 'mips64'\n                    }\n                }\n                release {\n                    buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"2016/12/22\\\"\" // TODO 发布时修改为当天日期\n                    buildConfigField \"boolean\", \"DEVELOP_MODE\", \"false\" // 关闭开发者模式\n                    proguardFiles 'proguard.cfg'\n                    minifyEnabled true\n                    shrinkResources true\n                    debuggable false\n                    jniDebuggable false\n                    signingConfig signingConfigs.release\n        \n                    applicationVariants.all { variant ->\n                        variant.outputs.each { output ->\n                            def outputFile = output.outputFile\n                            if (outputFile != null && outputFile.name.endsWith('.apk')) {\n                                // APK命名格式 Going-release.apk TODO 发布时使用\n                                def fileName = \"Going-v${defaultConfig.versionName}-${defaultConfig.versionCode}-release.apk\"\n        //                         def fileName = \"Going.apk\"\n                                output.outputFile = new File(outputFile.parent, fileName)\n                            }\n                        }\n                    }\n                }\n            }\n        \n            defaultConfig {\n                minSdkVersion 14\n                targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n                versionCode 5220\n                versionName \"5.2.2\"\n                //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:\"googleMarket\" ]\n                multiDexEnabled false\n                multiDexKeepProguard file('multiDexKeep.pro')\n                resConfigs \"en\", \"zh_CN\", \"zh_TW\" //暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n            }\n        \n            productFlavors {\n                  own {}\n                  googleMarket {}\n  \n                  tencent {}\n                  baidu {}\n        \n       \n            }\n        \n        //    productFlavors.all { flavor ->\n        //        flavor.manifestPlaceholders = [ UMENG_CHANNEL_VALUE:name ]\n        //    }\n        \n            packagingOptions {\n                exclude 'META-INF/LICENSE.txt'\n            }\n        \n            // 可以适当的打开Lint，检查是否存在隐藏问题\n            lintOptions {\n                checkReleaseBuilds false\n                abortOnError false\n            }\n        \n            android.dexOptions {\n                jumboMode = true\n                javaMaxHeapSize \"2g\"\n                maxProcessCount 8\n            }\n        \n        }\n        \n        // 替换编码方式，否则编译可能有中文乱码\n        tasks.withType(org.gradle.api.tasks.compile.JavaCompile) {\n            options.encoding = \"UTF-8\"\n        }\n\n\n\n\n相对于标准的我们在 android Task中新增了sourceSets这个Task制定了一些文件夹的目录，如果工程目录是标注的就不需要设置了\n\n\n在build.gradle同级新建一个gradle.properties\n里面可以用来存放build.gradle里面的一些参数\nSTORE_PASSWORD=nico\nKEY_ALIAS=nick\nKEY_PASSWORD=nico\n\n\n这个地方对应的脚本是signingConfigs》debug里面的参数 \n\n\n buildTypes 》debug 中的buildConfigField参数则会在编译时候  \n \n ![gradle01](https://github.com/liuyicheng3/learning-summary/blob/master/images/gradle%E5%88%86%E6%9E%9001.png?raw=true)\n \n                buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"Not yet\\\"\"\n                buildConfigField \"boolean\", \"DEVELOP_MODE\", \"true\"\n\n会在\n\n        public final class BuildConfig {\n          public static final boolean DEBUG = Boolean.parseBoolean(\"true\");\n          public static final String APPLICATION_ID = \"im.ecloud.ecalendar\";\n          public static final String BUILD_TYPE = \"debug\";\n          public static final String FLAVOR = \"own\";\n          public static final int VERSION_CODE = 5220;\n          public static final String VERSION_NAME = \"5.2.2\";\n          // Fields from build type: debug\n          public static final boolean DEVELOP_MODE = true;\n          public static final String RELEASE_TIME = \"Not yet\";\n        }\n\n\n可以参考友盟的多渠道打包（github）\n\n\n一个介绍gradle比较好的网站\nhttp://stormzhang.com/posts/\n\n\nhttps://segmentfault.com/a/1190000006915937\n\n这两个网站都是一系列的教程，建议一个一个的看\n","slug":"Gradle小结","published":1,"updated":"2017-03-17T13:30:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7bj00041rjjduvxjx5y","content":"<p>buildGradle配置分析<br>TopicLevel的gradle    </p>\n<pre><code>buildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n</code></pre><p>Mudule level的build.gradle  </p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n\nandroid {\n    compileSdkVersion 20\n    buildToolsVersion &quot;24.0.0&quot;\n\n\n    compileOptions{\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    defaultConfig {\n        applicationId &quot;com.lyc.study&quot;\n        minSdkVersion 15\n        targetSdkVersion 20\n        versionCode 1\n        versionName &quot;1.0&quot;\n        jackOptions{\n            enabled true\n        }\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n\ndependencies {\n    compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)\n    compile &apos;com.android.support:support-v4:+&apos;\n    compile &apos;com.android.support:support-annotations:22.2.0&apos;\n    compile &apos;com.android.support:support-v13:20.1.1&apos;\n}\n</code></pre><p>以上是标准的打包方式,下面是常用的我们自定义的内容   </p>\n<pre><code>dependencies {\n    compile fileTree(include: &apos;*.jar&apos;, dir: &apos;libs&apos;)\n    compile project(&apos;:google_services&apos;)\n\n    // compile &apos;com.android.support:multidex:1.0.1&apos;\n    compile &apos;top.zibin:Luban:1.0.9&apos;\n    debugCompile &apos;com.bugtags.library:bugtags-lib:latest.integration&apos;\n\n    testCompile &apos;junit:junit:4.12&apos;\n\n}\n\nandroid {\n    compileSdkVersion 21\n    buildToolsVersion &apos;23.0.2&apos;\n\n    sourceSets {\n        main {\n            manifest.srcFile &apos;AndroidManifest.xml&apos;\n            java.srcDirs = [&apos;src&apos;]\n            resources.srcDirs = [&apos;src&apos;]\n            aidl.srcDirs = [&apos;src&apos;]\n            renderscript.srcDirs = [&apos;src&apos;]\n            res.srcDirs = [&apos;res&apos;]\n            assets.srcDirs = [&apos;assets&apos;]\n            jniLibs.srcDirs = [&apos;libs&apos;]\n        }\n\n        test.setRoot(&apos;test&apos;)\n\n        debug.setRoot(&apos;build-types/debug&apos;)\n        release.setRoot(&apos;build-types/release&apos;)\n    }\n\n    signingConfigs {\n        debug {\n            // 请配置好pub.key及其密码，或者改为使用debug.keystore\n            storeFile file(&apos;pub.key&apos;) // storeFile file(&apos;debug.keystore&apos;)\n            storePassword STORE_PASSWORD\n            keyAlias KEY_ALIAS\n            keyPassword KEY_PASSWORD\n        }\n        release {\n            storeFile file(&apos;pub.key&apos;)\n            storePassword STORE_PASSWORD\n            keyAlias KEY_ALIAS\n            keyPassword KEY_PASSWORD\n        }\n    }\n\n    buildTypes {\n        debug {\n            buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;Not yet\\&quot;&quot;\n            buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;true&quot;\n            signingConfig signingConfigs.debug\n\n            ndk{\n                abiFilters &apos;armeabi&apos;, &apos;armeabi-v7a&apos;, &apos;x86&apos; //,&apos;arm64-v8a&apos;, &apos;x86_64&apos;, &apos;mips&apos;, &apos;mips64&apos;\n            }\n        }\n        release {\n            buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;2016/12/22\\&quot;&quot; // TODO 发布时修改为当天日期\n            buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;false&quot; // 关闭开发者模式\n            proguardFiles &apos;proguard.cfg&apos;\n            minifyEnabled true\n            shrinkResources true\n            debuggable false\n            jniDebuggable false\n            signingConfig signingConfigs.release\n\n            applicationVariants.all { variant -&gt;\n                variant.outputs.each { output -&gt;\n                    def outputFile = output.outputFile\n                    if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) {\n                        // APK命名格式 Going-release.apk TODO 发布时使用\n                        def fileName = &quot;Going-v${defaultConfig.versionName}-${defaultConfig.versionCode}-release.apk&quot;\n//                         def fileName = &quot;Going.apk&quot;\n                        output.outputFile = new File(outputFile.parent, fileName)\n                    }\n                }\n            }\n        }\n    }\n\n    defaultConfig {\n        minSdkVersion 14\n        targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n        versionCode 5220\n        versionName &quot;5.2.2&quot;\n        //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:&quot;googleMarket&quot; ]\n        multiDexEnabled false\n        multiDexKeepProguard file(&apos;multiDexKeep.pro&apos;)\n        resConfigs &quot;en&quot;, &quot;zh_CN&quot;, &quot;zh_TW&quot; //暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n    }\n\n    productFlavors {\n          own {}\n          googleMarket {}\n\n          tencent {}\n          baidu {}\n\n\n    }\n\n//    productFlavors.all { flavor -&gt;\n//        flavor.manifestPlaceholders = [ UMENG_CHANNEL_VALUE:name ]\n//    }\n\n    packagingOptions {\n        exclude &apos;META-INF/LICENSE.txt&apos;\n    }\n\n    // 可以适当的打开Lint，检查是否存在隐藏问题\n    lintOptions {\n        checkReleaseBuilds false\n        abortOnError false\n    }\n\n    android.dexOptions {\n        jumboMode = true\n        javaMaxHeapSize &quot;2g&quot;\n        maxProcessCount 8\n    }\n\n}\n\n// 替换编码方式，否则编译可能有中文乱码\ntasks.withType(org.gradle.api.tasks.compile.JavaCompile) {\n    options.encoding = &quot;UTF-8&quot;\n}\n</code></pre><p>相对于标准的我们在 android Task中新增了sourceSets这个Task制定了一些文件夹的目录，如果工程目录是标注的就不需要设置了</p>\n<p>在build.gradle同级新建一个gradle.properties<br>里面可以用来存放build.gradle里面的一些参数<br>STORE_PASSWORD=nico<br>KEY_ALIAS=nick<br>KEY_PASSWORD=nico</p>\n<p>这个地方对应的脚本是signingConfigs》debug里面的参数 </p>\n<p> buildTypes 》debug 中的buildConfigField参数则会在编译时候  </p>\n<p> <img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/gradle%E5%88%86%E6%9E%9001.png?raw=true\" alt=\"gradle01\"></p>\n<pre><code>buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;Not yet\\&quot;&quot;\nbuildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;true&quot;\n</code></pre><p>会在</p>\n<pre><code>public final class BuildConfig {\n  public static final boolean DEBUG = Boolean.parseBoolean(&quot;true&quot;);\n  public static final String APPLICATION_ID = &quot;im.ecloud.ecalendar&quot;;\n  public static final String BUILD_TYPE = &quot;debug&quot;;\n  public static final String FLAVOR = &quot;own&quot;;\n  public static final int VERSION_CODE = 5220;\n  public static final String VERSION_NAME = &quot;5.2.2&quot;;\n  // Fields from build type: debug\n  public static final boolean DEVELOP_MODE = true;\n  public static final String RELEASE_TIME = &quot;Not yet&quot;;\n}\n</code></pre><p>可以参考友盟的多渠道打包（github）</p>\n<p>一个介绍gradle比较好的网站<br><a href=\"http://stormzhang.com/posts/\" target=\"_blank\" rel=\"external\">http://stormzhang.com/posts/</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006915937\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000006915937</a></p>\n<p>这两个网站都是一系列的教程，建议一个一个的看</p>\n","excerpt":"","more":"<p>buildGradle配置分析<br>TopicLevel的gradle    </p>\n<pre><code>buildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n</code></pre><p>Mudule level的build.gradle  </p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n\nandroid {\n    compileSdkVersion 20\n    buildToolsVersion &quot;24.0.0&quot;\n\n\n    compileOptions{\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    defaultConfig {\n        applicationId &quot;com.lyc.study&quot;\n        minSdkVersion 15\n        targetSdkVersion 20\n        versionCode 1\n        versionName &quot;1.0&quot;\n        jackOptions{\n            enabled true\n        }\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n\ndependencies {\n    compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)\n    compile &apos;com.android.support:support-v4:+&apos;\n    compile &apos;com.android.support:support-annotations:22.2.0&apos;\n    compile &apos;com.android.support:support-v13:20.1.1&apos;\n}\n</code></pre><p>以上是标准的打包方式,下面是常用的我们自定义的内容   </p>\n<pre><code>dependencies {\n    compile fileTree(include: &apos;*.jar&apos;, dir: &apos;libs&apos;)\n    compile project(&apos;:google_services&apos;)\n\n    // compile &apos;com.android.support:multidex:1.0.1&apos;\n    compile &apos;top.zibin:Luban:1.0.9&apos;\n    debugCompile &apos;com.bugtags.library:bugtags-lib:latest.integration&apos;\n\n    testCompile &apos;junit:junit:4.12&apos;\n\n}\n\nandroid {\n    compileSdkVersion 21\n    buildToolsVersion &apos;23.0.2&apos;\n\n    sourceSets {\n        main {\n            manifest.srcFile &apos;AndroidManifest.xml&apos;\n            java.srcDirs = [&apos;src&apos;]\n            resources.srcDirs = [&apos;src&apos;]\n            aidl.srcDirs = [&apos;src&apos;]\n            renderscript.srcDirs = [&apos;src&apos;]\n            res.srcDirs = [&apos;res&apos;]\n            assets.srcDirs = [&apos;assets&apos;]\n            jniLibs.srcDirs = [&apos;libs&apos;]\n        }\n\n        test.setRoot(&apos;test&apos;)\n\n        debug.setRoot(&apos;build-types/debug&apos;)\n        release.setRoot(&apos;build-types/release&apos;)\n    }\n\n    signingConfigs {\n        debug {\n            // 请配置好pub.key及其密码，或者改为使用debug.keystore\n            storeFile file(&apos;pub.key&apos;) // storeFile file(&apos;debug.keystore&apos;)\n            storePassword STORE_PASSWORD\n            keyAlias KEY_ALIAS\n            keyPassword KEY_PASSWORD\n        }\n        release {\n            storeFile file(&apos;pub.key&apos;)\n            storePassword STORE_PASSWORD\n            keyAlias KEY_ALIAS\n            keyPassword KEY_PASSWORD\n        }\n    }\n\n    buildTypes {\n        debug {\n            buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;Not yet\\&quot;&quot;\n            buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;true&quot;\n            signingConfig signingConfigs.debug\n\n            ndk{\n                abiFilters &apos;armeabi&apos;, &apos;armeabi-v7a&apos;, &apos;x86&apos; //,&apos;arm64-v8a&apos;, &apos;x86_64&apos;, &apos;mips&apos;, &apos;mips64&apos;\n            }\n        }\n        release {\n            buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;2016/12/22\\&quot;&quot; // TODO 发布时修改为当天日期\n            buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;false&quot; // 关闭开发者模式\n            proguardFiles &apos;proguard.cfg&apos;\n            minifyEnabled true\n            shrinkResources true\n            debuggable false\n            jniDebuggable false\n            signingConfig signingConfigs.release\n\n            applicationVariants.all { variant -&gt;\n                variant.outputs.each { output -&gt;\n                    def outputFile = output.outputFile\n                    if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) {\n                        // APK命名格式 Going-release.apk TODO 发布时使用\n                        def fileName = &quot;Going-v${defaultConfig.versionName}-${defaultConfig.versionCode}-release.apk&quot;\n//                         def fileName = &quot;Going.apk&quot;\n                        output.outputFile = new File(outputFile.parent, fileName)\n                    }\n                }\n            }\n        }\n    }\n\n    defaultConfig {\n        minSdkVersion 14\n        targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n        versionCode 5220\n        versionName &quot;5.2.2&quot;\n        //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:&quot;googleMarket&quot; ]\n        multiDexEnabled false\n        multiDexKeepProguard file(&apos;multiDexKeep.pro&apos;)\n        resConfigs &quot;en&quot;, &quot;zh_CN&quot;, &quot;zh_TW&quot; //暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n    }\n\n    productFlavors {\n          own {}\n          googleMarket {}\n\n          tencent {}\n          baidu {}\n\n\n    }\n\n//    productFlavors.all { flavor -&gt;\n//        flavor.manifestPlaceholders = [ UMENG_CHANNEL_VALUE:name ]\n//    }\n\n    packagingOptions {\n        exclude &apos;META-INF/LICENSE.txt&apos;\n    }\n\n    // 可以适当的打开Lint，检查是否存在隐藏问题\n    lintOptions {\n        checkReleaseBuilds false\n        abortOnError false\n    }\n\n    android.dexOptions {\n        jumboMode = true\n        javaMaxHeapSize &quot;2g&quot;\n        maxProcessCount 8\n    }\n\n}\n\n// 替换编码方式，否则编译可能有中文乱码\ntasks.withType(org.gradle.api.tasks.compile.JavaCompile) {\n    options.encoding = &quot;UTF-8&quot;\n}\n</code></pre><p>相对于标准的我们在 android Task中新增了sourceSets这个Task制定了一些文件夹的目录，如果工程目录是标注的就不需要设置了</p>\n<p>在build.gradle同级新建一个gradle.properties<br>里面可以用来存放build.gradle里面的一些参数<br>STORE_PASSWORD=nico<br>KEY_ALIAS=nick<br>KEY_PASSWORD=nico</p>\n<p>这个地方对应的脚本是signingConfigs》debug里面的参数 </p>\n<p> buildTypes 》debug 中的buildConfigField参数则会在编译时候  </p>\n<p> <img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/gradle%E5%88%86%E6%9E%9001.png?raw=true\" alt=\"gradle01\"></p>\n<pre><code>buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;Not yet\\&quot;&quot;\nbuildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;true&quot;\n</code></pre><p>会在</p>\n<pre><code>public final class BuildConfig {\n  public static final boolean DEBUG = Boolean.parseBoolean(&quot;true&quot;);\n  public static final String APPLICATION_ID = &quot;im.ecloud.ecalendar&quot;;\n  public static final String BUILD_TYPE = &quot;debug&quot;;\n  public static final String FLAVOR = &quot;own&quot;;\n  public static final int VERSION_CODE = 5220;\n  public static final String VERSION_NAME = &quot;5.2.2&quot;;\n  // Fields from build type: debug\n  public static final boolean DEVELOP_MODE = true;\n  public static final String RELEASE_TIME = &quot;Not yet&quot;;\n}\n</code></pre><p>可以参考友盟的多渠道打包（github）</p>\n<p>一个介绍gradle比较好的网站<br><a href=\"http://stormzhang.com/posts/\">http://stormzhang.com/posts/</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006915937\">https://segmentfault.com/a/1190000006915937</a></p>\n<p>这两个网站都是一系列的教程，建议一个一个的看</p>\n"},{"title":"AS和Xcode快捷键","date":"2015-11-01T12:10:33.000Z","_content":"\n# Xcode \n\nXCode   不能直接修改文件名，需要找到本文件对应的申明或者实现的名称，右键refactor>rename  修改\n（记得勾选 Rename related files）\n\n\n在 Xcode里面所有的窗口控制显示与否都可以通过右上角的来控制  \n\n\n定位类的位置  shift  commoand  j\n\ncommond  6 \n\n\noption 然后点击方法位置\n\ncommond   T\n\nshift  commoand  O\n\nshift  commoand  F\n\n commoand  F\n\n\nesc  查看方法参数   \n\n\n快捷键位置方法   XCode>preferences>Key Bindings\n\n显示主题颜色设置   XCode>preferences>Font & Colors   从Default  改成   Dusk \n窗口显示和隐藏的button（其中代码下面的debug和log窗口在他们的右下角又有单独的控制显示和隐藏的button）  \n\n![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E8%AE%BE%E7%BD%AE.png?raw=true)\n\n![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg?raw=true)  \n\n\n参考资料：http://www.cocoachina.com/ios/20141224/10752.html\n\n\n\n# AndroidStudio  \n\n快捷键位置方法   AndroidStudio>preferences>Keymap  （把Mac  OS X 复制一份，然后修改）\n\n\n显示主题颜色设置   AndroidStudio>preferences>Editor>Colors & Font   从Default  改成   Darcula  (然后点击 save as  ，再把字体调大一点，不能直接修改) \n","source":"_posts/Xcode 和Android  studio 快捷键及设置对比.md","raw":"title: AS和Xcode快捷键\ndate: 2015-11-01 20:10:33\ncategories:\n- 工具\ntags:\n- 工具\n\n---\n\n# Xcode \n\nXCode   不能直接修改文件名，需要找到本文件对应的申明或者实现的名称，右键refactor>rename  修改\n（记得勾选 Rename related files）\n\n\n在 Xcode里面所有的窗口控制显示与否都可以通过右上角的来控制  \n\n\n定位类的位置  shift  commoand  j\n\ncommond  6 \n\n\noption 然后点击方法位置\n\ncommond   T\n\nshift  commoand  O\n\nshift  commoand  F\n\n commoand  F\n\n\nesc  查看方法参数   \n\n\n快捷键位置方法   XCode>preferences>Key Bindings\n\n显示主题颜色设置   XCode>preferences>Font & Colors   从Default  改成   Dusk \n窗口显示和隐藏的button（其中代码下面的debug和log窗口在他们的右下角又有单独的控制显示和隐藏的button）  \n\n![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E8%AE%BE%E7%BD%AE.png?raw=true)\n\n![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg?raw=true)  \n\n\n参考资料：http://www.cocoachina.com/ios/20141224/10752.html\n\n\n\n# AndroidStudio  \n\n快捷键位置方法   AndroidStudio>preferences>Keymap  （把Mac  OS X 复制一份，然后修改）\n\n\n显示主题颜色设置   AndroidStudio>preferences>Editor>Colors & Font   从Default  改成   Darcula  (然后点击 save as  ，再把字体调大一点，不能直接修改) \n","slug":"Xcode 和Android  studio 快捷键及设置对比","published":1,"updated":"2017-03-17T13:34:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7bl00051rjjnf30wxgg","content":"<h1 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h1><p>XCode   不能直接修改文件名，需要找到本文件对应的申明或者实现的名称，右键refactor&gt;rename  修改<br>（记得勾选 Rename related files）</p>\n<p>在 Xcode里面所有的窗口控制显示与否都可以通过右上角的来控制  </p>\n<p>定位类的位置  shift  commoand  j</p>\n<p>commond  6 </p>\n<p>option 然后点击方法位置</p>\n<p>commond   T</p>\n<p>shift  commoand  O</p>\n<p>shift  commoand  F</p>\n<p> commoand  F</p>\n<p>esc  查看方法参数   </p>\n<p>快捷键位置方法   XCode&gt;preferences&gt;Key Bindings</p>\n<p>显示主题颜色设置   XCode&gt;preferences&gt;Font &amp; Colors   从Default  改成   Dusk<br>窗口显示和隐藏的button（其中代码下面的debug和log窗口在他们的右下角又有单独的控制显示和隐藏的button）  </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E8%AE%BE%E7%BD%AE.png?raw=true\" alt=\"image\"></p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg?raw=true\" alt=\"image\">  </p>\n<p>参考资料：<a href=\"http://www.cocoachina.com/ios/20141224/10752.html\" target=\"_blank\" rel=\"external\">http://www.cocoachina.com/ios/20141224/10752.html</a></p>\n<h1 id=\"AndroidStudio\"><a href=\"#AndroidStudio\" class=\"headerlink\" title=\"AndroidStudio\"></a>AndroidStudio</h1><p>快捷键位置方法   AndroidStudio&gt;preferences&gt;Keymap  （把Mac  OS X 复制一份，然后修改）</p>\n<p>显示主题颜色设置   AndroidStudio&gt;preferences&gt;Editor&gt;Colors &amp; Font   从Default  改成   Darcula  (然后点击 save as  ，再把字体调大一点，不能直接修改) </p>\n","excerpt":"","more":"<h1 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h1><p>XCode   不能直接修改文件名，需要找到本文件对应的申明或者实现的名称，右键refactor&gt;rename  修改<br>（记得勾选 Rename related files）</p>\n<p>在 Xcode里面所有的窗口控制显示与否都可以通过右上角的来控制  </p>\n<p>定位类的位置  shift  commoand  j</p>\n<p>commond  6 </p>\n<p>option 然后点击方法位置</p>\n<p>commond   T</p>\n<p>shift  commoand  O</p>\n<p>shift  commoand  F</p>\n<p> commoand  F</p>\n<p>esc  查看方法参数   </p>\n<p>快捷键位置方法   XCode&gt;preferences&gt;Key Bindings</p>\n<p>显示主题颜色设置   XCode&gt;preferences&gt;Font &amp; Colors   从Default  改成   Dusk<br>窗口显示和隐藏的button（其中代码下面的debug和log窗口在他们的右下角又有单独的控制显示和隐藏的button）  </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E8%AE%BE%E7%BD%AE.png?raw=true\" alt=\"image\"></p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg?raw=true\" alt=\"image\">  </p>\n<p>参考资料：<a href=\"http://www.cocoachina.com/ios/20141224/10752.html\">http://www.cocoachina.com/ios/20141224/10752.html</a></p>\n<h1 id=\"AndroidStudio\"><a href=\"#AndroidStudio\" class=\"headerlink\" title=\"AndroidStudio\"></a>AndroidStudio</h1><p>快捷键位置方法   AndroidStudio&gt;preferences&gt;Keymap  （把Mac  OS X 复制一份，然后修改）</p>\n<p>显示主题颜色设置   AndroidStudio&gt;preferences&gt;Editor&gt;Colors &amp; Font   从Default  改成   Darcula  (然后点击 save as  ，再把字体调大一点，不能直接修改) </p>\n"},{"title":"Deeplink 设计","date":"2015-11-01T12:10:33.000Z","_content":"\n\n#deeplink指的是在第三方客户端/浏览器中，打开一个APP的H5页面时候，如果发现本地安装了这个APP，就会使用本地APP打开。\n需要前端和客户端互相配合来实现本功能。\n\n#服务器端：\n\n    <html>\n    <head>\n    <meta property=\"al:ios:url\" content=\"applinks://docs\" />\n    <meta property=\"al:ios:app_store_id\" content=\"12345\" />\n    <meta property=\"al:ios:app_name\" content=\"App Links\" />\n    <meta property=\"al:android:url\" content=\"applinks://docs\" />\n    <meta property=\"al:android:app_name\" content=\"App Links\" />\n    <meta property=\"al:android:package\" content=\"org.applinks\" />\n    <meta property=\"al:web:url\"\n    content=\"http://applinks.org/documentation\" />\n    </head>\n    <body>\n    Hello, world!\n    </body>\n    </html>\n\n#客户端  \n客户端deeplink的实现需要依靠jump系统。ps:jump系统可以通过URI 实现在app中的定向跳转 ，比如我们的app叫“天上人间”（缩写tsrj）。 \n\n1. 需要先在menifest中注册相应的scheme的filter。  \n   ps:一般加载主页上面.\n\n\n        <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n        <category android:name=\"android.intent.category.BROWSABLE\"/>\n        <!-- Accepts URIs that begin with \"tsrj://\" -->\n        <data android:scheme=\"tsrj\"/>\n        </intent-filter>\n        <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n        <category android:name=\"android.intent.category.BROWSABLE\"/>\n        <!-- Accepts URIs that begin with \"http://m.tsrj.com/\" -->\n        <data\n        android:host=\"m.tsrj.com\"\n        android:pathPrefix=\"/\"\n        android:scheme=\"http\"/>\n        <data\n        android:host=\"m.tsrj.com\"\n        android:pathPrefix=\"/\"\n        android:scheme=\"https\"/>\n        </intent-filter>\n    \n2. 在MainActivity新增解析jump信息的方法\n\n\n        private void jump(Intent intent) {\n        /** 根据传过来的参数 进行jump跳转 **/\n        String action_url = intent.getDataString();\n        MLog.i(\"启动Main_action_url:\" + action_url);\n        if (!TextUtils.isEmpty(action_url)) {\n        JumpManager.jump(this, action_url);\n        } \n        }\n        \n        JumpManger就实现解析数据然后根据URI跳转的功能\n        public static boolean jump(Context ctx, String action_url) {\n        \n        if (TextUtils.isEmpty(action_url)) {\n        return false;\n        }\n        \n        MLog.d(\"JumpManager  url:\" + action_url);\n        \n        Uri uri = null;\n        \n        /**如果不是一个标准的uri格式说明传入的数据无效的 可以直接忽视*/\n        \n        try {\n        uri = Uri.parse(action_url);\n        } catch (Exception e) {\n        return false;\n        }\n        \n        if (uri == null) {\n        return false;\n        }\n        \n        /**检测到是一个合法的uri 先判断是否是满足跳转需求的头部 如果是 开始进行跳转检测 如果不是 直接往内置浏览器跳*/\n        \n        if (!action_url.startsWith(JumpUriFactory.JUM_URL_HEAD) && !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_S) && !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_CUSTOM)) {\n        \n        return false;\n        }\n        \n        Intent jumpintent = null;\n        \n        List<String> paths = uri.getPathSegments();\n        \n        /**只有头没有页面参数就返回*/\n        if (paths == null || paths.size() <= 0) {\n        \n        return false;\n        }\n        \n        /**有path 但是path里面为空值 直接打开*/\n        String action = paths.get(0);\n        if (TextUtils.isEmpty(action)) {\n        if (!isFromWebView) {\n        jumpToInteriorPageActivity(ctx, uri);\n        }\n        return false;\n        }\n        \n        /** 使用系统浏览器打开 */\n        if (action.equals(\"web_system\")) {\n        jumpToSystemWebPage(ctx, uri);\n        return true;\n        }\n        \n        \n        /*else if (action.equals(JumpPageSet.detail)) {\n        goWaitress(ctx, action_url);\n        return true;\n        }*/\n        \n        /** city */\n        else if (action.equals(JumpPageSet.city)) {\n        goCity(ctx, action_url);\n        return true;\n        }\n        \n        /** usercenter */\n        else if (action.equals(JumpPageSet.personal_info)) {\n        goUserCenter(ctx, action_url);\n        return true;\n        }\n\n\n3. 处理uri解析出里面的参数,放入intent，并跳往相应的主页\n\n\n        /**\n         * 将url的数据进行解析 得到一个存放所有参数的集合\n         */\n        public static Set<String> getMyQueryParameterNames(Uri uri) {\n            String query = uri.getEncodedQuery();\n            if (query == null) {\n                return Collections.emptySet();\n            }\n            Set<String> names = new LinkedHashSet<String>();\n            int start = 0;\n            do {\n                int next = query.indexOf('&', start);\n                int end = (next == -1) ? query.length() : next;\n                int separator = query.indexOf('=', start);\n                if (separator > end || separator == -1) {\n                    separator = end;\n                }\n                String name = query.substring(start, separator);\n                names.add(Uri.decode(name));\n                // Move start to end of name.\n                start = end + 1;\n            } while (start < query.length());\n            return Collections.unmodifiableSet(names);\n        }\n        private static void goWaitress(final Context ctx, String actionUrl) {\n            MLog.i(\"actionUrl\"+actionUrl);\n            Uri  uri;\n            uri=Uri.parse(actionUrl);\n            Set<String>  parameters=JumpManager.getMyQueryParameterNames(uri);\n            Hashtable<String,String> params=new Hashtable<>();\n            if(parameters!=null&&parameters.size()>0){\n                for(String key:parameters){\n                    String value=uri.getQueryParameter(key);\n                    if(!TextUtils.isEmpty(value)){\n                        params.put(key,value);\n                    }\n                }\n            }\n            Intent it= new Intent(act, WaitressPage.class);\n            Set<String>  keySet=params.keySet();\n            for (String k:keySet){\n                it.putExtra(k,params.get(k));\n            }\n            startActivity(it);\n            }\n\n\n\n#DeepLink里面的坑： \n\n1. 由于有些页面有权限限制，所以要跳页面时候，要判断在当前账户当前版本是否可以打开\n2. 如果从H5页面带过来的信息带有登录状态，而且当前app的账号信息和H5页面的不一致，可能需要一个账号切换工作\n\n","source":"_posts/deep_link_design.md","raw":"\ntitle: Deeplink 设计\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n---\n\n\n#deeplink指的是在第三方客户端/浏览器中，打开一个APP的H5页面时候，如果发现本地安装了这个APP，就会使用本地APP打开。\n需要前端和客户端互相配合来实现本功能。\n\n#服务器端：\n\n    <html>\n    <head>\n    <meta property=\"al:ios:url\" content=\"applinks://docs\" />\n    <meta property=\"al:ios:app_store_id\" content=\"12345\" />\n    <meta property=\"al:ios:app_name\" content=\"App Links\" />\n    <meta property=\"al:android:url\" content=\"applinks://docs\" />\n    <meta property=\"al:android:app_name\" content=\"App Links\" />\n    <meta property=\"al:android:package\" content=\"org.applinks\" />\n    <meta property=\"al:web:url\"\n    content=\"http://applinks.org/documentation\" />\n    </head>\n    <body>\n    Hello, world!\n    </body>\n    </html>\n\n#客户端  \n客户端deeplink的实现需要依靠jump系统。ps:jump系统可以通过URI 实现在app中的定向跳转 ，比如我们的app叫“天上人间”（缩写tsrj）。 \n\n1. 需要先在menifest中注册相应的scheme的filter。  \n   ps:一般加载主页上面.\n\n\n        <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n        <category android:name=\"android.intent.category.BROWSABLE\"/>\n        <!-- Accepts URIs that begin with \"tsrj://\" -->\n        <data android:scheme=\"tsrj\"/>\n        </intent-filter>\n        <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n        <category android:name=\"android.intent.category.BROWSABLE\"/>\n        <!-- Accepts URIs that begin with \"http://m.tsrj.com/\" -->\n        <data\n        android:host=\"m.tsrj.com\"\n        android:pathPrefix=\"/\"\n        android:scheme=\"http\"/>\n        <data\n        android:host=\"m.tsrj.com\"\n        android:pathPrefix=\"/\"\n        android:scheme=\"https\"/>\n        </intent-filter>\n    \n2. 在MainActivity新增解析jump信息的方法\n\n\n        private void jump(Intent intent) {\n        /** 根据传过来的参数 进行jump跳转 **/\n        String action_url = intent.getDataString();\n        MLog.i(\"启动Main_action_url:\" + action_url);\n        if (!TextUtils.isEmpty(action_url)) {\n        JumpManager.jump(this, action_url);\n        } \n        }\n        \n        JumpManger就实现解析数据然后根据URI跳转的功能\n        public static boolean jump(Context ctx, String action_url) {\n        \n        if (TextUtils.isEmpty(action_url)) {\n        return false;\n        }\n        \n        MLog.d(\"JumpManager  url:\" + action_url);\n        \n        Uri uri = null;\n        \n        /**如果不是一个标准的uri格式说明传入的数据无效的 可以直接忽视*/\n        \n        try {\n        uri = Uri.parse(action_url);\n        } catch (Exception e) {\n        return false;\n        }\n        \n        if (uri == null) {\n        return false;\n        }\n        \n        /**检测到是一个合法的uri 先判断是否是满足跳转需求的头部 如果是 开始进行跳转检测 如果不是 直接往内置浏览器跳*/\n        \n        if (!action_url.startsWith(JumpUriFactory.JUM_URL_HEAD) && !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_S) && !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_CUSTOM)) {\n        \n        return false;\n        }\n        \n        Intent jumpintent = null;\n        \n        List<String> paths = uri.getPathSegments();\n        \n        /**只有头没有页面参数就返回*/\n        if (paths == null || paths.size() <= 0) {\n        \n        return false;\n        }\n        \n        /**有path 但是path里面为空值 直接打开*/\n        String action = paths.get(0);\n        if (TextUtils.isEmpty(action)) {\n        if (!isFromWebView) {\n        jumpToInteriorPageActivity(ctx, uri);\n        }\n        return false;\n        }\n        \n        /** 使用系统浏览器打开 */\n        if (action.equals(\"web_system\")) {\n        jumpToSystemWebPage(ctx, uri);\n        return true;\n        }\n        \n        \n        /*else if (action.equals(JumpPageSet.detail)) {\n        goWaitress(ctx, action_url);\n        return true;\n        }*/\n        \n        /** city */\n        else if (action.equals(JumpPageSet.city)) {\n        goCity(ctx, action_url);\n        return true;\n        }\n        \n        /** usercenter */\n        else if (action.equals(JumpPageSet.personal_info)) {\n        goUserCenter(ctx, action_url);\n        return true;\n        }\n\n\n3. 处理uri解析出里面的参数,放入intent，并跳往相应的主页\n\n\n        /**\n         * 将url的数据进行解析 得到一个存放所有参数的集合\n         */\n        public static Set<String> getMyQueryParameterNames(Uri uri) {\n            String query = uri.getEncodedQuery();\n            if (query == null) {\n                return Collections.emptySet();\n            }\n            Set<String> names = new LinkedHashSet<String>();\n            int start = 0;\n            do {\n                int next = query.indexOf('&', start);\n                int end = (next == -1) ? query.length() : next;\n                int separator = query.indexOf('=', start);\n                if (separator > end || separator == -1) {\n                    separator = end;\n                }\n                String name = query.substring(start, separator);\n                names.add(Uri.decode(name));\n                // Move start to end of name.\n                start = end + 1;\n            } while (start < query.length());\n            return Collections.unmodifiableSet(names);\n        }\n        private static void goWaitress(final Context ctx, String actionUrl) {\n            MLog.i(\"actionUrl\"+actionUrl);\n            Uri  uri;\n            uri=Uri.parse(actionUrl);\n            Set<String>  parameters=JumpManager.getMyQueryParameterNames(uri);\n            Hashtable<String,String> params=new Hashtable<>();\n            if(parameters!=null&&parameters.size()>0){\n                for(String key:parameters){\n                    String value=uri.getQueryParameter(key);\n                    if(!TextUtils.isEmpty(value)){\n                        params.put(key,value);\n                    }\n                }\n            }\n            Intent it= new Intent(act, WaitressPage.class);\n            Set<String>  keySet=params.keySet();\n            for (String k:keySet){\n                it.putExtra(k,params.get(k));\n            }\n            startActivity(it);\n            }\n\n\n\n#DeepLink里面的坑： \n\n1. 由于有些页面有权限限制，所以要跳页面时候，要判断在当前账户当前版本是否可以打开\n2. 如果从H5页面带过来的信息带有登录状态，而且当前app的账号信息和H5页面的不一致，可能需要一个账号切换工作\n\n","slug":"deep_link_design","published":1,"updated":"2017-03-17T13:27:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7bo00061rjjlg4w7olg","content":"<p>#deeplink指的是在第三方客户端/浏览器中，打开一个APP的H5页面时候，如果发现本地安装了这个APP，就会使用本地APP打开。<br>需要前端和客户端互相配合来实现本功能。</p>\n<p>#服务器端：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta property=&quot;al:ios:url&quot; content=&quot;applinks://docs&quot; /&gt;\n&lt;meta property=&quot;al:ios:app_store_id&quot; content=&quot;12345&quot; /&gt;\n&lt;meta property=&quot;al:ios:app_name&quot; content=&quot;App Links&quot; /&gt;\n&lt;meta property=&quot;al:android:url&quot; content=&quot;applinks://docs&quot; /&gt;\n&lt;meta property=&quot;al:android:app_name&quot; content=&quot;App Links&quot; /&gt;\n&lt;meta property=&quot;al:android:package&quot; content=&quot;org.applinks&quot; /&gt;\n&lt;meta property=&quot;al:web:url&quot;\ncontent=&quot;http://applinks.org/documentation&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\nHello, world!\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>#客户端<br>客户端deeplink的实现需要依靠jump系统。ps:jump系统可以通过URI 实现在app中的定向跳转 ，比如我们的app叫“天上人间”（缩写tsrj）。 </p>\n<ol>\n<li>需要先在menifest中注册相应的scheme的filter。<br>ps:一般加载主页上面.</li>\n</ol>\n<pre><code>&lt;intent-filter&gt;\n&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n&lt;!-- Accepts URIs that begin with &quot;tsrj://&quot; --&gt;\n&lt;data android:scheme=&quot;tsrj&quot;/&gt;\n&lt;/intent-filter&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n&lt;!-- Accepts URIs that begin with &quot;http://m.tsrj.com/&quot; --&gt;\n&lt;data\nandroid:host=&quot;m.tsrj.com&quot;\nandroid:pathPrefix=&quot;/&quot;\nandroid:scheme=&quot;http&quot;/&gt;\n&lt;data\nandroid:host=&quot;m.tsrj.com&quot;\nandroid:pathPrefix=&quot;/&quot;\nandroid:scheme=&quot;https&quot;/&gt;\n&lt;/intent-filter&gt;\n</code></pre><ol>\n<li>在MainActivity新增解析jump信息的方法</li>\n</ol>\n<pre><code>private void jump(Intent intent) {\n/** 根据传过来的参数 进行jump跳转 **/\nString action_url = intent.getDataString();\nMLog.i(&quot;启动Main_action_url:&quot; + action_url);\nif (!TextUtils.isEmpty(action_url)) {\nJumpManager.jump(this, action_url);\n} \n}\n\nJumpManger就实现解析数据然后根据URI跳转的功能\npublic static boolean jump(Context ctx, String action_url) {\n\nif (TextUtils.isEmpty(action_url)) {\nreturn false;\n}\n\nMLog.d(&quot;JumpManager  url:&quot; + action_url);\n\nUri uri = null;\n\n/**如果不是一个标准的uri格式说明传入的数据无效的 可以直接忽视*/\n\ntry {\nuri = Uri.parse(action_url);\n} catch (Exception e) {\nreturn false;\n}\n\nif (uri == null) {\nreturn false;\n}\n\n/**检测到是一个合法的uri 先判断是否是满足跳转需求的头部 如果是 开始进行跳转检测 如果不是 直接往内置浏览器跳*/\n\nif (!action_url.startsWith(JumpUriFactory.JUM_URL_HEAD) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_S) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_CUSTOM)) {\n\nreturn false;\n}\n\nIntent jumpintent = null;\n\nList&lt;String&gt; paths = uri.getPathSegments();\n\n/**只有头没有页面参数就返回*/\nif (paths == null || paths.size() &lt;= 0) {\n\nreturn false;\n}\n\n/**有path 但是path里面为空值 直接打开*/\nString action = paths.get(0);\nif (TextUtils.isEmpty(action)) {\nif (!isFromWebView) {\njumpToInteriorPageActivity(ctx, uri);\n}\nreturn false;\n}\n\n/** 使用系统浏览器打开 */\nif (action.equals(&quot;web_system&quot;)) {\njumpToSystemWebPage(ctx, uri);\nreturn true;\n}\n\n\n/*else if (action.equals(JumpPageSet.detail)) {\ngoWaitress(ctx, action_url);\nreturn true;\n}*/\n\n/** city */\nelse if (action.equals(JumpPageSet.city)) {\ngoCity(ctx, action_url);\nreturn true;\n}\n\n/** usercenter */\nelse if (action.equals(JumpPageSet.personal_info)) {\ngoUserCenter(ctx, action_url);\nreturn true;\n}\n</code></pre><ol>\n<li>处理uri解析出里面的参数,放入intent，并跳往相应的主页</li>\n</ol>\n<pre><code>/**\n * 将url的数据进行解析 得到一个存放所有参数的集合\n */\npublic static Set&lt;String&gt; getMyQueryParameterNames(Uri uri) {\n    String query = uri.getEncodedQuery();\n    if (query == null) {\n        return Collections.emptySet();\n    }\n    Set&lt;String&gt; names = new LinkedHashSet&lt;String&gt;();\n    int start = 0;\n    do {\n        int next = query.indexOf(&apos;&amp;&apos;, start);\n        int end = (next == -1) ? query.length() : next;\n        int separator = query.indexOf(&apos;=&apos;, start);\n        if (separator &gt; end || separator == -1) {\n            separator = end;\n        }\n        String name = query.substring(start, separator);\n        names.add(Uri.decode(name));\n        // Move start to end of name.\n        start = end + 1;\n    } while (start &lt; query.length());\n    return Collections.unmodifiableSet(names);\n}\nprivate static void goWaitress(final Context ctx, String actionUrl) {\n    MLog.i(&quot;actionUrl&quot;+actionUrl);\n    Uri  uri;\n    uri=Uri.parse(actionUrl);\n    Set&lt;String&gt;  parameters=JumpManager.getMyQueryParameterNames(uri);\n    Hashtable&lt;String,String&gt; params=new Hashtable&lt;&gt;();\n    if(parameters!=null&amp;&amp;parameters.size()&gt;0){\n        for(String key:parameters){\n            String value=uri.getQueryParameter(key);\n            if(!TextUtils.isEmpty(value)){\n                params.put(key,value);\n            }\n        }\n    }\n    Intent it= new Intent(act, WaitressPage.class);\n    Set&lt;String&gt;  keySet=params.keySet();\n    for (String k:keySet){\n        it.putExtra(k,params.get(k));\n    }\n    startActivity(it);\n    }\n</code></pre><p>#DeepLink里面的坑： </p>\n<ol>\n<li>由于有些页面有权限限制，所以要跳页面时候，要判断在当前账户当前版本是否可以打开</li>\n<li>如果从H5页面带过来的信息带有登录状态，而且当前app的账号信息和H5页面的不一致，可能需要一个账号切换工作</li>\n</ol>\n","excerpt":"","more":"<p>#deeplink指的是在第三方客户端/浏览器中，打开一个APP的H5页面时候，如果发现本地安装了这个APP，就会使用本地APP打开。<br>需要前端和客户端互相配合来实现本功能。</p>\n<p>#服务器端：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta property=&quot;al:ios:url&quot; content=&quot;applinks://docs&quot; /&gt;\n&lt;meta property=&quot;al:ios:app_store_id&quot; content=&quot;12345&quot; /&gt;\n&lt;meta property=&quot;al:ios:app_name&quot; content=&quot;App Links&quot; /&gt;\n&lt;meta property=&quot;al:android:url&quot; content=&quot;applinks://docs&quot; /&gt;\n&lt;meta property=&quot;al:android:app_name&quot; content=&quot;App Links&quot; /&gt;\n&lt;meta property=&quot;al:android:package&quot; content=&quot;org.applinks&quot; /&gt;\n&lt;meta property=&quot;al:web:url&quot;\ncontent=&quot;http://applinks.org/documentation&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\nHello, world!\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>#客户端<br>客户端deeplink的实现需要依靠jump系统。ps:jump系统可以通过URI 实现在app中的定向跳转 ，比如我们的app叫“天上人间”（缩写tsrj）。 </p>\n<ol>\n<li>需要先在menifest中注册相应的scheme的filter。<br>ps:一般加载主页上面.</li>\n</ol>\n<pre><code>&lt;intent-filter&gt;\n&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n&lt;!-- Accepts URIs that begin with &quot;tsrj://&quot; --&gt;\n&lt;data android:scheme=&quot;tsrj&quot;/&gt;\n&lt;/intent-filter&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n&lt;!-- Accepts URIs that begin with &quot;http://m.tsrj.com/&quot; --&gt;\n&lt;data\nandroid:host=&quot;m.tsrj.com&quot;\nandroid:pathPrefix=&quot;/&quot;\nandroid:scheme=&quot;http&quot;/&gt;\n&lt;data\nandroid:host=&quot;m.tsrj.com&quot;\nandroid:pathPrefix=&quot;/&quot;\nandroid:scheme=&quot;https&quot;/&gt;\n&lt;/intent-filter&gt;\n</code></pre><ol>\n<li>在MainActivity新增解析jump信息的方法</li>\n</ol>\n<pre><code>private void jump(Intent intent) {\n/** 根据传过来的参数 进行jump跳转 **/\nString action_url = intent.getDataString();\nMLog.i(&quot;启动Main_action_url:&quot; + action_url);\nif (!TextUtils.isEmpty(action_url)) {\nJumpManager.jump(this, action_url);\n} \n}\n\nJumpManger就实现解析数据然后根据URI跳转的功能\npublic static boolean jump(Context ctx, String action_url) {\n\nif (TextUtils.isEmpty(action_url)) {\nreturn false;\n}\n\nMLog.d(&quot;JumpManager  url:&quot; + action_url);\n\nUri uri = null;\n\n/**如果不是一个标准的uri格式说明传入的数据无效的 可以直接忽视*/\n\ntry {\nuri = Uri.parse(action_url);\n} catch (Exception e) {\nreturn false;\n}\n\nif (uri == null) {\nreturn false;\n}\n\n/**检测到是一个合法的uri 先判断是否是满足跳转需求的头部 如果是 开始进行跳转检测 如果不是 直接往内置浏览器跳*/\n\nif (!action_url.startsWith(JumpUriFactory.JUM_URL_HEAD) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_S) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_CUSTOM)) {\n\nreturn false;\n}\n\nIntent jumpintent = null;\n\nList&lt;String&gt; paths = uri.getPathSegments();\n\n/**只有头没有页面参数就返回*/\nif (paths == null || paths.size() &lt;= 0) {\n\nreturn false;\n}\n\n/**有path 但是path里面为空值 直接打开*/\nString action = paths.get(0);\nif (TextUtils.isEmpty(action)) {\nif (!isFromWebView) {\njumpToInteriorPageActivity(ctx, uri);\n}\nreturn false;\n}\n\n/** 使用系统浏览器打开 */\nif (action.equals(&quot;web_system&quot;)) {\njumpToSystemWebPage(ctx, uri);\nreturn true;\n}\n\n\n/*else if (action.equals(JumpPageSet.detail)) {\ngoWaitress(ctx, action_url);\nreturn true;\n}*/\n\n/** city */\nelse if (action.equals(JumpPageSet.city)) {\ngoCity(ctx, action_url);\nreturn true;\n}\n\n/** usercenter */\nelse if (action.equals(JumpPageSet.personal_info)) {\ngoUserCenter(ctx, action_url);\nreturn true;\n}\n</code></pre><ol>\n<li>处理uri解析出里面的参数,放入intent，并跳往相应的主页</li>\n</ol>\n<pre><code>/**\n * 将url的数据进行解析 得到一个存放所有参数的集合\n */\npublic static Set&lt;String&gt; getMyQueryParameterNames(Uri uri) {\n    String query = uri.getEncodedQuery();\n    if (query == null) {\n        return Collections.emptySet();\n    }\n    Set&lt;String&gt; names = new LinkedHashSet&lt;String&gt;();\n    int start = 0;\n    do {\n        int next = query.indexOf(&apos;&amp;&apos;, start);\n        int end = (next == -1) ? query.length() : next;\n        int separator = query.indexOf(&apos;=&apos;, start);\n        if (separator &gt; end || separator == -1) {\n            separator = end;\n        }\n        String name = query.substring(start, separator);\n        names.add(Uri.decode(name));\n        // Move start to end of name.\n        start = end + 1;\n    } while (start &lt; query.length());\n    return Collections.unmodifiableSet(names);\n}\nprivate static void goWaitress(final Context ctx, String actionUrl) {\n    MLog.i(&quot;actionUrl&quot;+actionUrl);\n    Uri  uri;\n    uri=Uri.parse(actionUrl);\n    Set&lt;String&gt;  parameters=JumpManager.getMyQueryParameterNames(uri);\n    Hashtable&lt;String,String&gt; params=new Hashtable&lt;&gt;();\n    if(parameters!=null&amp;&amp;parameters.size()&gt;0){\n        for(String key:parameters){\n            String value=uri.getQueryParameter(key);\n            if(!TextUtils.isEmpty(value)){\n                params.put(key,value);\n            }\n        }\n    }\n    Intent it= new Intent(act, WaitressPage.class);\n    Set&lt;String&gt;  keySet=params.keySet();\n    for (String k:keySet){\n        it.putExtra(k,params.get(k));\n    }\n    startActivity(it);\n    }\n</code></pre><p>#DeepLink里面的坑： </p>\n<ol>\n<li>由于有些页面有权限限制，所以要跳页面时候，要判断在当前账户当前版本是否可以打开</li>\n<li>如果从H5页面带过来的信息带有登录状态，而且当前app的账号信息和H5页面的不一致，可能需要一个账号切换工作</li>\n</ol>\n"},{"title":"Android模块化","date":"2015-11-01T12:10:33.000Z","_content":"\n\n# 基于AAR的Android模块化实践\n## 方案  \n1、首先 按照应用分层（common  view），注意每个module最好配置一下resourcePrefix \"mc_\"  \n2、上层再按照功能模块比如  信用卡和个人中心\n\n这样每个都会打出一个aar，府工程引入所有的aar就可以引入这个模块\n\n## 问题\n但是这个距离一个可以发布出去的aar还有距离，有以下几个问题需要解决：  \n1. 本地jar依赖（主工程很有可能也公用这个jar）；  \n2. 混淆的问题；  \n3. 多个aar合并；   \n4. 兄弟模块互相调用，基模块调用父模块的方法；\n\n\n### 问题1:  \nAndroid dependency的几种方法：\neg：  \n\n        testCompile 'junit:junit:4.12'\n    //compile fileTree(dir: 'libs', include: ['*.jar'])  \n    provided fileTree(dir: 'libs',include: ['*.jar'])  \n    compile 'com.android.support:support-v4:23.0.1'  \n    compile project(':Module_common')   \n- testCompile ：  debug 会编译  正式打包不会编译\n- compile ： 除去\"compile jar\"会编译进arr，其余的都不会编译进去\n- provided：编译时候不会把jar编译进去\n\n传递依赖的问题\n（例如 modle A 依赖 Module B，Module B 又依赖Module  C ）   jar  都放在C里面，Module A不引入jar 也能引用到jar。\n\n但是正式打包时候不需要这些jar，本地的jar必须以provided方式引入，这样aar里面就不会打进去这些jar了。\n\n这会引入另外一个问题：C改成provide 这些jar后，A和B找不到这些依赖的jar 会编译失败\n\n解决方案：\n把jar单独成一个module D，写成provided\n（也可在module A  和 B里面  把这些jar 都拷贝进去，然后统统写成provided）\n\n### 问题2\n\n首先要明白，我们要去混淆的是A和主工程的接口，而A和B以及C直接的调用都需要混淆，但是不能在B和C里面混淆，因为这样一混淆的话，A与B、C调用的接口也混淆了\n\n所以混淆只能在A里面打开，A和B都不能打开混淆\n\n### 问题3\n默认会打出三个aar，但是我们只能发布一个aar出去，所以必须使用到 https://github.com/adwiv/android-fat-aar 写的合并aar的gradle\n\n方法：  \n1、拷贝 fat-aar.gradle到build.gradle 同级目录\n2、module的build.gradle新增  \napply from: 'fat-aar.gradle'  ，\n\ncompile project(':Module_common')   \n改成  \nembedded project(':Module_common')\n\n这样在打B的aar时候，会把基moduel的aar合并进来\n\n\n如果这个模块工程就一个工程，就只需要解决问题1，同时配置一下混淆就行\n\n## 问题4\n通过hook调用\n基模块：\n\n    public class CommonModuleDataEngine {\n    \n        private static CommonModuleDataEngine INSTANCE;\n    \n        private AppInfo appInfo;//这个必须要父模块或者兄弟模块\n        public static CommonModuleDataEngine getInstance() {\n            if (INSTANCE == null) {\n                INSTANCE = new CommonModuleDataEngine();\n            }\n            return INSTANCE;\n        }\n    \n        private CommonModuleDataEngine() {\n        }\n    \n        public String getAppInfo() {\n            return appInfo.getAppInfo();\n        }\n    \n        public static class Builder {\n            private AppInfo appInfo;\n    \n            public Builder setAppInfo(AppInfo appInfo) {\n                this.appInfo = appInfo;\n                return this;\n            }\n            public void build() {\n                CommonModuleDataEngine engin = CommonModuleDataEngine.getInstance();\n                engin.appInfo = this.appInfo;\n    \n            }\n    \n        }\n        public interface AppInfo {\n    \n            String getAppInfo();\n    \n        }\n    \n    }\n\n\n主工程  \n\n在Application初始化的时候初始几个基类CommonModuleDataEngine，\n\n\nps：内部类的去混淆  \n\n        -keepclasseswithmembers  class CommonModuleDataEngine {*;}\n    -keepclasseswithmembers  class CommonModuleDataEngine$* {*;}\n\n\n\n\n### 其它注意事项  \n1、主程序和Module里面的Manifest里面的一些配置同名。必须在manifest  中的相应的配置里面 添加  \n\n        tools:replace=\"android:icon,theme,label\"\n例如基module和主程序都包含了高德定位，manifest必然也有相同的配置信息\n\n    <meta-data\n        tools:replace=\"android:value\"\n        android:name=\"com.amap.api.v2.apikey\"\n        android:value=\"*******\" />\n\nApp组件化与业务拆分: http://www.jianshu.com/p/60c1b9ddd8ab\n\n\n\n","source":"_posts/android模块化实践.md","raw":"title: Android模块化\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n- 模块化\n---\n\n\n# 基于AAR的Android模块化实践\n## 方案  \n1、首先 按照应用分层（common  view），注意每个module最好配置一下resourcePrefix \"mc_\"  \n2、上层再按照功能模块比如  信用卡和个人中心\n\n这样每个都会打出一个aar，府工程引入所有的aar就可以引入这个模块\n\n## 问题\n但是这个距离一个可以发布出去的aar还有距离，有以下几个问题需要解决：  \n1. 本地jar依赖（主工程很有可能也公用这个jar）；  \n2. 混淆的问题；  \n3. 多个aar合并；   \n4. 兄弟模块互相调用，基模块调用父模块的方法；\n\n\n### 问题1:  \nAndroid dependency的几种方法：\neg：  \n\n        testCompile 'junit:junit:4.12'\n    //compile fileTree(dir: 'libs', include: ['*.jar'])  \n    provided fileTree(dir: 'libs',include: ['*.jar'])  \n    compile 'com.android.support:support-v4:23.0.1'  \n    compile project(':Module_common')   \n- testCompile ：  debug 会编译  正式打包不会编译\n- compile ： 除去\"compile jar\"会编译进arr，其余的都不会编译进去\n- provided：编译时候不会把jar编译进去\n\n传递依赖的问题\n（例如 modle A 依赖 Module B，Module B 又依赖Module  C ）   jar  都放在C里面，Module A不引入jar 也能引用到jar。\n\n但是正式打包时候不需要这些jar，本地的jar必须以provided方式引入，这样aar里面就不会打进去这些jar了。\n\n这会引入另外一个问题：C改成provide 这些jar后，A和B找不到这些依赖的jar 会编译失败\n\n解决方案：\n把jar单独成一个module D，写成provided\n（也可在module A  和 B里面  把这些jar 都拷贝进去，然后统统写成provided）\n\n### 问题2\n\n首先要明白，我们要去混淆的是A和主工程的接口，而A和B以及C直接的调用都需要混淆，但是不能在B和C里面混淆，因为这样一混淆的话，A与B、C调用的接口也混淆了\n\n所以混淆只能在A里面打开，A和B都不能打开混淆\n\n### 问题3\n默认会打出三个aar，但是我们只能发布一个aar出去，所以必须使用到 https://github.com/adwiv/android-fat-aar 写的合并aar的gradle\n\n方法：  \n1、拷贝 fat-aar.gradle到build.gradle 同级目录\n2、module的build.gradle新增  \napply from: 'fat-aar.gradle'  ，\n\ncompile project(':Module_common')   \n改成  \nembedded project(':Module_common')\n\n这样在打B的aar时候，会把基moduel的aar合并进来\n\n\n如果这个模块工程就一个工程，就只需要解决问题1，同时配置一下混淆就行\n\n## 问题4\n通过hook调用\n基模块：\n\n    public class CommonModuleDataEngine {\n    \n        private static CommonModuleDataEngine INSTANCE;\n    \n        private AppInfo appInfo;//这个必须要父模块或者兄弟模块\n        public static CommonModuleDataEngine getInstance() {\n            if (INSTANCE == null) {\n                INSTANCE = new CommonModuleDataEngine();\n            }\n            return INSTANCE;\n        }\n    \n        private CommonModuleDataEngine() {\n        }\n    \n        public String getAppInfo() {\n            return appInfo.getAppInfo();\n        }\n    \n        public static class Builder {\n            private AppInfo appInfo;\n    \n            public Builder setAppInfo(AppInfo appInfo) {\n                this.appInfo = appInfo;\n                return this;\n            }\n            public void build() {\n                CommonModuleDataEngine engin = CommonModuleDataEngine.getInstance();\n                engin.appInfo = this.appInfo;\n    \n            }\n    \n        }\n        public interface AppInfo {\n    \n            String getAppInfo();\n    \n        }\n    \n    }\n\n\n主工程  \n\n在Application初始化的时候初始几个基类CommonModuleDataEngine，\n\n\nps：内部类的去混淆  \n\n        -keepclasseswithmembers  class CommonModuleDataEngine {*;}\n    -keepclasseswithmembers  class CommonModuleDataEngine$* {*;}\n\n\n\n\n### 其它注意事项  \n1、主程序和Module里面的Manifest里面的一些配置同名。必须在manifest  中的相应的配置里面 添加  \n\n        tools:replace=\"android:icon,theme,label\"\n例如基module和主程序都包含了高德定位，manifest必然也有相同的配置信息\n\n    <meta-data\n        tools:replace=\"android:value\"\n        android:name=\"com.amap.api.v2.apikey\"\n        android:value=\"*******\" />\n\nApp组件化与业务拆分: http://www.jianshu.com/p/60c1b9ddd8ab\n\n\n\n","slug":"android模块化实践","published":1,"updated":"2017-03-17T13:26:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7bt000a1rjjhxhl52a6","content":"<h1 id=\"基于AAR的Android模块化实践\"><a href=\"#基于AAR的Android模块化实践\" class=\"headerlink\" title=\"基于AAR的Android模块化实践\"></a>基于AAR的Android模块化实践</h1><h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>1、首先 按照应用分层（common  view），注意每个module最好配置一下resourcePrefix “mc_”<br>2、上层再按照功能模块比如  信用卡和个人中心</p>\n<p>这样每个都会打出一个aar，府工程引入所有的aar就可以引入这个模块</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>但是这个距离一个可以发布出去的aar还有距离，有以下几个问题需要解决：  </p>\n<ol>\n<li>本地jar依赖（主工程很有可能也公用这个jar）；  </li>\n<li>混淆的问题；  </li>\n<li>多个aar合并；   </li>\n<li>兄弟模块互相调用，基模块调用父模块的方法；</li>\n</ol>\n<h3 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1:\"></a>问题1:</h3><p>Android dependency的几种方法：<br>eg：  </p>\n<pre><code>    testCompile &apos;junit:junit:4.12&apos;\n//compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])  \nprovided fileTree(dir: &apos;libs&apos;,include: [&apos;*.jar&apos;])  \ncompile &apos;com.android.support:support-v4:23.0.1&apos;  \ncompile project(&apos;:Module_common&apos;)   \n</code></pre><ul>\n<li>testCompile ：  debug 会编译  正式打包不会编译</li>\n<li>compile ： 除去”compile jar”会编译进arr，其余的都不会编译进去</li>\n<li>provided：编译时候不会把jar编译进去</li>\n</ul>\n<p>传递依赖的问题<br>（例如 modle A 依赖 Module B，Module B 又依赖Module  C ）   jar  都放在C里面，Module A不引入jar 也能引用到jar。</p>\n<p>但是正式打包时候不需要这些jar，本地的jar必须以provided方式引入，这样aar里面就不会打进去这些jar了。</p>\n<p>这会引入另外一个问题：C改成provide 这些jar后，A和B找不到这些依赖的jar 会编译失败</p>\n<p>解决方案：<br>把jar单独成一个module D，写成provided<br>（也可在module A  和 B里面  把这些jar 都拷贝进去，然后统统写成provided）</p>\n<h3 id=\"问题2\"><a href=\"#问题2\" class=\"headerlink\" title=\"问题2\"></a>问题2</h3><p>首先要明白，我们要去混淆的是A和主工程的接口，而A和B以及C直接的调用都需要混淆，但是不能在B和C里面混淆，因为这样一混淆的话，A与B、C调用的接口也混淆了</p>\n<p>所以混淆只能在A里面打开，A和B都不能打开混淆</p>\n<h3 id=\"问题3\"><a href=\"#问题3\" class=\"headerlink\" title=\"问题3\"></a>问题3</h3><p>默认会打出三个aar，但是我们只能发布一个aar出去，所以必须使用到 <a href=\"https://github.com/adwiv/android-fat-aar\" target=\"_blank\" rel=\"external\">https://github.com/adwiv/android-fat-aar</a> 写的合并aar的gradle</p>\n<p>方法：<br>1、拷贝 fat-aar.gradle到build.gradle 同级目录<br>2、module的build.gradle新增<br>apply from: ‘fat-aar.gradle’  ，</p>\n<p>compile project(‘:Module_common’)<br>改成<br>embedded project(‘:Module_common’)</p>\n<p>这样在打B的aar时候，会把基moduel的aar合并进来</p>\n<p>如果这个模块工程就一个工程，就只需要解决问题1，同时配置一下混淆就行</p>\n<h2 id=\"问题4\"><a href=\"#问题4\" class=\"headerlink\" title=\"问题4\"></a>问题4</h2><p>通过hook调用<br>基模块：</p>\n<pre><code>public class CommonModuleDataEngine {\n\n    private static CommonModuleDataEngine INSTANCE;\n\n    private AppInfo appInfo;//这个必须要父模块或者兄弟模块\n    public static CommonModuleDataEngine getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new CommonModuleDataEngine();\n        }\n        return INSTANCE;\n    }\n\n    private CommonModuleDataEngine() {\n    }\n\n    public String getAppInfo() {\n        return appInfo.getAppInfo();\n    }\n\n    public static class Builder {\n        private AppInfo appInfo;\n\n        public Builder setAppInfo(AppInfo appInfo) {\n            this.appInfo = appInfo;\n            return this;\n        }\n        public void build() {\n            CommonModuleDataEngine engin = CommonModuleDataEngine.getInstance();\n            engin.appInfo = this.appInfo;\n\n        }\n\n    }\n    public interface AppInfo {\n\n        String getAppInfo();\n\n    }\n\n}\n</code></pre><p>主工程  </p>\n<p>在Application初始化的时候初始几个基类CommonModuleDataEngine，</p>\n<p>ps：内部类的去混淆  </p>\n<pre><code>    -keepclasseswithmembers  class CommonModuleDataEngine {*;}\n-keepclasseswithmembers  class CommonModuleDataEngine$* {*;}\n</code></pre><h3 id=\"其它注意事项\"><a href=\"#其它注意事项\" class=\"headerlink\" title=\"其它注意事项\"></a>其它注意事项</h3><p>1、主程序和Module里面的Manifest里面的一些配置同名。必须在manifest  中的相应的配置里面 添加  </p>\n<pre><code>tools:replace=&quot;android:icon,theme,label&quot;\n</code></pre><p>例如基module和主程序都包含了高德定位，manifest必然也有相同的配置信息</p>\n<pre><code>&lt;meta-data\n    tools:replace=&quot;android:value&quot;\n    android:name=&quot;com.amap.api.v2.apikey&quot;\n    android:value=&quot;*******&quot; /&gt;\n</code></pre><p>App组件化与业务拆分: <a href=\"http://www.jianshu.com/p/60c1b9ddd8ab\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/60c1b9ddd8ab</a></p>\n","excerpt":"","more":"<h1 id=\"基于AAR的Android模块化实践\"><a href=\"#基于AAR的Android模块化实践\" class=\"headerlink\" title=\"基于AAR的Android模块化实践\"></a>基于AAR的Android模块化实践</h1><h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>1、首先 按照应用分层（common  view），注意每个module最好配置一下resourcePrefix “mc_”<br>2、上层再按照功能模块比如  信用卡和个人中心</p>\n<p>这样每个都会打出一个aar，府工程引入所有的aar就可以引入这个模块</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>但是这个距离一个可以发布出去的aar还有距离，有以下几个问题需要解决：  </p>\n<ol>\n<li>本地jar依赖（主工程很有可能也公用这个jar）；  </li>\n<li>混淆的问题；  </li>\n<li>多个aar合并；   </li>\n<li>兄弟模块互相调用，基模块调用父模块的方法；</li>\n</ol>\n<h3 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1:\"></a>问题1:</h3><p>Android dependency的几种方法：<br>eg：  </p>\n<pre><code>    testCompile &apos;junit:junit:4.12&apos;\n//compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])  \nprovided fileTree(dir: &apos;libs&apos;,include: [&apos;*.jar&apos;])  \ncompile &apos;com.android.support:support-v4:23.0.1&apos;  \ncompile project(&apos;:Module_common&apos;)   \n</code></pre><ul>\n<li>testCompile ：  debug 会编译  正式打包不会编译</li>\n<li>compile ： 除去”compile jar”会编译进arr，其余的都不会编译进去</li>\n<li>provided：编译时候不会把jar编译进去</li>\n</ul>\n<p>传递依赖的问题<br>（例如 modle A 依赖 Module B，Module B 又依赖Module  C ）   jar  都放在C里面，Module A不引入jar 也能引用到jar。</p>\n<p>但是正式打包时候不需要这些jar，本地的jar必须以provided方式引入，这样aar里面就不会打进去这些jar了。</p>\n<p>这会引入另外一个问题：C改成provide 这些jar后，A和B找不到这些依赖的jar 会编译失败</p>\n<p>解决方案：<br>把jar单独成一个module D，写成provided<br>（也可在module A  和 B里面  把这些jar 都拷贝进去，然后统统写成provided）</p>\n<h3 id=\"问题2\"><a href=\"#问题2\" class=\"headerlink\" title=\"问题2\"></a>问题2</h3><p>首先要明白，我们要去混淆的是A和主工程的接口，而A和B以及C直接的调用都需要混淆，但是不能在B和C里面混淆，因为这样一混淆的话，A与B、C调用的接口也混淆了</p>\n<p>所以混淆只能在A里面打开，A和B都不能打开混淆</p>\n<h3 id=\"问题3\"><a href=\"#问题3\" class=\"headerlink\" title=\"问题3\"></a>问题3</h3><p>默认会打出三个aar，但是我们只能发布一个aar出去，所以必须使用到 <a href=\"https://github.com/adwiv/android-fat-aar\">https://github.com/adwiv/android-fat-aar</a> 写的合并aar的gradle</p>\n<p>方法：<br>1、拷贝 fat-aar.gradle到build.gradle 同级目录<br>2、module的build.gradle新增<br>apply from: ‘fat-aar.gradle’  ，</p>\n<p>compile project(‘:Module_common’)<br>改成<br>embedded project(‘:Module_common’)</p>\n<p>这样在打B的aar时候，会把基moduel的aar合并进来</p>\n<p>如果这个模块工程就一个工程，就只需要解决问题1，同时配置一下混淆就行</p>\n<h2 id=\"问题4\"><a href=\"#问题4\" class=\"headerlink\" title=\"问题4\"></a>问题4</h2><p>通过hook调用<br>基模块：</p>\n<pre><code>public class CommonModuleDataEngine {\n\n    private static CommonModuleDataEngine INSTANCE;\n\n    private AppInfo appInfo;//这个必须要父模块或者兄弟模块\n    public static CommonModuleDataEngine getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new CommonModuleDataEngine();\n        }\n        return INSTANCE;\n    }\n\n    private CommonModuleDataEngine() {\n    }\n\n    public String getAppInfo() {\n        return appInfo.getAppInfo();\n    }\n\n    public static class Builder {\n        private AppInfo appInfo;\n\n        public Builder setAppInfo(AppInfo appInfo) {\n            this.appInfo = appInfo;\n            return this;\n        }\n        public void build() {\n            CommonModuleDataEngine engin = CommonModuleDataEngine.getInstance();\n            engin.appInfo = this.appInfo;\n\n        }\n\n    }\n    public interface AppInfo {\n\n        String getAppInfo();\n\n    }\n\n}\n</code></pre><p>主工程  </p>\n<p>在Application初始化的时候初始几个基类CommonModuleDataEngine，</p>\n<p>ps：内部类的去混淆  </p>\n<pre><code>    -keepclasseswithmembers  class CommonModuleDataEngine {*;}\n-keepclasseswithmembers  class CommonModuleDataEngine$* {*;}\n</code></pre><h3 id=\"其它注意事项\"><a href=\"#其它注意事项\" class=\"headerlink\" title=\"其它注意事项\"></a>其它注意事项</h3><p>1、主程序和Module里面的Manifest里面的一些配置同名。必须在manifest  中的相应的配置里面 添加  </p>\n<pre><code>tools:replace=&quot;android:icon,theme,label&quot;\n</code></pre><p>例如基module和主程序都包含了高德定位，manifest必然也有相同的配置信息</p>\n<pre><code>&lt;meta-data\n    tools:replace=&quot;android:value&quot;\n    android:name=&quot;com.amap.api.v2.apikey&quot;\n    android:value=&quot;*******&quot; /&gt;\n</code></pre><p>App组件化与业务拆分: <a href=\"http://www.jianshu.com/p/60c1b9ddd8ab\">http://www.jianshu.com/p/60c1b9ddd8ab</a></p>\n"},{"title":"Github 教程","date":"2015-11-01T12:10:33.000Z","_content":"\n\n# Github 教程\n\n## 推一个本地工程到github\n1. 首先在github上创建一个resp\n2. 在本地工程里面引入 .gitignore\n  * 在androidstudio 安装一个ignore 插件，可以生成部分ignore\n  * 对于gradle目录的工程，每一个存在build.gradle目录都需要放一个.gitignore\n  * .gitignore 内容 （对于android的gradle目录结构最完整的ignore文件）[原文件](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore) \n        \n        \n        .gradle\n        /local.properties\n        /gradle.properties\n        /.idea/workspace.xml\n        /.idea/libraries\n        .DS_Store\n        /build\n        /captures\n        bin\n        gen\n        .settings\n        .idea\n        target\n        *.iml\n        *.key\n\n\n\n4. touch README.md  》》生成 reamdme文件\n    \n5. git init当前工程 》》生成 git信息\n\n6. git add -A 》》把当前工程除了ingore的添加到git里面\n\n7. git commit 》》生成第一次的commit信息\n\n8. git remote add origin git@github.com:liuyicheng3/NewRepo.git   》》设置当前git工程的远程分支\n\n9. git push -u origin master 》》push 到github上去\n\n10. Attention:一般android studio的默认ssh是 androidstudio自己的，所以这时候用android studio会提交不上去\n  需要在settiings>vertion control> git里面吧 SSH excutable 由built-in 改成 native\n\n\n##维护git文档方法\n * 可以网页里面直接弄，就不要通本地修改再提交，太麻烦。\n * 涉及到外部链接的图片文件，git库里面建对应的文件夹统一维护。\n * 对于图片贴的地址一定要是raw的，不要那个github上显示的地址\n```markdown\n[原文件](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore) \n```\n\n##一般的git工作流程\n\n###版本管理\n###按featrue 开发\n###codereview及合并\n\n## Markdown 快捷键\n   1. 空两行，让后代码区域两个TAB\n   2. shift tab  收回一个tab\n\n\n\n\n\n\n","source":"_posts/git_guide.md","raw":"title: Github 教程\ndate: 2015-11-01 20:10:33\ncategories:\n- 工具\ntags:\n- github\n- 工具\n\n---\n\n\n# Github 教程\n\n## 推一个本地工程到github\n1. 首先在github上创建一个resp\n2. 在本地工程里面引入 .gitignore\n  * 在androidstudio 安装一个ignore 插件，可以生成部分ignore\n  * 对于gradle目录的工程，每一个存在build.gradle目录都需要放一个.gitignore\n  * .gitignore 内容 （对于android的gradle目录结构最完整的ignore文件）[原文件](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore) \n        \n        \n        .gradle\n        /local.properties\n        /gradle.properties\n        /.idea/workspace.xml\n        /.idea/libraries\n        .DS_Store\n        /build\n        /captures\n        bin\n        gen\n        .settings\n        .idea\n        target\n        *.iml\n        *.key\n\n\n\n4. touch README.md  》》生成 reamdme文件\n    \n5. git init当前工程 》》生成 git信息\n\n6. git add -A 》》把当前工程除了ingore的添加到git里面\n\n7. git commit 》》生成第一次的commit信息\n\n8. git remote add origin git@github.com:liuyicheng3/NewRepo.git   》》设置当前git工程的远程分支\n\n9. git push -u origin master 》》push 到github上去\n\n10. Attention:一般android studio的默认ssh是 androidstudio自己的，所以这时候用android studio会提交不上去\n  需要在settiings>vertion control> git里面吧 SSH excutable 由built-in 改成 native\n\n\n##维护git文档方法\n * 可以网页里面直接弄，就不要通本地修改再提交，太麻烦。\n * 涉及到外部链接的图片文件，git库里面建对应的文件夹统一维护。\n * 对于图片贴的地址一定要是raw的，不要那个github上显示的地址\n```markdown\n[原文件](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore) \n```\n\n##一般的git工作流程\n\n###版本管理\n###按featrue 开发\n###codereview及合并\n\n## Markdown 快捷键\n   1. 空两行，让后代码区域两个TAB\n   2. shift tab  收回一个tab\n\n\n\n\n\n\n","slug":"git_guide","published":1,"updated":"2017-03-17T13:28:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7bz000d1rjjjmup2ynn","content":"<h1 id=\"Github-教程\"><a href=\"#Github-教程\" class=\"headerlink\" title=\"Github 教程\"></a>Github 教程</h1><h2 id=\"推一个本地工程到github\"><a href=\"#推一个本地工程到github\" class=\"headerlink\" title=\"推一个本地工程到github\"></a>推一个本地工程到github</h2><ol>\n<li>首先在github上创建一个resp</li>\n<li>在本地工程里面引入 .gitignore<ul>\n<li>在androidstudio 安装一个ignore 插件，可以生成部分ignore</li>\n<li>对于gradle目录的工程，每一个存在build.gradle目录都需要放一个.gitignore</li>\n<li>.gitignore 内容 （对于android的gradle目录结构最完整的ignore文件）<a href=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore\" target=\"_blank\" rel=\"external\">原文件</a> </li>\n</ul>\n</li>\n</ol>\n<pre><code>.gradle\n/local.properties\n/gradle.properties\n/.idea/workspace.xml\n/.idea/libraries\n.DS_Store\n/build\n/captures\nbin\ngen\n.settings\n.idea\ntarget\n*.iml\n*.key\n</code></pre><ol>\n<li><p>touch README.md  》》生成 reamdme文件</p>\n</li>\n<li><p>git init当前工程 》》生成 git信息</p>\n</li>\n<li><p>git add -A 》》把当前工程除了ingore的添加到git里面</p>\n</li>\n<li><p>git commit 》》生成第一次的commit信息</p>\n</li>\n<li><p>git remote add origin git@github.com:liuyicheng3/NewRepo.git   》》设置当前git工程的远程分支</p>\n</li>\n<li><p>git push -u origin master 》》push 到github上去</p>\n</li>\n<li><p>Attention:一般android studio的默认ssh是 androidstudio自己的，所以这时候用android studio会提交不上去<br>需要在settiings&gt;vertion control&gt; git里面吧 SSH excutable 由built-in 改成 native</p>\n</li>\n</ol>\n<p>##维护git文档方法</p>\n<ul>\n<li>可以网页里面直接弄，就不要通本地修改再提交，太麻烦。</li>\n<li>涉及到外部链接的图片文件，git库里面建对应的文件夹统一维护。</li>\n<li>对于图片贴的地址一定要是raw的，不要那个github上显示的地址<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">原文件</span>](<span class=\"link\">https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>##一般的git工作流程</p>\n<p>###版本管理</p>\n<p>###按featrue 开发</p>\n<p>###codereview及合并</p>\n<h2 id=\"Markdown-快捷键\"><a href=\"#Markdown-快捷键\" class=\"headerlink\" title=\"Markdown 快捷键\"></a>Markdown 快捷键</h2><ol>\n<li>空两行，让后代码区域两个TAB</li>\n<li>shift tab  收回一个tab</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"Github-教程\"><a href=\"#Github-教程\" class=\"headerlink\" title=\"Github 教程\"></a>Github 教程</h1><h2 id=\"推一个本地工程到github\"><a href=\"#推一个本地工程到github\" class=\"headerlink\" title=\"推一个本地工程到github\"></a>推一个本地工程到github</h2><ol>\n<li>首先在github上创建一个resp</li>\n<li>在本地工程里面引入 .gitignore<ul>\n<li>在androidstudio 安装一个ignore 插件，可以生成部分ignore</li>\n<li>对于gradle目录的工程，每一个存在build.gradle目录都需要放一个.gitignore</li>\n<li>.gitignore 内容 （对于android的gradle目录结构最完整的ignore文件）<a href=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore\">原文件</a> </li>\n</ul>\n</li>\n</ol>\n<pre><code>.gradle\n/local.properties\n/gradle.properties\n/.idea/workspace.xml\n/.idea/libraries\n.DS_Store\n/build\n/captures\nbin\ngen\n.settings\n.idea\ntarget\n*.iml\n*.key\n</code></pre><ol>\n<li><p>touch README.md  》》生成 reamdme文件</p>\n</li>\n<li><p>git init当前工程 》》生成 git信息</p>\n</li>\n<li><p>git add -A 》》把当前工程除了ingore的添加到git里面</p>\n</li>\n<li><p>git commit 》》生成第一次的commit信息</p>\n</li>\n<li><p>git remote add origin git@github.com:liuyicheng3/NewRepo.git   》》设置当前git工程的远程分支</p>\n</li>\n<li><p>git push -u origin master 》》push 到github上去</p>\n</li>\n<li><p>Attention:一般android studio的默认ssh是 androidstudio自己的，所以这时候用android studio会提交不上去<br>需要在settiings&gt;vertion control&gt; git里面吧 SSH excutable 由built-in 改成 native</p>\n</li>\n</ol>\n<p>##维护git文档方法</p>\n<ul>\n<li>可以网页里面直接弄，就不要通本地修改再提交，太麻烦。</li>\n<li>涉及到外部链接的图片文件，git库里面建对应的文件夹统一维护。</li>\n<li>对于图片贴的地址一定要是raw的，不要那个github上显示的地址<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">原文件</span>](<span class=\"link\">https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>##一般的git工作流程</p>\n<p>###版本管理</p>\n<p>###按featrue 开发</p>\n<p>###codereview及合并</p>\n<h2 id=\"Markdown-快捷键\"><a href=\"#Markdown-快捷键\" class=\"headerlink\" title=\"Markdown 快捷键\"></a>Markdown 快捷键</h2><ol>\n<li>空两行，让后代码区域两个TAB</li>\n<li>shift tab  收回一个tab</li>\n</ol>\n"},{"title":"AS 踩坑日记","date":"2015-11-01T12:10:33.000Z","_content":"\n\n\n升级instant run时候的报错\nError:Access to the dex task is now impossible, starting with 1.4.0\n1.4.0 introduces a new Transform API allowing manipulation of the .class files.\nSee more information: http://tools.android.com/tech-docs/new-build-system/transform-api\n\n解决方案：\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.0.0'\n\n    }\n}\n\n改成1.3.0\n\n\n项目根目录的gradle的\ngrade.property\n\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-2.2-all.zip\n","source":"_posts/gradle坑.md","raw":"title: AS 踩坑日记\ndate: 2015-11-01 20:10:33\ncategories:\n- 工具\ntags:\n- 工具\n\n---\n\n\n\n升级instant run时候的报错\nError:Access to the dex task is now impossible, starting with 1.4.0\n1.4.0 introduces a new Transform API allowing manipulation of the .class files.\nSee more information: http://tools.android.com/tech-docs/new-build-system/transform-api\n\n解决方案：\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.0.0'\n\n    }\n}\n\n改成1.3.0\n\n\n项目根目录的gradle的\ngrade.property\n\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-2.2-all.zip\n","slug":"gradle坑","published":1,"updated":"2017-03-17T13:29:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7c1000h1rjjoa1haq4t","content":"<p>升级instant run时候的报错<br>Error:Access to the dex task is now impossible, starting with 1.4.0<br>1.4.0 introduces a new Transform API allowing manipulation of the .class files.<br>See more information: <a href=\"http://tools.android.com/tech-docs/new-build-system/transform-api\" target=\"_blank\" rel=\"external\">http://tools.android.com/tech-docs/new-build-system/transform-api</a></p>\n<p>解决方案：</p>\n<p>buildscript {<br>    repositories {<br>        jcenter()<br>    }<br>    dependencies {<br>        classpath ‘com.android.tools.build:gradle:2.0.0’</p>\n<pre><code>}\n</code></pre><p>}</p>\n<p>改成1.3.0</p>\n<p>项目根目录的gradle的<br>grade.property</p>\n<p>distributionUrl=https\\://services.gradle.org/distributions/gradle-2.2-all.zip</p>\n","excerpt":"","more":"<p>升级instant run时候的报错<br>Error:Access to the dex task is now impossible, starting with 1.4.0<br>1.4.0 introduces a new Transform API allowing manipulation of the .class files.<br>See more information: <a href=\"http://tools.android.com/tech-docs/new-build-system/transform-api\">http://tools.android.com/tech-docs/new-build-system/transform-api</a></p>\n<p>解决方案：</p>\n<p>buildscript {<br>    repositories {<br>        jcenter()<br>    }<br>    dependencies {<br>        classpath ‘com.android.tools.build:gradle:2.0.0’</p>\n<pre><code>}\n</code></pre><p>}</p>\n<p>改成1.3.0</p>\n<p>项目根目录的gradle的<br>grade.property</p>\n<p>distributionUrl=https\\://services.gradle.org/distributions/gradle-2.2-all.zip</p>\n"},{"title":"立个flag 不要忘记","date":"2015-11-01T12:10:33.000Z","_content":"\n\nStickyHeaderListView  头部悬停  吸附的控件\n\n\njava  bitmap的实现  http://blog.csdn.net/xia744510124/article/details/51509285\n\n0x00000001\n\nHideOnListViewListener\n\n","source":"_posts/never_forget.md","raw":"title: 立个flag 不要忘记\ndate: 2015-11-01 20:10:33\ncategories:\n- 其它\ntags:\n- 其他\n\n---\n\n\nStickyHeaderListView  头部悬停  吸附的控件\n\n\njava  bitmap的实现  http://blog.csdn.net/xia744510124/article/details/51509285\n\n0x00000001\n\nHideOnListViewListener\n\n","slug":"never_forget","published":1,"updated":"2017-03-17T13:33:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7c2000j1rjjehvoq8y4","content":"<p>StickyHeaderListView  头部悬停  吸附的控件</p>\n<p>java  bitmap的实现  <a href=\"http://blog.csdn.net/xia744510124/article/details/51509285\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/xia744510124/article/details/51509285</a></p>\n<p>0x00000001</p>\n<p>HideOnListViewListener</p>\n","excerpt":"","more":"<p>StickyHeaderListView  头部悬停  吸附的控件</p>\n<p>java  bitmap的实现  <a href=\"http://blog.csdn.net/xia744510124/article/details/51509285\">http://blog.csdn.net/xia744510124/article/details/51509285</a></p>\n<p>0x00000001</p>\n<p>HideOnListViewListener</p>\n"},{"title":"iOS入门","date":"2015-11-01T12:10:33.000Z","_content":"\n\n\n# 第一课：熟悉OC语法\n\n# 第二课：storyboard和 手写View\n\nstoryboard;\n\n直接往上面拖放控件，然后按住ctr  把控件拖动到   @implementation，就相当于自动findview了，可以直接使用是这个控件了  \n\n   @property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;\n\n\n还有一种就是直接关联上点击事件\n把控件直接拖动到这个申明方法上就可以了\n\n\n    - (IBAction)showAlert:(id)sender;\n\n这个的原理可以看看storyboard的文件内容就可以明白了，大致和android的类似\n\n\n\n图片资源文件两种放法\n1. 在Supporting  Files 同级添加一个Resources的包，里面直接放图片进去（可以只放三倍图）   \n\n         UIImageView *imageView = [[UIImageView alloc] init];\n            imageView.image = [UIImage imageNamed:@\"home_banner.png\"];\t// 正常显示的图片\n            \n2. 在Assets.xcaseset里面右键新建New image set，然后手动把图片拖动到右边的一倍两倍三倍的框框中去 \n\n\n\n\nstoryboard  改成手写UI类型  \n\n1. 第一步： \n- 删除storyboard文件  \n- 编辑Supporting Files目录下的 .plist文件,\n删除Main storyboard  file name这一项\n2. 第二步：\n    编辑AppDelegate\n\n    \n    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n        self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n        [self.window makeKeyAndVisible];\n        \n        ViewController *__rootController = [[ViewController alloc] init];\n        UINavigationController *__navCtrler = [[UINavigationController alloc] initWithRootViewController:__rootController];\n        __navCtrler.navigationBarHidden = YES;\n        self.window.rootViewController = __navCtrler;\n      // Override point for customization after application launch.\n        return YES;\n    }\n\n\n这个相当于Application的oncreate,在这里加载Entry activity\n\n\n在ViewController里面手动往根View里面添加控件\n\n    - (void)viewDidLoad {\n        [super viewDidLoad];\n        \n        UILabel *firstLable=[[UILabel alloc]init];\n        firstLable.frame=CGRectMake(0, 0, 100, 100);\n        firstLable.backgroundColor = [UIColor whiteColor]; //设置lable背景颜色为黑色\n    \n        firstLable.text=@\"第一级\";\n        firstLable.userInteractionEnabled = YES;\n    \n        [firstLable setTextColor:[UIColor greenColor]]; //设置文本字体颜色为白色\n    \n        [self.view addSubview:firstLable];\n        UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapLable:)];\n        [firstLable addGestureRecognizer:singleTap];\n        \n        // Do any additional setup after loading the view, typically from a nib.\n    }\n\n\nviewDidLoad 相当于Activity的oncreate，这里我们就是手写View，然后加到根View里面去 self.view\n    [self.view addSubview:firstLable];\n\n\n\n# 第三课：Viewcontroller  之间的跳转\n\n在ViewController从一个Viewcontroller跳到另外一个SecondViewController\n\n    -(void) tapLable:(UILabel *)sender{\n        NSLog(@\"进入第二级Controller\");\n        \n        SecondViewController *controller = [[SecondViewController alloc] init];\n        [self.navigationController pushViewController:controller animated:YES];\n    }\n\n\n在SecondViewController也是一样的写法\n\n 返回第一个VIewCOntroller的方法\n\n    [self.navigationController popViewControllerAnimated:YES];\n","source":"_posts/ios学习笔记.md","raw":"title: iOS入门\ndate: 2015-11-01 20:10:33\ncategories:\n- iOS\ntags:\n- ios入门\n\n---\n\n\n\n# 第一课：熟悉OC语法\n\n# 第二课：storyboard和 手写View\n\nstoryboard;\n\n直接往上面拖放控件，然后按住ctr  把控件拖动到   @implementation，就相当于自动findview了，可以直接使用是这个控件了  \n\n   @property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;\n\n\n还有一种就是直接关联上点击事件\n把控件直接拖动到这个申明方法上就可以了\n\n\n    - (IBAction)showAlert:(id)sender;\n\n这个的原理可以看看storyboard的文件内容就可以明白了，大致和android的类似\n\n\n\n图片资源文件两种放法\n1. 在Supporting  Files 同级添加一个Resources的包，里面直接放图片进去（可以只放三倍图）   \n\n         UIImageView *imageView = [[UIImageView alloc] init];\n            imageView.image = [UIImage imageNamed:@\"home_banner.png\"];\t// 正常显示的图片\n            \n2. 在Assets.xcaseset里面右键新建New image set，然后手动把图片拖动到右边的一倍两倍三倍的框框中去 \n\n\n\n\nstoryboard  改成手写UI类型  \n\n1. 第一步： \n- 删除storyboard文件  \n- 编辑Supporting Files目录下的 .plist文件,\n删除Main storyboard  file name这一项\n2. 第二步：\n    编辑AppDelegate\n\n    \n    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n        self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n        [self.window makeKeyAndVisible];\n        \n        ViewController *__rootController = [[ViewController alloc] init];\n        UINavigationController *__navCtrler = [[UINavigationController alloc] initWithRootViewController:__rootController];\n        __navCtrler.navigationBarHidden = YES;\n        self.window.rootViewController = __navCtrler;\n      // Override point for customization after application launch.\n        return YES;\n    }\n\n\n这个相当于Application的oncreate,在这里加载Entry activity\n\n\n在ViewController里面手动往根View里面添加控件\n\n    - (void)viewDidLoad {\n        [super viewDidLoad];\n        \n        UILabel *firstLable=[[UILabel alloc]init];\n        firstLable.frame=CGRectMake(0, 0, 100, 100);\n        firstLable.backgroundColor = [UIColor whiteColor]; //设置lable背景颜色为黑色\n    \n        firstLable.text=@\"第一级\";\n        firstLable.userInteractionEnabled = YES;\n    \n        [firstLable setTextColor:[UIColor greenColor]]; //设置文本字体颜色为白色\n    \n        [self.view addSubview:firstLable];\n        UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapLable:)];\n        [firstLable addGestureRecognizer:singleTap];\n        \n        // Do any additional setup after loading the view, typically from a nib.\n    }\n\n\nviewDidLoad 相当于Activity的oncreate，这里我们就是手写View，然后加到根View里面去 self.view\n    [self.view addSubview:firstLable];\n\n\n\n# 第三课：Viewcontroller  之间的跳转\n\n在ViewController从一个Viewcontroller跳到另外一个SecondViewController\n\n    -(void) tapLable:(UILabel *)sender{\n        NSLog(@\"进入第二级Controller\");\n        \n        SecondViewController *controller = [[SecondViewController alloc] init];\n        [self.navigationController pushViewController:controller animated:YES];\n    }\n\n\n在SecondViewController也是一样的写法\n\n 返回第一个VIewCOntroller的方法\n\n    [self.navigationController popViewControllerAnimated:YES];\n","slug":"ios学习笔记","published":1,"updated":"2017-03-17T13:32:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7c6000n1rjjww1xihdp","content":"<h1 id=\"第一课：熟悉OC语法\"><a href=\"#第一课：熟悉OC语法\" class=\"headerlink\" title=\"第一课：熟悉OC语法\"></a>第一课：熟悉OC语法</h1><h1 id=\"第二课：storyboard和-手写View\"><a href=\"#第二课：storyboard和-手写View\" class=\"headerlink\" title=\"第二课：storyboard和 手写View\"></a>第二课：storyboard和 手写View</h1><p>storyboard;</p>\n<p>直接往上面拖放控件，然后按住ctr  把控件拖动到   @implementation，就相当于自动findview了，可以直接使用是这个控件了  </p>\n<p>   @property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;</p>\n<p>还有一种就是直接关联上点击事件<br>把控件直接拖动到这个申明方法上就可以了</p>\n<pre><code>- (IBAction)showAlert:(id)sender;\n</code></pre><p>这个的原理可以看看storyboard的文件内容就可以明白了，大致和android的类似</p>\n<p>图片资源文件两种放法</p>\n<ol>\n<li><p>在Supporting  Files 同级添加一个Resources的包，里面直接放图片进去（可以只放三倍图）   </p>\n<pre><code>UIImageView *imageView = [[UIImageView alloc] init];\n   imageView.image = [UIImage imageNamed:@&quot;home_banner.png&quot;];    // 正常显示的图片\n</code></pre></li>\n<li><p>在Assets.xcaseset里面右键新建New image set，然后手动把图片拖动到右边的一倍两倍三倍的框框中去 </p>\n</li>\n</ol>\n<p>storyboard  改成手写UI类型  </p>\n<ol>\n<li>第一步： </li>\n</ol>\n<ul>\n<li>删除storyboard文件  </li>\n<li>编辑Supporting Files目录下的 .plist文件,<br>删除Main storyboard  file name这一项</li>\n</ul>\n<ol>\n<li>第二步：<br> 编辑AppDelegate</li>\n</ol>\n<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n    [self.window makeKeyAndVisible];\n\n    ViewController *__rootController = [[ViewController alloc] init];\n    UINavigationController *__navCtrler = [[UINavigationController alloc] initWithRootViewController:__rootController];\n    __navCtrler.navigationBarHidden = YES;\n    self.window.rootViewController = __navCtrler;\n  // Override point for customization after application launch.\n    return YES;\n}\n</code></pre><p>这个相当于Application的oncreate,在这里加载Entry activity</p>\n<p>在ViewController里面手动往根View里面添加控件</p>\n<pre><code>- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UILabel *firstLable=[[UILabel alloc]init];\n    firstLable.frame=CGRectMake(0, 0, 100, 100);\n    firstLable.backgroundColor = [UIColor whiteColor]; //设置lable背景颜色为黑色\n\n    firstLable.text=@&quot;第一级&quot;;\n    firstLable.userInteractionEnabled = YES;\n\n    [firstLable setTextColor:[UIColor greenColor]]; //设置文本字体颜色为白色\n\n    [self.view addSubview:firstLable];\n    UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapLable:)];\n    [firstLable addGestureRecognizer:singleTap];\n\n    // Do any additional setup after loading the view, typically from a nib.\n}\n</code></pre><p>viewDidLoad 相当于Activity的oncreate，这里我们就是手写View，然后加到根View里面去 self.view<br>    [self.view addSubview:firstLable];</p>\n<h1 id=\"第三课：Viewcontroller-之间的跳转\"><a href=\"#第三课：Viewcontroller-之间的跳转\" class=\"headerlink\" title=\"第三课：Viewcontroller  之间的跳转\"></a>第三课：Viewcontroller  之间的跳转</h1><p>在ViewController从一个Viewcontroller跳到另外一个SecondViewController</p>\n<pre><code>-(void) tapLable:(UILabel *)sender{\n    NSLog(@&quot;进入第二级Controller&quot;);\n\n    SecondViewController *controller = [[SecondViewController alloc] init];\n    [self.navigationController pushViewController:controller animated:YES];\n}\n</code></pre><p>在SecondViewController也是一样的写法</p>\n<p> 返回第一个VIewCOntroller的方法</p>\n<pre><code>[self.navigationController popViewControllerAnimated:YES];\n</code></pre>","excerpt":"","more":"<h1 id=\"第一课：熟悉OC语法\"><a href=\"#第一课：熟悉OC语法\" class=\"headerlink\" title=\"第一课：熟悉OC语法\"></a>第一课：熟悉OC语法</h1><h1 id=\"第二课：storyboard和-手写View\"><a href=\"#第二课：storyboard和-手写View\" class=\"headerlink\" title=\"第二课：storyboard和 手写View\"></a>第二课：storyboard和 手写View</h1><p>storyboard;</p>\n<p>直接往上面拖放控件，然后按住ctr  把控件拖动到   @implementation，就相当于自动findview了，可以直接使用是这个控件了  </p>\n<p>   @property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;</p>\n<p>还有一种就是直接关联上点击事件<br>把控件直接拖动到这个申明方法上就可以了</p>\n<pre><code>- (IBAction)showAlert:(id)sender;\n</code></pre><p>这个的原理可以看看storyboard的文件内容就可以明白了，大致和android的类似</p>\n<p>图片资源文件两种放法</p>\n<ol>\n<li><p>在Supporting  Files 同级添加一个Resources的包，里面直接放图片进去（可以只放三倍图）   </p>\n<pre><code>UIImageView *imageView = [[UIImageView alloc] init];\n   imageView.image = [UIImage imageNamed:@&quot;home_banner.png&quot;];    // 正常显示的图片\n</code></pre></li>\n<li><p>在Assets.xcaseset里面右键新建New image set，然后手动把图片拖动到右边的一倍两倍三倍的框框中去 </p>\n</li>\n</ol>\n<p>storyboard  改成手写UI类型  </p>\n<ol>\n<li>第一步： </li>\n</ol>\n<ul>\n<li>删除storyboard文件  </li>\n<li>编辑Supporting Files目录下的 .plist文件,<br>删除Main storyboard  file name这一项</li>\n</ul>\n<ol>\n<li>第二步：<br> 编辑AppDelegate</li>\n</ol>\n<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n    [self.window makeKeyAndVisible];\n\n    ViewController *__rootController = [[ViewController alloc] init];\n    UINavigationController *__navCtrler = [[UINavigationController alloc] initWithRootViewController:__rootController];\n    __navCtrler.navigationBarHidden = YES;\n    self.window.rootViewController = __navCtrler;\n  // Override point for customization after application launch.\n    return YES;\n}\n</code></pre><p>这个相当于Application的oncreate,在这里加载Entry activity</p>\n<p>在ViewController里面手动往根View里面添加控件</p>\n<pre><code>- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UILabel *firstLable=[[UILabel alloc]init];\n    firstLable.frame=CGRectMake(0, 0, 100, 100);\n    firstLable.backgroundColor = [UIColor whiteColor]; //设置lable背景颜色为黑色\n\n    firstLable.text=@&quot;第一级&quot;;\n    firstLable.userInteractionEnabled = YES;\n\n    [firstLable setTextColor:[UIColor greenColor]]; //设置文本字体颜色为白色\n\n    [self.view addSubview:firstLable];\n    UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapLable:)];\n    [firstLable addGestureRecognizer:singleTap];\n\n    // Do any additional setup after loading the view, typically from a nib.\n}\n</code></pre><p>viewDidLoad 相当于Activity的oncreate，这里我们就是手写View，然后加到根View里面去 self.view<br>    [self.view addSubview:firstLable];</p>\n<h1 id=\"第三课：Viewcontroller-之间的跳转\"><a href=\"#第三课：Viewcontroller-之间的跳转\" class=\"headerlink\" title=\"第三课：Viewcontroller  之间的跳转\"></a>第三课：Viewcontroller  之间的跳转</h1><p>在ViewController从一个Viewcontroller跳到另外一个SecondViewController</p>\n<pre><code>-(void) tapLable:(UILabel *)sender{\n    NSLog(@&quot;进入第二级Controller&quot;);\n\n    SecondViewController *controller = [[SecondViewController alloc] init];\n    [self.navigationController pushViewController:controller animated:YES];\n}\n</code></pre><p>在SecondViewController也是一样的写法</p>\n<p> 返回第一个VIewCOntroller的方法</p>\n<pre><code>[self.navigationController popViewControllerAnimated:YES];\n</code></pre>"},{"title":"okhttp源码解析","date":"2015-11-01T12:10:33.000Z","_content":"\n\n# okttp 解析（okio以后再讲  So   ignore  Sink   Source）\n\n## Interface：OkhttpClient（singleton）  Request  Response\n\n## 主要由以下三部分 组成  \n\n### 1. 任务调度： 核心类disruptor（singleton） \n\na. 线程池   \nb. 队列\n\n\n      /** Ready async calls in the order they'll be run. */\n      private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n      \n      /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n      private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n      \n      /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n       private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n\n(由于okhttp两种 运行模式   sync  和async）\n\n### 2. 网络请求   \n* 核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） \n* 每个请求会生成一个Request  \n* 然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  \n\n\nokhttp一个请求的完整流程图  \n ![image](http://blog.piasy.com/img/201607/okhttp_full_process.png)\n\n在realcall的execute方法中会调用     \n\n\n    client.dispatcher().executed(this);//问题1  \n    Response result = getResponseWithInterceptorChain(false);//问题2  \n \n获得请求结果.    \n现在看问题1  在这里面干了写什么   \n其实就是 dispatcher记录任务而已 ，没有任何执行方法  \n核心在问题2中  \n她会  \n\n\n    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\n    return chain.proceed(originalRequest);\n也就是生成拦截器 ，并用这个拦截器启动这个请求\n继续进入proceed 可以看到\n进入了ApplicationInterceptorChain的getresponse方法\n开始构造HttpEngine    \n\n    engine.sendRequest();//问题21\n    engine.readResponse();//问题22\n   \n在问题21中其实就是  Rfc 标准的一种 实现  \n\n    InternalCache responseCache = Internal.instance.internalCache(client);\n    Response cacheCandidate = responseCache != null\n        ? responseCache.get(request)\n        : null;\n        \n就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache\n这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程 \n当取到值后还要根据http cache的rfc标准  判断  是否合理能使用\nnew CacheStrategy.Factory(now, request, cacheCandidate).get();\n在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  \n\n这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）\n\n      if (etag != null) {\n        conditionalRequestBuilder.header(\"If-None-Match\", etag);\n      } else if (lastModified != null) {\n        conditionalRequestBuilder.header(\"If-Modified-Since\", lastModifiedString);\n      } else if (servedDate != null) {\n        conditionalRequestBuilder.header(\"If-Modified-Since\", servedDateString);\n      }\n\n      Request conditionalRequest = conditionalRequestBuilder.build();\n\n这是请求前的工作\n现在开始发送请求\n\n      httpStream = connect();\n      httpStream.setHttpEngine(this);\n这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）\n\n    streamAllocation.newStream(client.connectTimeoutMillis(),\n    client.readTimeoutMillis(), client.writeTimeoutMillis(),\n    client.retryOnConnectionFailure(), doExtensiveHealthChecks);\n解决的问题 是socket连接重用和  route\n先是从连接池中找\n\n\n     // Attempt to get a connection from the pool.\n      RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);\n      if (pooledConnection != null) {\n        this.connection = pooledConnection;\n        return pooledConnection;\n      }\n如果没有的话就看route可以重用嘛\n\n     if (selectedRoute == null) {\n      selectedRoute = routeSelector.next();\n      synchronized (connectionPool) {\n        route = selectedRoute;\n      }\n    }\n    RealConnection newConnection = new RealConnection(selectedRoute);\n    acquire(newConnection);\n（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止\n\n    RouteDatabase里的Set<Route> failedRoutes = new LinkedHashSet<>()）\n弄完之后就是放如   \n\n     Internal.instance.put(connectionPool, newConnection);\n连接池中  方便下次继续使用\n下一步 就是建立socket连接的过程\n\n     newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),\n        connectionRetryEnabled);\n    routeDatabase().connected(newConnection.route());\n跟进去 就是\n\n       connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n继续\n\n     try {\n      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);\n    } catch (ConnectException e) {\n      throw new ConnectException(\"Failed to connect to \" + route.socketAddress());\n    }\n    source = Okio.buffer(Okio.source(rawSocket));\n    sink = Okio.buffer(Okio.sink(rawSocket));\n连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的\n然后才是真正发送这个请求的过程\n\n       httpStream.writeRequestHeaders(networkRequest);\n       requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);\n继续跟进\n\n     httpEngine.writingRequestHeaders();\n      String requestLine = RequestLine.get(\n        request, httpEngine.getConnection().route().proxy().type());\n    writeRequest(request.headers(), requestLine);\n\n》》\n\n    ** Returns bytes of a request header for sending on an HTTP transport. */\n    public void writeRequest(Headers headers, String requestLine) throws IOException {\n    if (state != STATE_IDLE) throw new IllegalStateException(\"state: \" + state);\n    sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\");\n    for (int i = 0, size = headers.size(); i < size; i++) {\n      sink.writeUtf8(headers.name(i))\n          .writeUtf8(\": \")\n          .writeUtf8(headers.value(i))\n          .writeUtf8(\"\\r\\n\");\n    }\n    sink.writeUtf8(\"\\r\\n\");\n    state = STATE_OPEN_REQUEST_BODY;\n    }\n\n\n读过程\n就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink\n\n\n\n\n\n\n\n到此 请求reponse的工作做完了\n现在 如果是需要真正发送网络请求就也就是问题22\n\n      networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);\n》》\n\n     engin.readResponse\n》》\n\n      // Write the request body to the socket.\n      if (requestBodyOut != null) {\n        if (bufferedRequestBody != null) {\n          // This also closes the wrapped requestBodyOut.\n          bufferedRequestBody.close();\n        } else {\n          requestBodyOut.close();\n        }\n        if (requestBodyOut instanceof RetryableSink) {\n          httpStream.writeRequestBody((RetryableSink) requestBodyOut);\n        }\n      }\n\n      networkResponse = readNetworkResponse();\n\n》》\n\n    Response readNetworkResponse() throws IOException {\n    httpStream.finishRequest();\n\n    Response networkResponse = httpStream.readResponseHeaders()\n        .request(networkRequest)\n        .handshake(streamAllocation.connection().handshake())\n        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))\n        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))\n        .build();\n\n    if (!forWebSocket) {\n      networkResponse = networkResponse.newBuilder()\n          .body(httpStream.openResponseBody(networkResponse))\n          .build();\n    }\n\n    if (\"close\".equalsIgnoreCase(networkResponse.request().header(\"Connection\"))\n        || \"close\".equalsIgnoreCase(networkResponse.header(\"Connection\"))) {\n      streamAllocation.noNewStreams();\n    }\n\n    return networkResponse;\n  }\n\n解析和返回\n\n      Response response = engine.getResponse();\n\n\n     //tobe continue（已经 cache过程 请求重试过程）\n      Request followUp = engine.followUpRequest();\n\n\n\n### 3. cache管理\n\n\n\n\n最后附上 相关的http请求cache的rfc内容\n ![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg)\n\n### 每个状态的详细说明如下：\n\n#### 1. Last-Modified  \n在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：  \nLast-Modified:Tue, 24 Feb 2009 08:01:04 GMT  \n客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：  \nIf-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT  \n如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。  \n注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  \n\n#### 2. Etag工作原理  \nHTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：  \nEtag:“5d8c72a5edda8d6a:3239″  \n客户端的查询更新格式是这样的： \nIf-None-Match:“5d8c72a5edda8d6a:3239″  \n如果ETag没改变，则返回状态304。  \n即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″  \n标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。  \nIf-None-Match:“5d8c72a5edda8d6a:3239“  \n,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  \n\n#### 3. Expires  \n给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT  \n需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  \n\n#### 4. Last-Modified和Expires  \nLast-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  \n\n\n#### 5. Etag和Expires  \n如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  \n\n\n#### 6. Last-Modified和Etag  \n分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败  \n分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)  \nLast-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存  \n过程如下:  \n* 客户端请求一个页面（A）。  \n* 服务器返回页面A，并在给A加上一个Last-Modified/ETag。  \n* 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  \n* 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  \n* 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  \n\n\n备注：   \n* Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  \n* WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  \n* 客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  \n* 通过上述值到服务器端检查，判断文件是否继续缓存；  \n\n\n#### 7.关于 Cache-Control: max-age=秒 和 Expires  \nExpires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）  \nmax-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。  \n如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。  \nExpires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。  \nExpires =max-age +   “每次下载时的当前的request时间”  \n所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   \n\n\n\n","source":"_posts/okhttp.md","raw":"title: okhttp源码解析\ndate: 2015-11-01 20:10:33\ncategories:\n- android\ntags:\n- 网络层\n\n---\n\n\n# okttp 解析（okio以后再讲  So   ignore  Sink   Source）\n\n## Interface：OkhttpClient（singleton）  Request  Response\n\n## 主要由以下三部分 组成  \n\n### 1. 任务调度： 核心类disruptor（singleton） \n\na. 线程池   \nb. 队列\n\n\n      /** Ready async calls in the order they'll be run. */\n      private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n      \n      /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n      private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n      \n      /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n       private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n\n(由于okhttp两种 运行模式   sync  和async）\n\n### 2. 网络请求   \n* 核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） \n* 每个请求会生成一个Request  \n* 然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  \n\n\nokhttp一个请求的完整流程图  \n ![image](http://blog.piasy.com/img/201607/okhttp_full_process.png)\n\n在realcall的execute方法中会调用     \n\n\n    client.dispatcher().executed(this);//问题1  \n    Response result = getResponseWithInterceptorChain(false);//问题2  \n \n获得请求结果.    \n现在看问题1  在这里面干了写什么   \n其实就是 dispatcher记录任务而已 ，没有任何执行方法  \n核心在问题2中  \n她会  \n\n\n    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\n    return chain.proceed(originalRequest);\n也就是生成拦截器 ，并用这个拦截器启动这个请求\n继续进入proceed 可以看到\n进入了ApplicationInterceptorChain的getresponse方法\n开始构造HttpEngine    \n\n    engine.sendRequest();//问题21\n    engine.readResponse();//问题22\n   \n在问题21中其实就是  Rfc 标准的一种 实现  \n\n    InternalCache responseCache = Internal.instance.internalCache(client);\n    Response cacheCandidate = responseCache != null\n        ? responseCache.get(request)\n        : null;\n        \n就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache\n这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程 \n当取到值后还要根据http cache的rfc标准  判断  是否合理能使用\nnew CacheStrategy.Factory(now, request, cacheCandidate).get();\n在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  \n\n这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）\n\n      if (etag != null) {\n        conditionalRequestBuilder.header(\"If-None-Match\", etag);\n      } else if (lastModified != null) {\n        conditionalRequestBuilder.header(\"If-Modified-Since\", lastModifiedString);\n      } else if (servedDate != null) {\n        conditionalRequestBuilder.header(\"If-Modified-Since\", servedDateString);\n      }\n\n      Request conditionalRequest = conditionalRequestBuilder.build();\n\n这是请求前的工作\n现在开始发送请求\n\n      httpStream = connect();\n      httpStream.setHttpEngine(this);\n这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）\n\n    streamAllocation.newStream(client.connectTimeoutMillis(),\n    client.readTimeoutMillis(), client.writeTimeoutMillis(),\n    client.retryOnConnectionFailure(), doExtensiveHealthChecks);\n解决的问题 是socket连接重用和  route\n先是从连接池中找\n\n\n     // Attempt to get a connection from the pool.\n      RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);\n      if (pooledConnection != null) {\n        this.connection = pooledConnection;\n        return pooledConnection;\n      }\n如果没有的话就看route可以重用嘛\n\n     if (selectedRoute == null) {\n      selectedRoute = routeSelector.next();\n      synchronized (connectionPool) {\n        route = selectedRoute;\n      }\n    }\n    RealConnection newConnection = new RealConnection(selectedRoute);\n    acquire(newConnection);\n（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止\n\n    RouteDatabase里的Set<Route> failedRoutes = new LinkedHashSet<>()）\n弄完之后就是放如   \n\n     Internal.instance.put(connectionPool, newConnection);\n连接池中  方便下次继续使用\n下一步 就是建立socket连接的过程\n\n     newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),\n        connectionRetryEnabled);\n    routeDatabase().connected(newConnection.route());\n跟进去 就是\n\n       connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n继续\n\n     try {\n      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);\n    } catch (ConnectException e) {\n      throw new ConnectException(\"Failed to connect to \" + route.socketAddress());\n    }\n    source = Okio.buffer(Okio.source(rawSocket));\n    sink = Okio.buffer(Okio.sink(rawSocket));\n连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的\n然后才是真正发送这个请求的过程\n\n       httpStream.writeRequestHeaders(networkRequest);\n       requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);\n继续跟进\n\n     httpEngine.writingRequestHeaders();\n      String requestLine = RequestLine.get(\n        request, httpEngine.getConnection().route().proxy().type());\n    writeRequest(request.headers(), requestLine);\n\n》》\n\n    ** Returns bytes of a request header for sending on an HTTP transport. */\n    public void writeRequest(Headers headers, String requestLine) throws IOException {\n    if (state != STATE_IDLE) throw new IllegalStateException(\"state: \" + state);\n    sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\");\n    for (int i = 0, size = headers.size(); i < size; i++) {\n      sink.writeUtf8(headers.name(i))\n          .writeUtf8(\": \")\n          .writeUtf8(headers.value(i))\n          .writeUtf8(\"\\r\\n\");\n    }\n    sink.writeUtf8(\"\\r\\n\");\n    state = STATE_OPEN_REQUEST_BODY;\n    }\n\n\n读过程\n就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink\n\n\n\n\n\n\n\n到此 请求reponse的工作做完了\n现在 如果是需要真正发送网络请求就也就是问题22\n\n      networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);\n》》\n\n     engin.readResponse\n》》\n\n      // Write the request body to the socket.\n      if (requestBodyOut != null) {\n        if (bufferedRequestBody != null) {\n          // This also closes the wrapped requestBodyOut.\n          bufferedRequestBody.close();\n        } else {\n          requestBodyOut.close();\n        }\n        if (requestBodyOut instanceof RetryableSink) {\n          httpStream.writeRequestBody((RetryableSink) requestBodyOut);\n        }\n      }\n\n      networkResponse = readNetworkResponse();\n\n》》\n\n    Response readNetworkResponse() throws IOException {\n    httpStream.finishRequest();\n\n    Response networkResponse = httpStream.readResponseHeaders()\n        .request(networkRequest)\n        .handshake(streamAllocation.connection().handshake())\n        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))\n        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))\n        .build();\n\n    if (!forWebSocket) {\n      networkResponse = networkResponse.newBuilder()\n          .body(httpStream.openResponseBody(networkResponse))\n          .build();\n    }\n\n    if (\"close\".equalsIgnoreCase(networkResponse.request().header(\"Connection\"))\n        || \"close\".equalsIgnoreCase(networkResponse.header(\"Connection\"))) {\n      streamAllocation.noNewStreams();\n    }\n\n    return networkResponse;\n  }\n\n解析和返回\n\n      Response response = engine.getResponse();\n\n\n     //tobe continue（已经 cache过程 请求重试过程）\n      Request followUp = engine.followUpRequest();\n\n\n\n### 3. cache管理\n\n\n\n\n最后附上 相关的http请求cache的rfc内容\n ![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg)\n\n### 每个状态的详细说明如下：\n\n#### 1. Last-Modified  \n在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：  \nLast-Modified:Tue, 24 Feb 2009 08:01:04 GMT  \n客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：  \nIf-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT  \n如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。  \n注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  \n\n#### 2. Etag工作原理  \nHTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：  \nEtag:“5d8c72a5edda8d6a:3239″  \n客户端的查询更新格式是这样的： \nIf-None-Match:“5d8c72a5edda8d6a:3239″  \n如果ETag没改变，则返回状态304。  \n即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″  \n标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。  \nIf-None-Match:“5d8c72a5edda8d6a:3239“  \n,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  \n\n#### 3. Expires  \n给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT  \n需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  \n\n#### 4. Last-Modified和Expires  \nLast-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  \n\n\n#### 5. Etag和Expires  \n如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  \n\n\n#### 6. Last-Modified和Etag  \n分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败  \n分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)  \nLast-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存  \n过程如下:  \n* 客户端请求一个页面（A）。  \n* 服务器返回页面A，并在给A加上一个Last-Modified/ETag。  \n* 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  \n* 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  \n* 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  \n\n\n备注：   \n* Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  \n* WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  \n* 客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  \n* 通过上述值到服务器端检查，判断文件是否继续缓存；  \n\n\n#### 7.关于 Cache-Control: max-age=秒 和 Expires  \nExpires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）  \nmax-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。  \n如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。  \nExpires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。  \nExpires =max-age +   “每次下载时的当前的request时间”  \n所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   \n\n\n\n","slug":"okhttp","published":1,"updated":"2017-03-17T13:34:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7c8000p1rjj02xz9kyf","content":"<h1 id=\"okttp-解析（okio以后再讲-So-ignore-Sink-Source）\"><a href=\"#okttp-解析（okio以后再讲-So-ignore-Sink-Source）\" class=\"headerlink\" title=\"okttp 解析（okio以后再讲  So   ignore  Sink   Source）\"></a>okttp 解析（okio以后再讲  So   ignore  Sink   Source）</h1><h2 id=\"Interface：OkhttpClient（singleton）-Request-Response\"><a href=\"#Interface：OkhttpClient（singleton）-Request-Response\" class=\"headerlink\" title=\"Interface：OkhttpClient（singleton）  Request  Response\"></a>Interface：OkhttpClient（singleton）  Request  Response</h2><h2 id=\"主要由以下三部分-组成\"><a href=\"#主要由以下三部分-组成\" class=\"headerlink\" title=\"主要由以下三部分 组成\"></a>主要由以下三部分 组成</h2><h3 id=\"1-任务调度：-核心类disruptor（singleton）\"><a href=\"#1-任务调度：-核心类disruptor（singleton）\" class=\"headerlink\" title=\"1. 任务调度： 核心类disruptor（singleton）\"></a>1. 任务调度： 核心类disruptor（singleton）</h3><p>a. 线程池<br>b. 队列</p>\n<pre><code>/** Ready async calls in the order they&apos;ll be run. */\nprivate final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */\n private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();\n</code></pre><p>(由于okhttp两种 运行模式   sync  和async）</p>\n<h3 id=\"2-网络请求\"><a href=\"#2-网络请求\" class=\"headerlink\" title=\"2. 网络请求\"></a>2. 网络请求</h3><ul>\n<li>核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） </li>\n<li>每个请求会生成一个Request  </li>\n<li>然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  </li>\n</ul>\n<p>okhttp一个请求的完整流程图<br> <img src=\"http://blog.piasy.com/img/201607/okhttp_full_process.png\" alt=\"image\"></p>\n<p>在realcall的execute方法中会调用     </p>\n<pre><code>client.dispatcher().executed(this);//问题1  \nResponse result = getResponseWithInterceptorChain(false);//问题2  \n</code></pre><p>获得请求结果.<br>现在看问题1  在这里面干了写什么<br>其实就是 dispatcher记录任务而已 ，没有任何执行方法<br>核心在问题2中<br>她会  </p>\n<pre><code>Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\nreturn chain.proceed(originalRequest);\n</code></pre><p>也就是生成拦截器 ，并用这个拦截器启动这个请求<br>继续进入proceed 可以看到<br>进入了ApplicationInterceptorChain的getresponse方法<br>开始构造HttpEngine    </p>\n<pre><code>engine.sendRequest();//问题21\nengine.readResponse();//问题22\n</code></pre><p>在问题21中其实就是  Rfc 标准的一种 实现  </p>\n<pre><code>InternalCache responseCache = Internal.instance.internalCache(client);\nResponse cacheCandidate = responseCache != null\n    ? responseCache.get(request)\n    : null;\n</code></pre><p>就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache<br>这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程<br>当取到值后还要根据http cache的rfc标准  判断  是否合理能使用<br>new CacheStrategy.Factory(now, request, cacheCandidate).get();<br>在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  </p>\n<p>这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）</p>\n<pre><code>if (etag != null) {\n  conditionalRequestBuilder.header(&quot;If-None-Match&quot;, etag);\n} else if (lastModified != null) {\n  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, lastModifiedString);\n} else if (servedDate != null) {\n  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, servedDateString);\n}\n\nRequest conditionalRequest = conditionalRequestBuilder.build();\n</code></pre><p>这是请求前的工作<br>现在开始发送请求</p>\n<pre><code>httpStream = connect();\nhttpStream.setHttpEngine(this);\n</code></pre><p>这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）</p>\n<pre><code>streamAllocation.newStream(client.connectTimeoutMillis(),\nclient.readTimeoutMillis(), client.writeTimeoutMillis(),\nclient.retryOnConnectionFailure(), doExtensiveHealthChecks);\n</code></pre><p>解决的问题 是socket连接重用和  route<br>先是从连接池中找</p>\n<pre><code>// Attempt to get a connection from the pool.\n RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);\n if (pooledConnection != null) {\n   this.connection = pooledConnection;\n   return pooledConnection;\n }\n</code></pre><p>如果没有的话就看route可以重用嘛</p>\n<pre><code> if (selectedRoute == null) {\n  selectedRoute = routeSelector.next();\n  synchronized (connectionPool) {\n    route = selectedRoute;\n  }\n}\nRealConnection newConnection = new RealConnection(selectedRoute);\nacquire(newConnection);\n</code></pre><p>（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止</p>\n<pre><code>RouteDatabase里的Set&lt;Route&gt; failedRoutes = new LinkedHashSet&lt;&gt;()）\n</code></pre><p>弄完之后就是放如   </p>\n<pre><code>Internal.instance.put(connectionPool, newConnection);\n</code></pre><p>连接池中  方便下次继续使用<br>下一步 就是建立socket连接的过程</p>\n<pre><code> newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),\n    connectionRetryEnabled);\nrouteDatabase().connected(newConnection.route());\n</code></pre><p>跟进去 就是</p>\n<pre><code>connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n</code></pre><p>继续</p>\n<pre><code> try {\n  Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);\n} catch (ConnectException e) {\n  throw new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress());\n}\nsource = Okio.buffer(Okio.source(rawSocket));\nsink = Okio.buffer(Okio.sink(rawSocket));\n</code></pre><p>连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的<br>然后才是真正发送这个请求的过程</p>\n<pre><code>httpStream.writeRequestHeaders(networkRequest);\nrequestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);\n</code></pre><p>继续跟进</p>\n<pre><code> httpEngine.writingRequestHeaders();\n  String requestLine = RequestLine.get(\n    request, httpEngine.getConnection().route().proxy().type());\nwriteRequest(request.headers(), requestLine);\n</code></pre><p>》》</p>\n<pre><code>** Returns bytes of a request header for sending on an HTTP transport. */\npublic void writeRequest(Headers headers, String requestLine) throws IOException {\nif (state != STATE_IDLE) throw new IllegalStateException(&quot;state: &quot; + state);\nsink.writeUtf8(requestLine).writeUtf8(&quot;\\r\\n&quot;);\nfor (int i = 0, size = headers.size(); i &lt; size; i++) {\n  sink.writeUtf8(headers.name(i))\n      .writeUtf8(&quot;: &quot;)\n      .writeUtf8(headers.value(i))\n      .writeUtf8(&quot;\\r\\n&quot;);\n}\nsink.writeUtf8(&quot;\\r\\n&quot;);\nstate = STATE_OPEN_REQUEST_BODY;\n}\n</code></pre><p>读过程<br>就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink</p>\n<p>到此 请求reponse的工作做完了<br>现在 如果是需要真正发送网络请求就也就是问题22</p>\n<pre><code>networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);\n</code></pre><p>》》</p>\n<pre><code>engin.readResponse\n</code></pre><p>》》</p>\n<pre><code>// Write the request body to the socket.\nif (requestBodyOut != null) {\n  if (bufferedRequestBody != null) {\n    // This also closes the wrapped requestBodyOut.\n    bufferedRequestBody.close();\n  } else {\n    requestBodyOut.close();\n  }\n  if (requestBodyOut instanceof RetryableSink) {\n    httpStream.writeRequestBody((RetryableSink) requestBodyOut);\n  }\n}\n\nnetworkResponse = readNetworkResponse();\n</code></pre><p>》》</p>\n<pre><code>Response readNetworkResponse() throws IOException {\nhttpStream.finishRequest();\n\nResponse networkResponse = httpStream.readResponseHeaders()\n    .request(networkRequest)\n    .handshake(streamAllocation.connection().handshake())\n    .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))\n    .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))\n    .build();\n\nif (!forWebSocket) {\n  networkResponse = networkResponse.newBuilder()\n      .body(httpStream.openResponseBody(networkResponse))\n      .build();\n}\n\nif (&quot;close&quot;.equalsIgnoreCase(networkResponse.request().header(&quot;Connection&quot;))\n    || &quot;close&quot;.equalsIgnoreCase(networkResponse.header(&quot;Connection&quot;))) {\n  streamAllocation.noNewStreams();\n}\n\nreturn networkResponse;\n</code></pre><p>  }</p>\n<p>解析和返回</p>\n<pre><code> Response response = engine.getResponse();\n\n\n//tobe continue（已经 cache过程 请求重试过程）\n Request followUp = engine.followUpRequest();\n</code></pre><h3 id=\"3-cache管理\"><a href=\"#3-cache管理\" class=\"headerlink\" title=\"3. cache管理\"></a>3. cache管理</h3><p>最后附上 相关的http请求cache的rfc内容<br> <img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg\" alt=\"image\"></p>\n<h3 id=\"每个状态的详细说明如下：\"><a href=\"#每个状态的详细说明如下：\" class=\"headerlink\" title=\"每个状态的详细说明如下：\"></a>每个状态的详细说明如下：</h3><h4 id=\"1-Last-Modified\"><a href=\"#1-Last-Modified\" class=\"headerlink\" title=\"1. Last-Modified\"></a>1. Last-Modified</h4><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：<br>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT<br>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：<br>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT<br>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。<br>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  </p>\n<h4 id=\"2-Etag工作原理\"><a href=\"#2-Etag工作原理\" class=\"headerlink\" title=\"2. Etag工作原理\"></a>2. Etag工作原理</h4><p>HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：<br>Etag:“5d8c72a5edda8d6a:3239″<br>客户端的查询更新格式是这样的：<br>If-None-Match:“5d8c72a5edda8d6a:3239″<br>如果ETag没改变，则返回状态304。<br>即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″<br>标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。<br>If-None-Match:“5d8c72a5edda8d6a:3239“<br>,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  </p>\n<h4 id=\"3-Expires\"><a href=\"#3-Expires\" class=\"headerlink\" title=\"3. Expires\"></a>3. Expires</h4><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT<br>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  </p>\n<h4 id=\"4-Last-Modified和Expires\"><a href=\"#4-Last-Modified和Expires\" class=\"headerlink\" title=\"4. Last-Modified和Expires\"></a>4. Last-Modified和Expires</h4><p>Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  </p>\n<h4 id=\"5-Etag和Expires\"><a href=\"#5-Etag和Expires\" class=\"headerlink\" title=\"5. Etag和Expires\"></a>5. Etag和Expires</h4><p>如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  </p>\n<h4 id=\"6-Last-Modified和Etag\"><a href=\"#6-Last-Modified和Etag\" class=\"headerlink\" title=\"6. Last-Modified和Etag\"></a>6. Last-Modified和Etag</h4><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败<br>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)<br>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存<br>过程如下:  </p>\n<ul>\n<li>客户端请求一个页面（A）。  </li>\n<li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。  </li>\n<li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  </li>\n<li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  </li>\n<li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  </li>\n</ul>\n<p>备注：   </p>\n<ul>\n<li>Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  </li>\n<li>WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  </li>\n<li>客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  </li>\n<li>通过上述值到服务器端检查，判断文件是否继续缓存；  </li>\n</ul>\n<h4 id=\"7-关于-Cache-Control-max-age-秒-和-Expires\"><a href=\"#7-关于-Cache-Control-max-age-秒-和-Expires\" class=\"headerlink\" title=\"7.关于 Cache-Control: max-age=秒 和 Expires\"></a>7.关于 Cache-Control: max-age=秒 和 Expires</h4><p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。<br>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。<br>Expires =max-age +   “每次下载时的当前的request时间”<br>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   </p>\n","excerpt":"","more":"<h1 id=\"okttp-解析（okio以后再讲-So-ignore-Sink-Source）\"><a href=\"#okttp-解析（okio以后再讲-So-ignore-Sink-Source）\" class=\"headerlink\" title=\"okttp 解析（okio以后再讲  So   ignore  Sink   Source）\"></a>okttp 解析（okio以后再讲  So   ignore  Sink   Source）</h1><h2 id=\"Interface：OkhttpClient（singleton）-Request-Response\"><a href=\"#Interface：OkhttpClient（singleton）-Request-Response\" class=\"headerlink\" title=\"Interface：OkhttpClient（singleton）  Request  Response\"></a>Interface：OkhttpClient（singleton）  Request  Response</h2><h2 id=\"主要由以下三部分-组成\"><a href=\"#主要由以下三部分-组成\" class=\"headerlink\" title=\"主要由以下三部分 组成\"></a>主要由以下三部分 组成</h2><h3 id=\"1-任务调度：-核心类disruptor（singleton）\"><a href=\"#1-任务调度：-核心类disruptor（singleton）\" class=\"headerlink\" title=\"1. 任务调度： 核心类disruptor（singleton）\"></a>1. 任务调度： 核心类disruptor（singleton）</h3><p>a. 线程池<br>b. 队列</p>\n<pre><code>/** Ready async calls in the order they&apos;ll be run. */\nprivate final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */\n private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();\n</code></pre><p>(由于okhttp两种 运行模式   sync  和async）</p>\n<h3 id=\"2-网络请求\"><a href=\"#2-网络请求\" class=\"headerlink\" title=\"2. 网络请求\"></a>2. 网络请求</h3><ul>\n<li>核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） </li>\n<li>每个请求会生成一个Request  </li>\n<li>然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  </li>\n</ul>\n<p>okhttp一个请求的完整流程图<br> <img src=\"http://blog.piasy.com/img/201607/okhttp_full_process.png\" alt=\"image\"></p>\n<p>在realcall的execute方法中会调用     </p>\n<pre><code>client.dispatcher().executed(this);//问题1  \nResponse result = getResponseWithInterceptorChain(false);//问题2  \n</code></pre><p>获得请求结果.<br>现在看问题1  在这里面干了写什么<br>其实就是 dispatcher记录任务而已 ，没有任何执行方法<br>核心在问题2中<br>她会  </p>\n<pre><code>Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\nreturn chain.proceed(originalRequest);\n</code></pre><p>也就是生成拦截器 ，并用这个拦截器启动这个请求<br>继续进入proceed 可以看到<br>进入了ApplicationInterceptorChain的getresponse方法<br>开始构造HttpEngine    </p>\n<pre><code>engine.sendRequest();//问题21\nengine.readResponse();//问题22\n</code></pre><p>在问题21中其实就是  Rfc 标准的一种 实现  </p>\n<pre><code>InternalCache responseCache = Internal.instance.internalCache(client);\nResponse cacheCandidate = responseCache != null\n    ? responseCache.get(request)\n    : null;\n</code></pre><p>就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache<br>这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程<br>当取到值后还要根据http cache的rfc标准  判断  是否合理能使用<br>new CacheStrategy.Factory(now, request, cacheCandidate).get();<br>在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  </p>\n<p>这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）</p>\n<pre><code>if (etag != null) {\n  conditionalRequestBuilder.header(&quot;If-None-Match&quot;, etag);\n} else if (lastModified != null) {\n  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, lastModifiedString);\n} else if (servedDate != null) {\n  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, servedDateString);\n}\n\nRequest conditionalRequest = conditionalRequestBuilder.build();\n</code></pre><p>这是请求前的工作<br>现在开始发送请求</p>\n<pre><code>httpStream = connect();\nhttpStream.setHttpEngine(this);\n</code></pre><p>这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）</p>\n<pre><code>streamAllocation.newStream(client.connectTimeoutMillis(),\nclient.readTimeoutMillis(), client.writeTimeoutMillis(),\nclient.retryOnConnectionFailure(), doExtensiveHealthChecks);\n</code></pre><p>解决的问题 是socket连接重用和  route<br>先是从连接池中找</p>\n<pre><code>// Attempt to get a connection from the pool.\n RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);\n if (pooledConnection != null) {\n   this.connection = pooledConnection;\n   return pooledConnection;\n }\n</code></pre><p>如果没有的话就看route可以重用嘛</p>\n<pre><code> if (selectedRoute == null) {\n  selectedRoute = routeSelector.next();\n  synchronized (connectionPool) {\n    route = selectedRoute;\n  }\n}\nRealConnection newConnection = new RealConnection(selectedRoute);\nacquire(newConnection);\n</code></pre><p>（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止</p>\n<pre><code>RouteDatabase里的Set&lt;Route&gt; failedRoutes = new LinkedHashSet&lt;&gt;()）\n</code></pre><p>弄完之后就是放如   </p>\n<pre><code>Internal.instance.put(connectionPool, newConnection);\n</code></pre><p>连接池中  方便下次继续使用<br>下一步 就是建立socket连接的过程</p>\n<pre><code> newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),\n    connectionRetryEnabled);\nrouteDatabase().connected(newConnection.route());\n</code></pre><p>跟进去 就是</p>\n<pre><code>connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n</code></pre><p>继续</p>\n<pre><code> try {\n  Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);\n} catch (ConnectException e) {\n  throw new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress());\n}\nsource = Okio.buffer(Okio.source(rawSocket));\nsink = Okio.buffer(Okio.sink(rawSocket));\n</code></pre><p>连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的<br>然后才是真正发送这个请求的过程</p>\n<pre><code>httpStream.writeRequestHeaders(networkRequest);\nrequestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);\n</code></pre><p>继续跟进</p>\n<pre><code> httpEngine.writingRequestHeaders();\n  String requestLine = RequestLine.get(\n    request, httpEngine.getConnection().route().proxy().type());\nwriteRequest(request.headers(), requestLine);\n</code></pre><p>》》</p>\n<pre><code>** Returns bytes of a request header for sending on an HTTP transport. */\npublic void writeRequest(Headers headers, String requestLine) throws IOException {\nif (state != STATE_IDLE) throw new IllegalStateException(&quot;state: &quot; + state);\nsink.writeUtf8(requestLine).writeUtf8(&quot;\\r\\n&quot;);\nfor (int i = 0, size = headers.size(); i &lt; size; i++) {\n  sink.writeUtf8(headers.name(i))\n      .writeUtf8(&quot;: &quot;)\n      .writeUtf8(headers.value(i))\n      .writeUtf8(&quot;\\r\\n&quot;);\n}\nsink.writeUtf8(&quot;\\r\\n&quot;);\nstate = STATE_OPEN_REQUEST_BODY;\n}\n</code></pre><p>读过程<br>就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink</p>\n<p>到此 请求reponse的工作做完了<br>现在 如果是需要真正发送网络请求就也就是问题22</p>\n<pre><code>networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);\n</code></pre><p>》》</p>\n<pre><code>engin.readResponse\n</code></pre><p>》》</p>\n<pre><code>// Write the request body to the socket.\nif (requestBodyOut != null) {\n  if (bufferedRequestBody != null) {\n    // This also closes the wrapped requestBodyOut.\n    bufferedRequestBody.close();\n  } else {\n    requestBodyOut.close();\n  }\n  if (requestBodyOut instanceof RetryableSink) {\n    httpStream.writeRequestBody((RetryableSink) requestBodyOut);\n  }\n}\n\nnetworkResponse = readNetworkResponse();\n</code></pre><p>》》</p>\n<pre><code>Response readNetworkResponse() throws IOException {\nhttpStream.finishRequest();\n\nResponse networkResponse = httpStream.readResponseHeaders()\n    .request(networkRequest)\n    .handshake(streamAllocation.connection().handshake())\n    .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))\n    .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))\n    .build();\n\nif (!forWebSocket) {\n  networkResponse = networkResponse.newBuilder()\n      .body(httpStream.openResponseBody(networkResponse))\n      .build();\n}\n\nif (&quot;close&quot;.equalsIgnoreCase(networkResponse.request().header(&quot;Connection&quot;))\n    || &quot;close&quot;.equalsIgnoreCase(networkResponse.header(&quot;Connection&quot;))) {\n  streamAllocation.noNewStreams();\n}\n\nreturn networkResponse;\n</code></pre><p>  }</p>\n<p>解析和返回</p>\n<pre><code> Response response = engine.getResponse();\n\n\n//tobe continue（已经 cache过程 请求重试过程）\n Request followUp = engine.followUpRequest();\n</code></pre><h3 id=\"3-cache管理\"><a href=\"#3-cache管理\" class=\"headerlink\" title=\"3. cache管理\"></a>3. cache管理</h3><p>最后附上 相关的http请求cache的rfc内容<br> <img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg\" alt=\"image\"></p>\n<h3 id=\"每个状态的详细说明如下：\"><a href=\"#每个状态的详细说明如下：\" class=\"headerlink\" title=\"每个状态的详细说明如下：\"></a>每个状态的详细说明如下：</h3><h4 id=\"1-Last-Modified\"><a href=\"#1-Last-Modified\" class=\"headerlink\" title=\"1. Last-Modified\"></a>1. Last-Modified</h4><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：<br>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT<br>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：<br>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT<br>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。<br>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  </p>\n<h4 id=\"2-Etag工作原理\"><a href=\"#2-Etag工作原理\" class=\"headerlink\" title=\"2. Etag工作原理\"></a>2. Etag工作原理</h4><p>HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：<br>Etag:“5d8c72a5edda8d6a:3239″<br>客户端的查询更新格式是这样的：<br>If-None-Match:“5d8c72a5edda8d6a:3239″<br>如果ETag没改变，则返回状态304。<br>即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″<br>标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。<br>If-None-Match:“5d8c72a5edda8d6a:3239“<br>,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  </p>\n<h4 id=\"3-Expires\"><a href=\"#3-Expires\" class=\"headerlink\" title=\"3. Expires\"></a>3. Expires</h4><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT<br>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  </p>\n<h4 id=\"4-Last-Modified和Expires\"><a href=\"#4-Last-Modified和Expires\" class=\"headerlink\" title=\"4. Last-Modified和Expires\"></a>4. Last-Modified和Expires</h4><p>Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  </p>\n<h4 id=\"5-Etag和Expires\"><a href=\"#5-Etag和Expires\" class=\"headerlink\" title=\"5. Etag和Expires\"></a>5. Etag和Expires</h4><p>如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  </p>\n<h4 id=\"6-Last-Modified和Etag\"><a href=\"#6-Last-Modified和Etag\" class=\"headerlink\" title=\"6. Last-Modified和Etag\"></a>6. Last-Modified和Etag</h4><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败<br>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)<br>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存<br>过程如下:  </p>\n<ul>\n<li>客户端请求一个页面（A）。  </li>\n<li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。  </li>\n<li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  </li>\n<li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  </li>\n<li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  </li>\n</ul>\n<p>备注：   </p>\n<ul>\n<li>Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  </li>\n<li>WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  </li>\n<li>客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  </li>\n<li>通过上述值到服务器端检查，判断文件是否继续缓存；  </li>\n</ul>\n<h4 id=\"7-关于-Cache-Control-max-age-秒-和-Expires\"><a href=\"#7-关于-Cache-Control-max-age-秒-和-Expires\" class=\"headerlink\" title=\"7.关于 Cache-Control: max-age=秒 和 Expires\"></a>7.关于 Cache-Control: max-age=秒 和 Expires</h4><p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。<br>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。<br>Expires =max-age +   “每次下载时的当前的request时间”<br>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   </p>\n"},{"title":"快速打包方案","date":"2015-11-01T12:10:33.000Z","_content":"\n# 往apk文件里面动态添加信息的两种方法。 \n（都需要保留安装时候的apk文件）\n\n1. 方案一：往meta_info里面添加文件,写入参数信息\n2. 方案二：在apk这个文件的comment信息里面添加需要传入的信息  \n\n\n\n## 方案一：  \n参考：http://tech.meituan.com/mt-apk-packaging.html   \n主要代表：美团  \n原理：meta_info（里面存的就是签名信息）里面的文件不参与签名，修改后，apk不需要签名 \n\n## 方案二：  \n参考：http://blog.csdn.net/kongpinde/article/details/51518466  \n主要代表：天猫、豌豆荚   \n原理：apk就是一个zip压缩包。而zip包有个comment区域，可以往里面写入信息，而不对apk的安装产生影响   \nzip 文件的末尾有一个 Central Directory Record 区域，其末尾包含一个 File comment 区域，可以存放一些数据，所以 File comment 是 zip 文件一部分，如果可以正确的修改这个部分，就可以在不破坏压缩包、不用重新打包的的前提下快速的给 Apk 文件写入自己想要的数据。\n\ncomment 是在 Central Directory Record 末尾储存的，可以将数据直接写在这里，下表是 header 末尾的结构。\n ![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment.png)\n从表中可以看到定义 comment 长度的字段位于 comment 之前。\n\n这里我们需要自定义 comment，在自定义 comment 内容的后面添加一个区域储存 comment 的长度，结构如下图。\n![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment_structure.png)\n\n### Server动态生成apk \n这一部分可以在本地或服务端进行，需要定义一个长度为 2 的 byte[] 来储存 comment 的长度，直接使用 Java 的 api 就可以把 comment 和 comment 的长度写到 Apk 的末尾，代码如下：\n\n    \tpublic static void writeApk(File file, String comment) {\n    \t\tZipFile zipFile = null;\n    \t\tByteArrayOutputStream outputStream = null;\n    \t\tRandomAccessFile accessFile = null;\n    \t\ttry {\n    \t\t\tzipFile = new ZipFile(file);\n    \t\t\tString zipComment = zipFile.getComment();\n    \t\t\t// 判断comment区域是否已经有数据了\n    \t\t\tif (zipComment != null)\n    \t\t\t\treturn;\n    \t\t\tbyte[] byteComment = comment.getBytes();\n    \t\t\toutputStream = new ByteArrayOutputStream();\n    \t\t\t// 将数据写入输出流\n    \t\t\toutputStream.write(byteComment);\n    \t\t\t// 紧接着写入数据大小\n    \t\t\toutputStream.write(short2Stream((short) byteComment.length));\n        \t\t\tbyte[] data = outputStream.toByteArray();\n    \t\t\taccessFile = new RandomAccessFile(file, \"rw\");\n    \t\t\t// 跳到comment区域\n    \t\t\taccessFile.seek(file.length() - 2);\n    \t\t\t// 先写入数据大小\n    \t\t\taccessFile.write(short2Stream((short) data.length));\n    \t\t\t// 写入数据\n    \t\t\taccessFile.write(data);\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t} finally {\n    \t\t\ttry {\n    \t\t\t\tif (zipFile != null)\n    \t\t\t\t\tzipFile.close();\n    \t\t\t\tif (outputStream != null)\n    \t\t\t\t\toutputStream.close();\n    \t\t\t\tif (accessFile != null)\n    \t\t\t\t\taccessFile.close();\n    \t\t\t} catch (Exception e) {\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t}\n    \tprivate static byte[] short2Stream(short data) {\n    \t\tByteBuffer buffer = ByteBuffer.allocate(2);\n    \t\tbuffer.order(ByteOrder.LITTLE_ENDIAN);\n    \t\tbuffer.putShort(data);\n    \t\tbuffer.flip();\n    \t\treturn buffer.array();\n    \t}\n\n\n\n### 客户端解析apk数据：\n\n\n        private static String readApk(Context context) {\n    \t\t// 获取文件路径\n    \t\tFile file = new File(context.getPackageCodePath());\n    \t\tbyte[] bytes = null;\n    \t\tRandomAccessFile accessFile = null;\n    \t\ttry {\n    \t\t\taccessFile = new RandomAccessFile(file, \"r\");\n    \t\t\tlong index = accessFile.length();\n    \t\t\tbytes = new byte[2];\n    \t\t\t// 获取comment文件的位置\n    \t\t\tindex = index - bytes.length;\n    \t\t\taccessFile.seek(index);\n    \t\t\t// 获取comment中写入数据的大小byte类型\n    \t\t\taccessFile.readFully(bytes);\n    \t\t\t// 将byte转换成大小\n    \t\t\tint contentLength = stream2Short(bytes, 0);\n    \t\t\t// 创建byte[]数据大小来存储写入的数据\n    \t\t\tbytes = new byte[contentLength];\n    \t\t\tindex = index - bytes.length;\n    \t\t\taccessFile.seek(index);\n    \t\t\t// 读取数据\n    \t\t\taccessFile.readFully(bytes);\n    \t\t\treturn new String(bytes, \"utf-8\");\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t} finally {\n    \t\t\tif (accessFile != null) {\n    \t\t\t\ttry {\n    \t\t\t\t\taccessFile.close();\n    \t\t\t\t} catch (IOException e) {\n    \t\t\t\t\te.printStackTrace();\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn null;\n    \t}\n    \n\n    \tprivate static short stream2Short(byte[] stream, int offset) {\n    \t\tByteBuffer buffer = ByteBuffer.allocate(2);\n    \t\tbuffer.order(ByteOrder.LITTLE_ENDIAN);\n    \t\tbuffer.put(stream[offset]);\n    \t\tbuffer.put(stream[offset + 1]);\n    \t\treturn buffer.getShort(0);\n    \t}\n\n# apk的安装过程\n1. 复制APK安装包到data/app目录下（所以安装完成后，即使把sd卡中的apk删除也没关系）;\n2. 解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录;\n3. 并data/data目录下创建对应的应用数据目录。\n\n\n## 应用安装涉及到如下几个目录：        \n\nsystem/app ---------------系统自带的应用程序，获得adb root权限才能删除\n\ndata/app  ---------------用户程序安装的目录。安装时把                                                                                                      apk文件复制到此目录\ndata/data ---------------存放应用程序的数据\ndata/dalvik-cache--------将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)\n\n\n\n## app卸载\n\n删除安装过程中在上述三个目录下创建的文件及目录。\n\n\n\n","source":"_posts/动态往apk写入信息.md","raw":"title: 快速打包方案\ndate: 2015-11-01 20:10:33\ncategories:\n- Android快速打包\ntags:\n- 打包\n- Android\n---\n\n# 往apk文件里面动态添加信息的两种方法。 \n（都需要保留安装时候的apk文件）\n\n1. 方案一：往meta_info里面添加文件,写入参数信息\n2. 方案二：在apk这个文件的comment信息里面添加需要传入的信息  \n\n\n\n## 方案一：  \n参考：http://tech.meituan.com/mt-apk-packaging.html   \n主要代表：美团  \n原理：meta_info（里面存的就是签名信息）里面的文件不参与签名，修改后，apk不需要签名 \n\n## 方案二：  \n参考：http://blog.csdn.net/kongpinde/article/details/51518466  \n主要代表：天猫、豌豆荚   \n原理：apk就是一个zip压缩包。而zip包有个comment区域，可以往里面写入信息，而不对apk的安装产生影响   \nzip 文件的末尾有一个 Central Directory Record 区域，其末尾包含一个 File comment 区域，可以存放一些数据，所以 File comment 是 zip 文件一部分，如果可以正确的修改这个部分，就可以在不破坏压缩包、不用重新打包的的前提下快速的给 Apk 文件写入自己想要的数据。\n\ncomment 是在 Central Directory Record 末尾储存的，可以将数据直接写在这里，下表是 header 末尾的结构。\n ![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment.png)\n从表中可以看到定义 comment 长度的字段位于 comment 之前。\n\n这里我们需要自定义 comment，在自定义 comment 内容的后面添加一个区域储存 comment 的长度，结构如下图。\n![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment_structure.png)\n\n### Server动态生成apk \n这一部分可以在本地或服务端进行，需要定义一个长度为 2 的 byte[] 来储存 comment 的长度，直接使用 Java 的 api 就可以把 comment 和 comment 的长度写到 Apk 的末尾，代码如下：\n\n    \tpublic static void writeApk(File file, String comment) {\n    \t\tZipFile zipFile = null;\n    \t\tByteArrayOutputStream outputStream = null;\n    \t\tRandomAccessFile accessFile = null;\n    \t\ttry {\n    \t\t\tzipFile = new ZipFile(file);\n    \t\t\tString zipComment = zipFile.getComment();\n    \t\t\t// 判断comment区域是否已经有数据了\n    \t\t\tif (zipComment != null)\n    \t\t\t\treturn;\n    \t\t\tbyte[] byteComment = comment.getBytes();\n    \t\t\toutputStream = new ByteArrayOutputStream();\n    \t\t\t// 将数据写入输出流\n    \t\t\toutputStream.write(byteComment);\n    \t\t\t// 紧接着写入数据大小\n    \t\t\toutputStream.write(short2Stream((short) byteComment.length));\n        \t\t\tbyte[] data = outputStream.toByteArray();\n    \t\t\taccessFile = new RandomAccessFile(file, \"rw\");\n    \t\t\t// 跳到comment区域\n    \t\t\taccessFile.seek(file.length() - 2);\n    \t\t\t// 先写入数据大小\n    \t\t\taccessFile.write(short2Stream((short) data.length));\n    \t\t\t// 写入数据\n    \t\t\taccessFile.write(data);\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t} finally {\n    \t\t\ttry {\n    \t\t\t\tif (zipFile != null)\n    \t\t\t\t\tzipFile.close();\n    \t\t\t\tif (outputStream != null)\n    \t\t\t\t\toutputStream.close();\n    \t\t\t\tif (accessFile != null)\n    \t\t\t\t\taccessFile.close();\n    \t\t\t} catch (Exception e) {\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t}\n    \tprivate static byte[] short2Stream(short data) {\n    \t\tByteBuffer buffer = ByteBuffer.allocate(2);\n    \t\tbuffer.order(ByteOrder.LITTLE_ENDIAN);\n    \t\tbuffer.putShort(data);\n    \t\tbuffer.flip();\n    \t\treturn buffer.array();\n    \t}\n\n\n\n### 客户端解析apk数据：\n\n\n        private static String readApk(Context context) {\n    \t\t// 获取文件路径\n    \t\tFile file = new File(context.getPackageCodePath());\n    \t\tbyte[] bytes = null;\n    \t\tRandomAccessFile accessFile = null;\n    \t\ttry {\n    \t\t\taccessFile = new RandomAccessFile(file, \"r\");\n    \t\t\tlong index = accessFile.length();\n    \t\t\tbytes = new byte[2];\n    \t\t\t// 获取comment文件的位置\n    \t\t\tindex = index - bytes.length;\n    \t\t\taccessFile.seek(index);\n    \t\t\t// 获取comment中写入数据的大小byte类型\n    \t\t\taccessFile.readFully(bytes);\n    \t\t\t// 将byte转换成大小\n    \t\t\tint contentLength = stream2Short(bytes, 0);\n    \t\t\t// 创建byte[]数据大小来存储写入的数据\n    \t\t\tbytes = new byte[contentLength];\n    \t\t\tindex = index - bytes.length;\n    \t\t\taccessFile.seek(index);\n    \t\t\t// 读取数据\n    \t\t\taccessFile.readFully(bytes);\n    \t\t\treturn new String(bytes, \"utf-8\");\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t} finally {\n    \t\t\tif (accessFile != null) {\n    \t\t\t\ttry {\n    \t\t\t\t\taccessFile.close();\n    \t\t\t\t} catch (IOException e) {\n    \t\t\t\t\te.printStackTrace();\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn null;\n    \t}\n    \n\n    \tprivate static short stream2Short(byte[] stream, int offset) {\n    \t\tByteBuffer buffer = ByteBuffer.allocate(2);\n    \t\tbuffer.order(ByteOrder.LITTLE_ENDIAN);\n    \t\tbuffer.put(stream[offset]);\n    \t\tbuffer.put(stream[offset + 1]);\n    \t\treturn buffer.getShort(0);\n    \t}\n\n# apk的安装过程\n1. 复制APK安装包到data/app目录下（所以安装完成后，即使把sd卡中的apk删除也没关系）;\n2. 解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录;\n3. 并data/data目录下创建对应的应用数据目录。\n\n\n## 应用安装涉及到如下几个目录：        \n\nsystem/app ---------------系统自带的应用程序，获得adb root权限才能删除\n\ndata/app  ---------------用户程序安装的目录。安装时把                                                                                                      apk文件复制到此目录\ndata/data ---------------存放应用程序的数据\ndata/dalvik-cache--------将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)\n\n\n\n## app卸载\n\n删除安装过程中在上述三个目录下创建的文件及目录。\n\n\n\n","slug":"动态往apk写入信息","published":1,"updated":"2017-03-17T05:00:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7cd000u1rjjp3qb5tx8","content":"<h1 id=\"往apk文件里面动态添加信息的两种方法。\"><a href=\"#往apk文件里面动态添加信息的两种方法。\" class=\"headerlink\" title=\"往apk文件里面动态添加信息的两种方法。\"></a>往apk文件里面动态添加信息的两种方法。</h1><p>（都需要保留安装时候的apk文件）</p>\n<ol>\n<li>方案一：往meta_info里面添加文件,写入参数信息</li>\n<li>方案二：在apk这个文件的comment信息里面添加需要传入的信息  </li>\n</ol>\n<h2 id=\"方案一：\"><a href=\"#方案一：\" class=\"headerlink\" title=\"方案一：\"></a>方案一：</h2><p>参考：<a href=\"http://tech.meituan.com/mt-apk-packaging.html\" target=\"_blank\" rel=\"external\">http://tech.meituan.com/mt-apk-packaging.html</a><br>主要代表：美团<br>原理：meta_info（里面存的就是签名信息）里面的文件不参与签名，修改后，apk不需要签名 </p>\n<h2 id=\"方案二：\"><a href=\"#方案二：\" class=\"headerlink\" title=\"方案二：\"></a>方案二：</h2><p>参考：<a href=\"http://blog.csdn.net/kongpinde/article/details/51518466\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/kongpinde/article/details/51518466</a><br>主要代表：天猫、豌豆荚<br>原理：apk就是一个zip压缩包。而zip包有个comment区域，可以往里面写入信息，而不对apk的安装产生影响<br>zip 文件的末尾有一个 Central Directory Record 区域，其末尾包含一个 File comment 区域，可以存放一些数据，所以 File comment 是 zip 文件一部分，如果可以正确的修改这个部分，就可以在不破坏压缩包、不用重新打包的的前提下快速的给 Apk 文件写入自己想要的数据。</p>\n<p>comment 是在 Central Directory Record 末尾储存的，可以将数据直接写在这里，下表是 header 末尾的结构。<br> <img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment.png\" alt=\"image\"><br>从表中可以看到定义 comment 长度的字段位于 comment 之前。</p>\n<p>这里我们需要自定义 comment，在自定义 comment 内容的后面添加一个区域储存 comment 的长度，结构如下图。<br><img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment_structure.png\" alt=\"image\"></p>\n<h3 id=\"Server动态生成apk\"><a href=\"#Server动态生成apk\" class=\"headerlink\" title=\"Server动态生成apk\"></a>Server动态生成apk</h3><p>这一部分可以在本地或服务端进行，需要定义一个长度为 2 的 byte[] 来储存 comment 的长度，直接使用 Java 的 api 就可以把 comment 和 comment 的长度写到 Apk 的末尾，代码如下：</p>\n<pre><code>public static void writeApk(File file, String comment) {\n    ZipFile zipFile = null;\n    ByteArrayOutputStream outputStream = null;\n    RandomAccessFile accessFile = null;\n    try {\n        zipFile = new ZipFile(file);\n        String zipComment = zipFile.getComment();\n        // 判断comment区域是否已经有数据了\n        if (zipComment != null)\n            return;\n        byte[] byteComment = comment.getBytes();\n        outputStream = new ByteArrayOutputStream();\n        // 将数据写入输出流\n        outputStream.write(byteComment);\n        // 紧接着写入数据大小\n        outputStream.write(short2Stream((short) byteComment.length));\n            byte[] data = outputStream.toByteArray();\n        accessFile = new RandomAccessFile(file, &quot;rw&quot;);\n        // 跳到comment区域\n        accessFile.seek(file.length() - 2);\n        // 先写入数据大小\n        accessFile.write(short2Stream((short) data.length));\n        // 写入数据\n        accessFile.write(data);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if (zipFile != null)\n                zipFile.close();\n            if (outputStream != null)\n                outputStream.close();\n            if (accessFile != null)\n                accessFile.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\nprivate static byte[] short2Stream(short data) {\n    ByteBuffer buffer = ByteBuffer.allocate(2);\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n    buffer.putShort(data);\n    buffer.flip();\n    return buffer.array();\n}\n</code></pre><h3 id=\"客户端解析apk数据：\"><a href=\"#客户端解析apk数据：\" class=\"headerlink\" title=\"客户端解析apk数据：\"></a>客户端解析apk数据：</h3><pre><code>private static String readApk(Context context) {\n    // 获取文件路径\n    File file = new File(context.getPackageCodePath());\n    byte[] bytes = null;\n    RandomAccessFile accessFile = null;\n    try {\n        accessFile = new RandomAccessFile(file, &quot;r&quot;);\n        long index = accessFile.length();\n        bytes = new byte[2];\n        // 获取comment文件的位置\n        index = index - bytes.length;\n        accessFile.seek(index);\n        // 获取comment中写入数据的大小byte类型\n        accessFile.readFully(bytes);\n        // 将byte转换成大小\n        int contentLength = stream2Short(bytes, 0);\n        // 创建byte[]数据大小来存储写入的数据\n        bytes = new byte[contentLength];\n        index = index - bytes.length;\n        accessFile.seek(index);\n        // 读取数据\n        accessFile.readFully(bytes);\n        return new String(bytes, &quot;utf-8&quot;);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (accessFile != null) {\n            try {\n                accessFile.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}\n\n\nprivate static short stream2Short(byte[] stream, int offset) {\n    ByteBuffer buffer = ByteBuffer.allocate(2);\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n    buffer.put(stream[offset]);\n    buffer.put(stream[offset + 1]);\n    return buffer.getShort(0);\n}\n</code></pre><h1 id=\"apk的安装过程\"><a href=\"#apk的安装过程\" class=\"headerlink\" title=\"apk的安装过程\"></a>apk的安装过程</h1><ol>\n<li>复制APK安装包到data/app目录下（所以安装完成后，即使把sd卡中的apk删除也没关系）;</li>\n<li>解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录;</li>\n<li>并data/data目录下创建对应的应用数据目录。</li>\n</ol>\n<h2 id=\"应用安装涉及到如下几个目录：\"><a href=\"#应用安装涉及到如下几个目录：\" class=\"headerlink\" title=\"应用安装涉及到如下几个目录：\"></a>应用安装涉及到如下几个目录：</h2><p>system/app —————系统自带的应用程序，获得adb root权限才能删除</p>\n<p>data/app  —————用户程序安装的目录。安装时把                                                                                                      apk文件复制到此目录<br>data/data —————存放应用程序的数据<br>data/dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)</p>\n<h2 id=\"app卸载\"><a href=\"#app卸载\" class=\"headerlink\" title=\"app卸载\"></a>app卸载</h2><p>删除安装过程中在上述三个目录下创建的文件及目录。</p>\n","excerpt":"","more":"<h1 id=\"往apk文件里面动态添加信息的两种方法。\"><a href=\"#往apk文件里面动态添加信息的两种方法。\" class=\"headerlink\" title=\"往apk文件里面动态添加信息的两种方法。\"></a>往apk文件里面动态添加信息的两种方法。</h1><p>（都需要保留安装时候的apk文件）</p>\n<ol>\n<li>方案一：往meta_info里面添加文件,写入参数信息</li>\n<li>方案二：在apk这个文件的comment信息里面添加需要传入的信息  </li>\n</ol>\n<h2 id=\"方案一：\"><a href=\"#方案一：\" class=\"headerlink\" title=\"方案一：\"></a>方案一：</h2><p>参考：<a href=\"http://tech.meituan.com/mt-apk-packaging.html\">http://tech.meituan.com/mt-apk-packaging.html</a><br>主要代表：美团<br>原理：meta_info（里面存的就是签名信息）里面的文件不参与签名，修改后，apk不需要签名 </p>\n<h2 id=\"方案二：\"><a href=\"#方案二：\" class=\"headerlink\" title=\"方案二：\"></a>方案二：</h2><p>参考：<a href=\"http://blog.csdn.net/kongpinde/article/details/51518466\">http://blog.csdn.net/kongpinde/article/details/51518466</a><br>主要代表：天猫、豌豆荚<br>原理：apk就是一个zip压缩包。而zip包有个comment区域，可以往里面写入信息，而不对apk的安装产生影响<br>zip 文件的末尾有一个 Central Directory Record 区域，其末尾包含一个 File comment 区域，可以存放一些数据，所以 File comment 是 zip 文件一部分，如果可以正确的修改这个部分，就可以在不破坏压缩包、不用重新打包的的前提下快速的给 Apk 文件写入自己想要的数据。</p>\n<p>comment 是在 Central Directory Record 末尾储存的，可以将数据直接写在这里，下表是 header 末尾的结构。<br> <img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment.png\" alt=\"image\"><br>从表中可以看到定义 comment 长度的字段位于 comment 之前。</p>\n<p>这里我们需要自定义 comment，在自定义 comment 内容的后面添加一个区域储存 comment 的长度，结构如下图。<br><img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment_structure.png\" alt=\"image\"></p>\n<h3 id=\"Server动态生成apk\"><a href=\"#Server动态生成apk\" class=\"headerlink\" title=\"Server动态生成apk\"></a>Server动态生成apk</h3><p>这一部分可以在本地或服务端进行，需要定义一个长度为 2 的 byte[] 来储存 comment 的长度，直接使用 Java 的 api 就可以把 comment 和 comment 的长度写到 Apk 的末尾，代码如下：</p>\n<pre><code>public static void writeApk(File file, String comment) {\n    ZipFile zipFile = null;\n    ByteArrayOutputStream outputStream = null;\n    RandomAccessFile accessFile = null;\n    try {\n        zipFile = new ZipFile(file);\n        String zipComment = zipFile.getComment();\n        // 判断comment区域是否已经有数据了\n        if (zipComment != null)\n            return;\n        byte[] byteComment = comment.getBytes();\n        outputStream = new ByteArrayOutputStream();\n        // 将数据写入输出流\n        outputStream.write(byteComment);\n        // 紧接着写入数据大小\n        outputStream.write(short2Stream((short) byteComment.length));\n            byte[] data = outputStream.toByteArray();\n        accessFile = new RandomAccessFile(file, &quot;rw&quot;);\n        // 跳到comment区域\n        accessFile.seek(file.length() - 2);\n        // 先写入数据大小\n        accessFile.write(short2Stream((short) data.length));\n        // 写入数据\n        accessFile.write(data);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if (zipFile != null)\n                zipFile.close();\n            if (outputStream != null)\n                outputStream.close();\n            if (accessFile != null)\n                accessFile.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\nprivate static byte[] short2Stream(short data) {\n    ByteBuffer buffer = ByteBuffer.allocate(2);\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n    buffer.putShort(data);\n    buffer.flip();\n    return buffer.array();\n}\n</code></pre><h3 id=\"客户端解析apk数据：\"><a href=\"#客户端解析apk数据：\" class=\"headerlink\" title=\"客户端解析apk数据：\"></a>客户端解析apk数据：</h3><pre><code>private static String readApk(Context context) {\n    // 获取文件路径\n    File file = new File(context.getPackageCodePath());\n    byte[] bytes = null;\n    RandomAccessFile accessFile = null;\n    try {\n        accessFile = new RandomAccessFile(file, &quot;r&quot;);\n        long index = accessFile.length();\n        bytes = new byte[2];\n        // 获取comment文件的位置\n        index = index - bytes.length;\n        accessFile.seek(index);\n        // 获取comment中写入数据的大小byte类型\n        accessFile.readFully(bytes);\n        // 将byte转换成大小\n        int contentLength = stream2Short(bytes, 0);\n        // 创建byte[]数据大小来存储写入的数据\n        bytes = new byte[contentLength];\n        index = index - bytes.length;\n        accessFile.seek(index);\n        // 读取数据\n        accessFile.readFully(bytes);\n        return new String(bytes, &quot;utf-8&quot;);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (accessFile != null) {\n            try {\n                accessFile.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}\n\n\nprivate static short stream2Short(byte[] stream, int offset) {\n    ByteBuffer buffer = ByteBuffer.allocate(2);\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n    buffer.put(stream[offset]);\n    buffer.put(stream[offset + 1]);\n    return buffer.getShort(0);\n}\n</code></pre><h1 id=\"apk的安装过程\"><a href=\"#apk的安装过程\" class=\"headerlink\" title=\"apk的安装过程\"></a>apk的安装过程</h1><ol>\n<li>复制APK安装包到data/app目录下（所以安装完成后，即使把sd卡中的apk删除也没关系）;</li>\n<li>解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录;</li>\n<li>并data/data目录下创建对应的应用数据目录。</li>\n</ol>\n<h2 id=\"应用安装涉及到如下几个目录：\"><a href=\"#应用安装涉及到如下几个目录：\" class=\"headerlink\" title=\"应用安装涉及到如下几个目录：\"></a>应用安装涉及到如下几个目录：</h2><p>system/app —————系统自带的应用程序，获得adb root权限才能删除</p>\n<p>data/app  —————用户程序安装的目录。安装时把                                                                                                      apk文件复制到此目录<br>data/data —————存放应用程序的数据<br>data/dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)</p>\n<h2 id=\"app卸载\"><a href=\"#app卸载\" class=\"headerlink\" title=\"app卸载\"></a>app卸载</h2><p>删除安装过程中在上述三个目录下创建的文件及目录。</p>\n"},{"title":"Android 性能检测与优化","date":"2015-11-01T12:10:33.000Z","_content":"\n\n\n# 手机端：\n\n## 开发者选项\n1. 绘图》 显示布局边界\n\n2. 硬件加速渲染 》调试GPU过渡绘制  要打开\n\n\n3. 监控》启用严格模式\n\t \n4. GPU呈现模式分析  可以对照颜色表找出耗时出在那一部分\n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/GPU%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F.jpg?raw=true)\n \n# 电脑端：\n1. 查看MemoryMonitor  ，查看页面内存波动（对于listview ）\n\n2. tools》android》android  device  monistor\n（其实它就是把android sdk中tools下面的很多功能聚合起来；  如ddms，uiautomatorviewer，monitor等功能聚合起来，但是好像没有集成hierarchyviewer的功能）\n\n3. 查看录制页面变化时候的cpu耗时   \n  开始录制》选中进程，点击红色方框左边的按钮，然后点击红色方框里右侧的按钮录制正式开始，需要结束时，再点击右侧按钮结束，就会有结果自动生成  \n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6.png?raw=true)\n  \n  分析结果》录制实际上是一个采样的过程，可以看图中红色方框里面最耗时的几个方法，基本上可以定位到程序的问题   \n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6_2.png?raw=true)\n4. 查看布局层次，以及每一层的绘制时间，目的是减小层次  \n入口是在：tools 下面 hierarchyviewer  查看每个层次的绘制时间（这个好像必须在模拟器上看）\n\n\n# 分析卡的原因\n\n\n# 参考资料 \nhttp://www.cnblogs.com/krislight1105/p/5352500.html  \nhttp://blog.csdn.net/wangbaochu/article/details/50396512\n","source":"_posts/性能优化篇.md","raw":"title: Android 性能检测与优化\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n- 性能\n---\n\n\n\n# 手机端：\n\n## 开发者选项\n1. 绘图》 显示布局边界\n\n2. 硬件加速渲染 》调试GPU过渡绘制  要打开\n\n\n3. 监控》启用严格模式\n\t \n4. GPU呈现模式分析  可以对照颜色表找出耗时出在那一部分\n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/GPU%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F.jpg?raw=true)\n \n# 电脑端：\n1. 查看MemoryMonitor  ，查看页面内存波动（对于listview ）\n\n2. tools》android》android  device  monistor\n（其实它就是把android sdk中tools下面的很多功能聚合起来；  如ddms，uiautomatorviewer，monitor等功能聚合起来，但是好像没有集成hierarchyviewer的功能）\n\n3. 查看录制页面变化时候的cpu耗时   \n  开始录制》选中进程，点击红色方框左边的按钮，然后点击红色方框里右侧的按钮录制正式开始，需要结束时，再点击右侧按钮结束，就会有结果自动生成  \n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6.png?raw=true)\n  \n  分析结果》录制实际上是一个采样的过程，可以看图中红色方框里面最耗时的几个方法，基本上可以定位到程序的问题   \n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6_2.png?raw=true)\n4. 查看布局层次，以及每一层的绘制时间，目的是减小层次  \n入口是在：tools 下面 hierarchyviewer  查看每个层次的绘制时间（这个好像必须在模拟器上看）\n\n\n# 分析卡的原因\n\n\n# 参考资料 \nhttp://www.cnblogs.com/krislight1105/p/5352500.html  \nhttp://blog.csdn.net/wangbaochu/article/details/50396512\n","slug":"性能优化篇","published":1,"updated":"2017-03-17T13:25:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7ce000v1rjjg88t3nor","content":"<h1 id=\"手机端：\"><a href=\"#手机端：\" class=\"headerlink\" title=\"手机端：\"></a>手机端：</h1><h2 id=\"开发者选项\"><a href=\"#开发者选项\" class=\"headerlink\" title=\"开发者选项\"></a>开发者选项</h2><ol>\n<li><p>绘图》 显示布局边界</p>\n</li>\n<li><p>硬件加速渲染 》调试GPU过渡绘制  要打开</p>\n</li>\n</ol>\n<ol>\n<li><p>监控》启用严格模式</p>\n</li>\n<li><p>GPU呈现模式分析  可以对照颜色表找出耗时出在那一部分<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/GPU%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F.jpg?raw=true\" alt=\"image\"></p>\n</li>\n</ol>\n<h1 id=\"电脑端：\"><a href=\"#电脑端：\" class=\"headerlink\" title=\"电脑端：\"></a>电脑端：</h1><ol>\n<li><p>查看MemoryMonitor  ，查看页面内存波动（对于listview ）</p>\n</li>\n<li><p>tools》android》android  device  monistor<br>（其实它就是把android sdk中tools下面的很多功能聚合起来；  如ddms，uiautomatorviewer，monitor等功能聚合起来，但是好像没有集成hierarchyviewer的功能）</p>\n</li>\n<li><p>查看录制页面变化时候的cpu耗时<br>开始录制》选中进程，点击红色方框左边的按钮，然后点击红色方框里右侧的按钮录制正式开始，需要结束时，再点击右侧按钮结束，就会有结果自动生成<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6.png?raw=true\" alt=\"image\"></p>\n<p>分析结果》录制实际上是一个采样的过程，可以看图中红色方框里面最耗时的几个方法，基本上可以定位到程序的问题<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6_2.png?raw=true\" alt=\"image\"></p>\n</li>\n<li>查看布局层次，以及每一层的绘制时间，目的是减小层次<br>入口是在：tools 下面 hierarchyviewer  查看每个层次的绘制时间（这个好像必须在模拟器上看）</li>\n</ol>\n<h1 id=\"分析卡的原因\"><a href=\"#分析卡的原因\" class=\"headerlink\" title=\"分析卡的原因\"></a>分析卡的原因</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://www.cnblogs.com/krislight1105/p/5352500.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/krislight1105/p/5352500.html</a><br><a href=\"http://blog.csdn.net/wangbaochu/article/details/50396512\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/wangbaochu/article/details/50396512</a></p>\n","excerpt":"","more":"<h1 id=\"手机端：\"><a href=\"#手机端：\" class=\"headerlink\" title=\"手机端：\"></a>手机端：</h1><h2 id=\"开发者选项\"><a href=\"#开发者选项\" class=\"headerlink\" title=\"开发者选项\"></a>开发者选项</h2><ol>\n<li><p>绘图》 显示布局边界</p>\n</li>\n<li><p>硬件加速渲染 》调试GPU过渡绘制  要打开</p>\n</li>\n</ol>\n<ol>\n<li><p>监控》启用严格模式</p>\n</li>\n<li><p>GPU呈现模式分析  可以对照颜色表找出耗时出在那一部分<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/GPU%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F.jpg?raw=true\" alt=\"image\"></p>\n</li>\n</ol>\n<h1 id=\"电脑端：\"><a href=\"#电脑端：\" class=\"headerlink\" title=\"电脑端：\"></a>电脑端：</h1><ol>\n<li><p>查看MemoryMonitor  ，查看页面内存波动（对于listview ）</p>\n</li>\n<li><p>tools》android》android  device  monistor<br>（其实它就是把android sdk中tools下面的很多功能聚合起来；  如ddms，uiautomatorviewer，monitor等功能聚合起来，但是好像没有集成hierarchyviewer的功能）</p>\n</li>\n<li><p>查看录制页面变化时候的cpu耗时<br>开始录制》选中进程，点击红色方框左边的按钮，然后点击红色方框里右侧的按钮录制正式开始，需要结束时，再点击右侧按钮结束，就会有结果自动生成<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6.png?raw=true\" alt=\"image\"></p>\n<p>分析结果》录制实际上是一个采样的过程，可以看图中红色方框里面最耗时的几个方法，基本上可以定位到程序的问题<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6_2.png?raw=true\" alt=\"image\"></p>\n</li>\n<li>查看布局层次，以及每一层的绘制时间，目的是减小层次<br>入口是在：tools 下面 hierarchyviewer  查看每个层次的绘制时间（这个好像必须在模拟器上看）</li>\n</ol>\n<h1 id=\"分析卡的原因\"><a href=\"#分析卡的原因\" class=\"headerlink\" title=\"分析卡的原因\"></a>分析卡的原因</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://www.cnblogs.com/krislight1105/p/5352500.html\">http://www.cnblogs.com/krislight1105/p/5352500.html</a><br><a href=\"http://blog.csdn.net/wangbaochu/article/details/50396512\">http://blog.csdn.net/wangbaochu/article/details/50396512</a></p>\n"},{"title":"混淆写法","date":"2015-11-01T12:10:33.000Z","_content":"\n\n-keepclassmembers class ** {\n    public void onEvent*(**);\n}\n\n只保护 public void onEvent*(**)的方法不被重命名\n\n-keepattributes Signature\n\n\n-keep class okio.** {*;}\n\n\n-keep class android.support.v4.app.NotificationCompat**{\n    public *;\n}\n\n\n-keep class com.veda.lyc.Utils{ static *;}  \n保持里面的静态方法不被混淆\n\nkeep的几个选项\n\n\n| Keep        | From being removed or renamed   |  From being renamed  |\n| --------   | -----:  | :----:  |\n| Classes and class members     | -keep |   -keepnames     |\n| Class members only        |   -keepclassmembers   |   -keepclassmembernames   |\n| \t-keepclassmembers\t-keepclassmembernames\nClasses and class members, if class members present       |    -keepclasseswithmembers    |  -keepclasseswithmembernames  |\n\n\n参考资料\nhttp://blog.csdn.net/sudic_niu/article/details/7921548","source":"_posts/混淆写法.md","raw":"title: 混淆写法\ndate: 2015-11-01 20:10:33\ncategories:\n- 打包\ntags:\n- Android\n---\n\n\n-keepclassmembers class ** {\n    public void onEvent*(**);\n}\n\n只保护 public void onEvent*(**)的方法不被重命名\n\n-keepattributes Signature\n\n\n-keep class okio.** {*;}\n\n\n-keep class android.support.v4.app.NotificationCompat**{\n    public *;\n}\n\n\n-keep class com.veda.lyc.Utils{ static *;}  \n保持里面的静态方法不被混淆\n\nkeep的几个选项\n\n\n| Keep        | From being removed or renamed   |  From being renamed  |\n| --------   | -----:  | :----:  |\n| Classes and class members     | -keep |   -keepnames     |\n| Class members only        |   -keepclassmembers   |   -keepclassmembernames   |\n| \t-keepclassmembers\t-keepclassmembernames\nClasses and class members, if class members present       |    -keepclasseswithmembers    |  -keepclasseswithmembernames  |\n\n\n参考资料\nhttp://blog.csdn.net/sudic_niu/article/details/7921548","slug":"混淆写法","published":1,"updated":"2017-03-17T13:23:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7ck00101rjjktxf2xjp","content":"<p>-keepclassmembers class <strong> {<br>    public void onEvent*(</strong>);<br>}</p>\n<p>只保护 public void onEvent<em>(*</em>)的方法不被重命名</p>\n<p>-keepattributes Signature</p>\n<p>-keep class okio.<em>* {</em>;}</p>\n<p>-keep class android.support.v4.app.NotificationCompat<em>*{<br>    public </em>;<br>}</p>\n<p>-keep class com.veda.lyc.Utils{ static *;}<br>保持里面的静态方法不被混淆</p>\n<p>keep的几个选项</p>\n<table>\n<thead>\n<tr>\n<th>Keep</th>\n<th style=\"text-align:right\">From being removed or renamed</th>\n<th style=\"text-align:center\">From being renamed</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Classes and class members</td>\n<td style=\"text-align:right\">-keep</td>\n<td style=\"text-align:center\">-keepnames</td>\n</tr>\n<tr>\n<td>Class members only</td>\n<td style=\"text-align:right\">-keepclassmembers</td>\n<td style=\"text-align:center\">-keepclassmembernames</td>\n</tr>\n<tr>\n<td>-keepclassmembers    -keepclassmembernames</td>\n</tr>\n</tbody>\n</table>\n<p>Classes and class members, if class members present       |    -keepclasseswithmembers    |  -keepclasseswithmembernames  |</p>\n<p>参考资料<br><a href=\"http://blog.csdn.net/sudic_niu/article/details/7921548\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/sudic_niu/article/details/7921548</a></p>\n","excerpt":"","more":"<p>-keepclassmembers class <strong> {<br>    public void onEvent*(</strong>);<br>}</p>\n<p>只保护 public void onEvent<em>(*</em>)的方法不被重命名</p>\n<p>-keepattributes Signature</p>\n<p>-keep class okio.<em>* {</em>;}</p>\n<p>-keep class android.support.v4.app.NotificationCompat<em>*{<br>    public </em>;<br>}</p>\n<p>-keep class com.veda.lyc.Utils{ static *;}<br>保持里面的静态方法不被混淆</p>\n<p>keep的几个选项</p>\n<table>\n<thead>\n<tr>\n<th>Keep</th>\n<th style=\"text-align:right\">From being removed or renamed</th>\n<th style=\"text-align:center\">From being renamed</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Classes and class members</td>\n<td style=\"text-align:right\">-keep</td>\n<td style=\"text-align:center\">-keepnames</td>\n</tr>\n<tr>\n<td>Class members only</td>\n<td style=\"text-align:right\">-keepclassmembers</td>\n<td style=\"text-align:center\">-keepclassmembernames</td>\n</tr>\n<tr>\n<td>-keepclassmembers    -keepclassmembernames</td>\n</tr>\n</tbody>\n</table>\n<p>Classes and class members, if class members present       |    -keepclasseswithmembers    |  -keepclasseswithmembernames  |</p>\n<p>参考资料<br><a href=\"http://blog.csdn.net/sudic_niu/article/details/7921548\">http://blog.csdn.net/sudic_niu/article/details/7921548</a></p>\n"},{"title":"热补丁","date":"2015-11-01T12:10:33.000Z","_content":"\n# 基于java的热补丁逻辑\n\n## 核心两个部分\n### 1. hook部分  \nhook部分主要是使用反射调用补丁里面的内容\n\nhook部分的本质是提供对补丁方法调用的封装（主工程无法直接实例和调用补丁的方法），每次调用都是通过反射调用，传入activity，handler，callback进去。\n\n### 2. 补丁部分\n补丁实际上是java代码转的dex  \n它的工作有两种：网络取数据，构造生成view\n\n\n补丁部分构造view是通过hook部分传过来activity，然后用代码动态构造view，不涉及到任何布局文件，资源文件。  \n\n\n\n## hook的初始化及调用过程\n1. 初始化DexClassLoader  \nclassLoader = new DexClassLoader(dexApkFilePath\n                    + dexName + \".apk\", context.getDir(\"dex\", Context.MODE_PRIVATE).getAbsolutePath(), null,\n                    context.getClassLoader().getParent());\n                    \n2. load补丁相应的class  \ncontrollerClass = classLoader.loadClass(\"com.nico.Controller\");\n\n3. 初始化构造函数\ncontrollerConstrucor = controllerClass.getConstructor(new Class[]{Context.class, String.class, boolean.class});\n\n4. 实例化补丁里面的类\ncontrollerInstance = controllerConstrucor.newInstance(new Object[]{mContext});\n\n5. 通过初始化的实例controllerInstance来调用里面的方法  \nMethod initController = controllerClass.getDeclaredMethod(\"initController\", new Class[]{String.class, String.class, String.class});\n        initController.setAccessible(true);\n        initController.invoke(controllerInstance, new Object[]{paramsA, paramsB, paramsC});\n\n## 补丁的升级\n\n1. 校验是否有新的版本升级\n2. 把新的补丁下载到本地sd卡中去\n3. 解压补丁到data/data/app.pkg/app_dex目录  \nZipManager.extNativeZipFile(mContext,\n                            mContext.getResources().getAssets().open(Utils.ZIP_NAME),\n                            cachePath, dexApkFilePath, lastVersion)\n4. 重新走一遍补丁的实例化过程（从DexLoader开始）\n\n## 坑\n1. 第一次安装，补丁放到asset目录下面\n2. 由于里面传入了activity，要注意销毁补丁里面的强引用\n\n\n## To Be Continue\n1. load补丁里面的资源文件 ,通过反射调用AssetManger里面的资源文件，把ID设置上去 \n\n AssetManager assetManager = AssetManager.class.newInstance();  \n            Method addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class);  \n            addAssetPath.invoke(assetManager, libPath);  \n            Resources superRes = super.getResources();  \n            mRes = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());\n            \n2. 尝试使用mvp模式，把controllor从activity里面剥离开来，让所有contollor可以被热补丁，这要处理起来（可以把整个app轻量化）\n\n\n\n## 参考资料\n\nhttp://blog.csdn.net/wwj_748/article/details/46349781\n\nhttp://blog.csdn.net/yuanzeyao/article/details/42390431\n\nhttp://blog.csdn.net/u010386612/article/details/51077291\n\n\nhttp://blog.csdn.net/cn_foolishman/article/details/46874811","source":"_posts/热补丁_part0.md","raw":"title: 热补丁\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n- 热补丁\n---\n\n# 基于java的热补丁逻辑\n\n## 核心两个部分\n### 1. hook部分  \nhook部分主要是使用反射调用补丁里面的内容\n\nhook部分的本质是提供对补丁方法调用的封装（主工程无法直接实例和调用补丁的方法），每次调用都是通过反射调用，传入activity，handler，callback进去。\n\n### 2. 补丁部分\n补丁实际上是java代码转的dex  \n它的工作有两种：网络取数据，构造生成view\n\n\n补丁部分构造view是通过hook部分传过来activity，然后用代码动态构造view，不涉及到任何布局文件，资源文件。  \n\n\n\n## hook的初始化及调用过程\n1. 初始化DexClassLoader  \nclassLoader = new DexClassLoader(dexApkFilePath\n                    + dexName + \".apk\", context.getDir(\"dex\", Context.MODE_PRIVATE).getAbsolutePath(), null,\n                    context.getClassLoader().getParent());\n                    \n2. load补丁相应的class  \ncontrollerClass = classLoader.loadClass(\"com.nico.Controller\");\n\n3. 初始化构造函数\ncontrollerConstrucor = controllerClass.getConstructor(new Class[]{Context.class, String.class, boolean.class});\n\n4. 实例化补丁里面的类\ncontrollerInstance = controllerConstrucor.newInstance(new Object[]{mContext});\n\n5. 通过初始化的实例controllerInstance来调用里面的方法  \nMethod initController = controllerClass.getDeclaredMethod(\"initController\", new Class[]{String.class, String.class, String.class});\n        initController.setAccessible(true);\n        initController.invoke(controllerInstance, new Object[]{paramsA, paramsB, paramsC});\n\n## 补丁的升级\n\n1. 校验是否有新的版本升级\n2. 把新的补丁下载到本地sd卡中去\n3. 解压补丁到data/data/app.pkg/app_dex目录  \nZipManager.extNativeZipFile(mContext,\n                            mContext.getResources().getAssets().open(Utils.ZIP_NAME),\n                            cachePath, dexApkFilePath, lastVersion)\n4. 重新走一遍补丁的实例化过程（从DexLoader开始）\n\n## 坑\n1. 第一次安装，补丁放到asset目录下面\n2. 由于里面传入了activity，要注意销毁补丁里面的强引用\n\n\n## To Be Continue\n1. load补丁里面的资源文件 ,通过反射调用AssetManger里面的资源文件，把ID设置上去 \n\n AssetManager assetManager = AssetManager.class.newInstance();  \n            Method addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class);  \n            addAssetPath.invoke(assetManager, libPath);  \n            Resources superRes = super.getResources();  \n            mRes = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());\n            \n2. 尝试使用mvp模式，把controllor从activity里面剥离开来，让所有contollor可以被热补丁，这要处理起来（可以把整个app轻量化）\n\n\n\n## 参考资料\n\nhttp://blog.csdn.net/wwj_748/article/details/46349781\n\nhttp://blog.csdn.net/yuanzeyao/article/details/42390431\n\nhttp://blog.csdn.net/u010386612/article/details/51077291\n\n\nhttp://blog.csdn.net/cn_foolishman/article/details/46874811","slug":"热补丁_part0","published":1,"updated":"2017-03-17T13:24:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0dwk7cm00131rjjygf7zdcp","content":"<h1 id=\"基于java的热补丁逻辑\"><a href=\"#基于java的热补丁逻辑\" class=\"headerlink\" title=\"基于java的热补丁逻辑\"></a>基于java的热补丁逻辑</h1><h2 id=\"核心两个部分\"><a href=\"#核心两个部分\" class=\"headerlink\" title=\"核心两个部分\"></a>核心两个部分</h2><h3 id=\"1-hook部分\"><a href=\"#1-hook部分\" class=\"headerlink\" title=\"1. hook部分\"></a>1. hook部分</h3><p>hook部分主要是使用反射调用补丁里面的内容</p>\n<p>hook部分的本质是提供对补丁方法调用的封装（主工程无法直接实例和调用补丁的方法），每次调用都是通过反射调用，传入activity，handler，callback进去。</p>\n<h3 id=\"2-补丁部分\"><a href=\"#2-补丁部分\" class=\"headerlink\" title=\"2. 补丁部分\"></a>2. 补丁部分</h3><p>补丁实际上是java代码转的dex<br>它的工作有两种：网络取数据，构造生成view</p>\n<p>补丁部分构造view是通过hook部分传过来activity，然后用代码动态构造view，不涉及到任何布局文件，资源文件。  </p>\n<h2 id=\"hook的初始化及调用过程\"><a href=\"#hook的初始化及调用过程\" class=\"headerlink\" title=\"hook的初始化及调用过程\"></a>hook的初始化及调用过程</h2><ol>\n<li><p>初始化DexClassLoader<br>classLoader = new DexClassLoader(dexApkFilePath</p>\n<pre><code>+ dexName + &quot;.apk&quot;, context.getDir(&quot;dex&quot;, Context.MODE_PRIVATE).getAbsolutePath(), null,\ncontext.getClassLoader().getParent());\n</code></pre></li>\n<li><p>load补丁相应的class<br>controllerClass = classLoader.loadClass(“com.nico.Controller”);</p>\n</li>\n<li><p>初始化构造函数<br>controllerConstrucor = controllerClass.getConstructor(new Class[]{Context.class, String.class, boolean.class});</p>\n</li>\n<li><p>实例化补丁里面的类<br>controllerInstance = controllerConstrucor.newInstance(new Object[]{mContext});</p>\n</li>\n<li><p>通过初始化的实例controllerInstance来调用里面的方法<br>Method initController = controllerClass.getDeclaredMethod(“initController”, new Class[]{String.class, String.class, String.class});</p>\n<pre><code>initController.setAccessible(true);\ninitController.invoke(controllerInstance, new Object[]{paramsA, paramsB, paramsC});\n</code></pre></li>\n</ol>\n<h2 id=\"补丁的升级\"><a href=\"#补丁的升级\" class=\"headerlink\" title=\"补丁的升级\"></a>补丁的升级</h2><ol>\n<li>校验是否有新的版本升级</li>\n<li>把新的补丁下载到本地sd卡中去</li>\n<li>解压补丁到data/data/app.pkg/app_dex目录<br>ZipManager.extNativeZipFile(mContext,<pre><code>mContext.getResources().getAssets().open(Utils.ZIP_NAME),\ncachePath, dexApkFilePath, lastVersion)\n</code></pre></li>\n<li>重新走一遍补丁的实例化过程（从DexLoader开始）</li>\n</ol>\n<h2 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h2><ol>\n<li>第一次安装，补丁放到asset目录下面</li>\n<li>由于里面传入了activity，要注意销毁补丁里面的强引用</li>\n</ol>\n<h2 id=\"To-Be-Continue\"><a href=\"#To-Be-Continue\" class=\"headerlink\" title=\"To Be Continue\"></a>To Be Continue</h2><ol>\n<li><p>load补丁里面的资源文件 ,通过反射调用AssetManger里面的资源文件，把ID设置上去 </p>\n<p>AssetManager assetManager = AssetManager.class.newInstance();  </p>\n<pre><code>Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);  \naddAssetPath.invoke(assetManager, libPath);  \nResources superRes = super.getResources();  \nmRes = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());\n</code></pre></li>\n<li><p>尝试使用mvp模式，把controllor从activity里面剥离开来，让所有contollor可以被热补丁，这要处理起来（可以把整个app轻量化）</p>\n</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.csdn.net/wwj_748/article/details/46349781\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/wwj_748/article/details/46349781</a></p>\n<p><a href=\"http://blog.csdn.net/yuanzeyao/article/details/42390431\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/yuanzeyao/article/details/42390431</a></p>\n<p><a href=\"http://blog.csdn.net/u010386612/article/details/51077291\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u010386612/article/details/51077291</a></p>\n<p><a href=\"http://blog.csdn.net/cn_foolishman/article/details/46874811\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/cn_foolishman/article/details/46874811</a></p>\n","excerpt":"","more":"<h1 id=\"基于java的热补丁逻辑\"><a href=\"#基于java的热补丁逻辑\" class=\"headerlink\" title=\"基于java的热补丁逻辑\"></a>基于java的热补丁逻辑</h1><h2 id=\"核心两个部分\"><a href=\"#核心两个部分\" class=\"headerlink\" title=\"核心两个部分\"></a>核心两个部分</h2><h3 id=\"1-hook部分\"><a href=\"#1-hook部分\" class=\"headerlink\" title=\"1. hook部分\"></a>1. hook部分</h3><p>hook部分主要是使用反射调用补丁里面的内容</p>\n<p>hook部分的本质是提供对补丁方法调用的封装（主工程无法直接实例和调用补丁的方法），每次调用都是通过反射调用，传入activity，handler，callback进去。</p>\n<h3 id=\"2-补丁部分\"><a href=\"#2-补丁部分\" class=\"headerlink\" title=\"2. 补丁部分\"></a>2. 补丁部分</h3><p>补丁实际上是java代码转的dex<br>它的工作有两种：网络取数据，构造生成view</p>\n<p>补丁部分构造view是通过hook部分传过来activity，然后用代码动态构造view，不涉及到任何布局文件，资源文件。  </p>\n<h2 id=\"hook的初始化及调用过程\"><a href=\"#hook的初始化及调用过程\" class=\"headerlink\" title=\"hook的初始化及调用过程\"></a>hook的初始化及调用过程</h2><ol>\n<li><p>初始化DexClassLoader<br>classLoader = new DexClassLoader(dexApkFilePath</p>\n<pre><code>+ dexName + &quot;.apk&quot;, context.getDir(&quot;dex&quot;, Context.MODE_PRIVATE).getAbsolutePath(), null,\ncontext.getClassLoader().getParent());\n</code></pre></li>\n<li><p>load补丁相应的class<br>controllerClass = classLoader.loadClass(“com.nico.Controller”);</p>\n</li>\n<li><p>初始化构造函数<br>controllerConstrucor = controllerClass.getConstructor(new Class[]{Context.class, String.class, boolean.class});</p>\n</li>\n<li><p>实例化补丁里面的类<br>controllerInstance = controllerConstrucor.newInstance(new Object[]{mContext});</p>\n</li>\n<li><p>通过初始化的实例controllerInstance来调用里面的方法<br>Method initController = controllerClass.getDeclaredMethod(“initController”, new Class[]{String.class, String.class, String.class});</p>\n<pre><code>initController.setAccessible(true);\ninitController.invoke(controllerInstance, new Object[]{paramsA, paramsB, paramsC});\n</code></pre></li>\n</ol>\n<h2 id=\"补丁的升级\"><a href=\"#补丁的升级\" class=\"headerlink\" title=\"补丁的升级\"></a>补丁的升级</h2><ol>\n<li>校验是否有新的版本升级</li>\n<li>把新的补丁下载到本地sd卡中去</li>\n<li>解压补丁到data/data/app.pkg/app_dex目录<br>ZipManager.extNativeZipFile(mContext,<pre><code>mContext.getResources().getAssets().open(Utils.ZIP_NAME),\ncachePath, dexApkFilePath, lastVersion)\n</code></pre></li>\n<li>重新走一遍补丁的实例化过程（从DexLoader开始）</li>\n</ol>\n<h2 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h2><ol>\n<li>第一次安装，补丁放到asset目录下面</li>\n<li>由于里面传入了activity，要注意销毁补丁里面的强引用</li>\n</ol>\n<h2 id=\"To-Be-Continue\"><a href=\"#To-Be-Continue\" class=\"headerlink\" title=\"To Be Continue\"></a>To Be Continue</h2><ol>\n<li><p>load补丁里面的资源文件 ,通过反射调用AssetManger里面的资源文件，把ID设置上去 </p>\n<p>AssetManager assetManager = AssetManager.class.newInstance();  </p>\n<pre><code>Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);  \naddAssetPath.invoke(assetManager, libPath);  \nResources superRes = super.getResources();  \nmRes = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());\n</code></pre></li>\n<li><p>尝试使用mvp模式，把controllor从activity里面剥离开来，让所有contollor可以被热补丁，这要处理起来（可以把整个app轻量化）</p>\n</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.csdn.net/wwj_748/article/details/46349781\">http://blog.csdn.net/wwj_748/article/details/46349781</a></p>\n<p><a href=\"http://blog.csdn.net/yuanzeyao/article/details/42390431\">http://blog.csdn.net/yuanzeyao/article/details/42390431</a></p>\n<p><a href=\"http://blog.csdn.net/u010386612/article/details/51077291\">http://blog.csdn.net/u010386612/article/details/51077291</a></p>\n<p><a href=\"http://blog.csdn.net/cn_foolishman/article/details/46874811\">http://blog.csdn.net/cn_foolishman/article/details/46874811</a></p>\n"},{"_content":"# EventBus3.0 优点：\n\nEventBus 3由于使用了注解，比起使用反射来遍历方法的2.4版本逊色不少。但开挂之后(启用了索引)远远超出之前的版本。\n\n![性能对比](http://i.imgur.com/5evKXOx.png)\n\n参考资料：https://www.cnblogs.com/bugly/p/5475034.html\n\n\n## 开挂方法：  \n1. 在当前moudle的gradle 添加    \n\n\t\t\tapply plugin: 'com.neenbedankt.android-apt'   \n\n2. 在dependencies里面添加   \n\n\t\tdependencies \n\t\tcompile 'org.greenrobot:eventbus:3.0.0'\n\t\tapt 'org.greenrobot:eventbus-annotation-processor:3.0.1'   \n\n\n3. 在使用时候   \n\n\t\t@Subscribe\n\t\tpublic void helloEventBus(UserReLoginEvent  event){\n\t\t    // TODO: 17/6/27  这是是为了测试而使用的\n\t\t    UtilsManager.toast(mContext,\"这是eventbus 3.0 可以支持的\");\n\t\t}\n\n\n\n## 事件源定位：  \n为了防止事件环路对EventBus加一个Wrapper，每次发送Event时候打印一下路径   \n\n\t \tprivate static void printWrapPath(String tagStr, Object... objects) {\n\n\t        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n\t        final StackTraceElement ste = stackTrace[5];\n\n\t        StringBuilder stringBuilder = new StringBuilder();\n\t        String className = ste.getFileName();\n\t        if (!TextUtils.isEmpty(className)) {\n\t            String methodName = ste.getMethodName();\n\t            int lineNumber = ste.getLineNumber();\n\t            stringBuilder.append(\"(\").append(className).append(\":\").append(lineNumber).append(\") #\").append(methodName).append(\" : \");\n\t        } else {\n\t            stringBuilder.append(\" \");\n\t        }\n\n\t        String tag = (tagStr == null ? LOG_DEFAULT_TAG : tagStr);\n\t        String msg = (objects == null) ? \"null\" : getObjectsString(objects);\n\t        String headString = stringBuilder.toString();\n\n\t \t\tLog.println(type, tagStr, headString + msg);\n\n\t \t}\n\n\n## 混淆问题  ：  \n\n混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。\n\n首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报java.lang.NoSuchFieldError: No static field POSTING。网上给出的解决办法是keep住所有eventbus相关的代码：\n\n\t\t-keep class de.greenrobot.** {*;}  \n\n\n其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。\n\n\t\t-keep public enum org.greenrobot.eventbus.ThreadMode { public static *; }   \n\n\n这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule?\n\n这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法：\n\n\t-keepclassmembers class * {\n\t    @de.greenrobot.event.Subscribe <methods>;\n\t}\n\n\n所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。\n\n## Android APT\n  参考资料：https://segmentfault.com/a/1190000005100468\n\n","source":"_posts/EventBus版本升级.md","raw":"# EventBus3.0 优点：\n\nEventBus 3由于使用了注解，比起使用反射来遍历方法的2.4版本逊色不少。但开挂之后(启用了索引)远远超出之前的版本。\n\n![性能对比](http://i.imgur.com/5evKXOx.png)\n\n参考资料：https://www.cnblogs.com/bugly/p/5475034.html\n\n\n## 开挂方法：  \n1. 在当前moudle的gradle 添加    \n\n\t\t\tapply plugin: 'com.neenbedankt.android-apt'   \n\n2. 在dependencies里面添加   \n\n\t\tdependencies \n\t\tcompile 'org.greenrobot:eventbus:3.0.0'\n\t\tapt 'org.greenrobot:eventbus-annotation-processor:3.0.1'   \n\n\n3. 在使用时候   \n\n\t\t@Subscribe\n\t\tpublic void helloEventBus(UserReLoginEvent  event){\n\t\t    // TODO: 17/6/27  这是是为了测试而使用的\n\t\t    UtilsManager.toast(mContext,\"这是eventbus 3.0 可以支持的\");\n\t\t}\n\n\n\n## 事件源定位：  \n为了防止事件环路对EventBus加一个Wrapper，每次发送Event时候打印一下路径   \n\n\t \tprivate static void printWrapPath(String tagStr, Object... objects) {\n\n\t        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n\t        final StackTraceElement ste = stackTrace[5];\n\n\t        StringBuilder stringBuilder = new StringBuilder();\n\t        String className = ste.getFileName();\n\t        if (!TextUtils.isEmpty(className)) {\n\t            String methodName = ste.getMethodName();\n\t            int lineNumber = ste.getLineNumber();\n\t            stringBuilder.append(\"(\").append(className).append(\":\").append(lineNumber).append(\") #\").append(methodName).append(\" : \");\n\t        } else {\n\t            stringBuilder.append(\" \");\n\t        }\n\n\t        String tag = (tagStr == null ? LOG_DEFAULT_TAG : tagStr);\n\t        String msg = (objects == null) ? \"null\" : getObjectsString(objects);\n\t        String headString = stringBuilder.toString();\n\n\t \t\tLog.println(type, tagStr, headString + msg);\n\n\t \t}\n\n\n## 混淆问题  ：  \n\n混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。\n\n首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报java.lang.NoSuchFieldError: No static field POSTING。网上给出的解决办法是keep住所有eventbus相关的代码：\n\n\t\t-keep class de.greenrobot.** {*;}  \n\n\n其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。\n\n\t\t-keep public enum org.greenrobot.eventbus.ThreadMode { public static *; }   \n\n\n这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule?\n\n这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法：\n\n\t-keepclassmembers class * {\n\t    @de.greenrobot.event.Subscribe <methods>;\n\t}\n\n\n所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。\n\n## Android APT\n  参考资料：https://segmentfault.com/a/1190000005100468\n\n","slug":"EventBus版本升级","published":1,"date":"2018-03-03T13:49:07.000Z","updated":"2018-03-03T13:49:07.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjebfw8hw0000b6jffolpgw3o","content":"<h1 id=\"EventBus3-0-优点：\"><a href=\"#EventBus3-0-优点：\" class=\"headerlink\" title=\"EventBus3.0 优点：\"></a>EventBus3.0 优点：</h1><p>EventBus 3由于使用了注解，比起使用反射来遍历方法的2.4版本逊色不少。但开挂之后(启用了索引)远远超出之前的版本。</p>\n<p><img src=\"http://i.imgur.com/5evKXOx.png\" alt=\"性能对比\"></p>\n<p>参考资料：<a href=\"https://www.cnblogs.com/bugly/p/5475034.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/bugly/p/5475034.html</a></p>\n<h2 id=\"开挂方法：\"><a href=\"#开挂方法：\" class=\"headerlink\" title=\"开挂方法：\"></a>开挂方法：</h2><ol>\n<li><p>在当前moudle的gradle 添加    </p>\n<pre><code>apply plugin: &apos;com.neenbedankt.android-apt&apos;   \n</code></pre></li>\n<li><p>在dependencies里面添加   </p>\n<pre><code>dependencies \ncompile &apos;org.greenrobot:eventbus:3.0.0&apos;\napt &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;   \n</code></pre></li>\n</ol>\n<ol>\n<li><p>在使用时候   </p>\n<pre><code>@Subscribe\npublic void helloEventBus(UserReLoginEvent  event){\n    // TODO: 17/6/27  这是是为了测试而使用的\n    UtilsManager.toast(mContext,&quot;这是eventbus 3.0 可以支持的&quot;);\n}\n</code></pre></li>\n</ol>\n<h2 id=\"事件源定位：\"><a href=\"#事件源定位：\" class=\"headerlink\" title=\"事件源定位：\"></a>事件源定位：</h2><p>为了防止事件环路对EventBus加一个Wrapper，每次发送Event时候打印一下路径   </p>\n<pre><code>private static void printWrapPath(String tagStr, Object... objects) {\n\n   StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n   final StackTraceElement ste = stackTrace[5];\n\n   StringBuilder stringBuilder = new StringBuilder();\n   String className = ste.getFileName();\n   if (!TextUtils.isEmpty(className)) {\n       String methodName = ste.getMethodName();\n       int lineNumber = ste.getLineNumber();\n       stringBuilder.append(&quot;(&quot;).append(className).append(&quot;:&quot;).append(lineNumber).append(&quot;) #&quot;).append(methodName).append(&quot; : &quot;);\n   } else {\n       stringBuilder.append(&quot; &quot;);\n   }\n\n   String tag = (tagStr == null ? LOG_DEFAULT_TAG : tagStr);\n   String msg = (objects == null) ? &quot;null&quot; : getObjectsString(objects);\n   String headString = stringBuilder.toString();\n\n    Log.println(type, tagStr, headString + msg);\n\n}\n</code></pre><h2 id=\"混淆问题-：\"><a href=\"#混淆问题-：\" class=\"headerlink\" title=\"混淆问题  ：\"></a>混淆问题  ：</h2><p>混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。</p>\n<p>首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报java.lang.NoSuchFieldError: No static field POSTING。网上给出的解决办法是keep住所有eventbus相关的代码：</p>\n<pre><code>-keep class de.greenrobot.** {*;}  \n</code></pre><p>其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。</p>\n<pre><code>-keep public enum org.greenrobot.eventbus.ThreadMode { public static *; }   \n</code></pre><p>这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule?</p>\n<p>这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法：</p>\n<pre><code>-keepclassmembers class * {\n    @de.greenrobot.event.Subscribe &lt;methods&gt;;\n}\n</code></pre><p>所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。</p>\n<h2 id=\"Android-APT\"><a href=\"#Android-APT\" class=\"headerlink\" title=\"Android APT\"></a>Android APT</h2><p>  参考资料：<a href=\"https://segmentfault.com/a/1190000005100468\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000005100468</a></p>\n","excerpt":"","more":"<h1 id=\"EventBus3-0-优点：\"><a href=\"#EventBus3-0-优点：\" class=\"headerlink\" title=\"EventBus3.0 优点：\"></a>EventBus3.0 优点：</h1><p>EventBus 3由于使用了注解，比起使用反射来遍历方法的2.4版本逊色不少。但开挂之后(启用了索引)远远超出之前的版本。</p>\n<p><img src=\"http://i.imgur.com/5evKXOx.png\" alt=\"性能对比\"></p>\n<p>参考资料：<a href=\"https://www.cnblogs.com/bugly/p/5475034.html\">https://www.cnblogs.com/bugly/p/5475034.html</a></p>\n<h2 id=\"开挂方法：\"><a href=\"#开挂方法：\" class=\"headerlink\" title=\"开挂方法：\"></a>开挂方法：</h2><ol>\n<li><p>在当前moudle的gradle 添加    </p>\n<pre><code>apply plugin: &apos;com.neenbedankt.android-apt&apos;   \n</code></pre></li>\n<li><p>在dependencies里面添加   </p>\n<pre><code>dependencies \ncompile &apos;org.greenrobot:eventbus:3.0.0&apos;\napt &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;   \n</code></pre></li>\n</ol>\n<ol>\n<li><p>在使用时候   </p>\n<pre><code>@Subscribe\npublic void helloEventBus(UserReLoginEvent  event){\n    // TODO: 17/6/27  这是是为了测试而使用的\n    UtilsManager.toast(mContext,&quot;这是eventbus 3.0 可以支持的&quot;);\n}\n</code></pre></li>\n</ol>\n<h2 id=\"事件源定位：\"><a href=\"#事件源定位：\" class=\"headerlink\" title=\"事件源定位：\"></a>事件源定位：</h2><p>为了防止事件环路对EventBus加一个Wrapper，每次发送Event时候打印一下路径   </p>\n<pre><code>private static void printWrapPath(String tagStr, Object... objects) {\n\n   StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n   final StackTraceElement ste = stackTrace[5];\n\n   StringBuilder stringBuilder = new StringBuilder();\n   String className = ste.getFileName();\n   if (!TextUtils.isEmpty(className)) {\n       String methodName = ste.getMethodName();\n       int lineNumber = ste.getLineNumber();\n       stringBuilder.append(&quot;(&quot;).append(className).append(&quot;:&quot;).append(lineNumber).append(&quot;) #&quot;).append(methodName).append(&quot; : &quot;);\n   } else {\n       stringBuilder.append(&quot; &quot;);\n   }\n\n   String tag = (tagStr == null ? LOG_DEFAULT_TAG : tagStr);\n   String msg = (objects == null) ? &quot;null&quot; : getObjectsString(objects);\n   String headString = stringBuilder.toString();\n\n    Log.println(type, tagStr, headString + msg);\n\n}\n</code></pre><h2 id=\"混淆问题-：\"><a href=\"#混淆问题-：\" class=\"headerlink\" title=\"混淆问题  ：\"></a>混淆问题  ：</h2><p>混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。</p>\n<p>首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报java.lang.NoSuchFieldError: No static field POSTING。网上给出的解决办法是keep住所有eventbus相关的代码：</p>\n<pre><code>-keep class de.greenrobot.** {*;}  \n</code></pre><p>其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。</p>\n<pre><code>-keep public enum org.greenrobot.eventbus.ThreadMode { public static *; }   \n</code></pre><p>这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule?</p>\n<p>这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法：</p>\n<pre><code>-keepclassmembers class * {\n    @de.greenrobot.event.Subscribe &lt;methods&gt;;\n}\n</code></pre><p>所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。</p>\n<h2 id=\"Android-APT\"><a href=\"#Android-APT\" class=\"headerlink\" title=\"Android APT\"></a>Android APT</h2><p>  参考资料：<a href=\"https://segmentfault.com/a/1190000005100468\">https://segmentfault.com/a/1190000005100468</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj0dwk7b900001rjjh5cesaxq","category_id":"cj0dwk7bh00021rjja80ocw5o","_id":"cj0dwk7by000b1rjjtwlhbxr5"},{"post_id":"cj0dwk7bo00061rjjlg4w7olg","category_id":"cj0dwk7bh00021rjja80ocw5o","_id":"cj0dwk7c0000g1rjj40sz1ofo"},{"post_id":"cj0dwk7bt000a1rjjhxhl52a6","category_id":"cj0dwk7bh00021rjja80ocw5o","_id":"cj0dwk7c2000i1rjj2978fmvd"},{"post_id":"cj0dwk7be00011rjjm4l2x5c1","category_id":"cj0dwk7bh00021rjja80ocw5o","_id":"cj0dwk7c6000m1rjj3dj0hrax"},{"post_id":"cj0dwk7bj00041rjjduvxjx5y","category_id":"cj0dwk7c0000e1rjj5vnerph7","_id":"cj0dwk7c9000q1rjjol4z7806"},{"post_id":"cj0dwk7bl00051rjjnf30wxgg","category_id":"cj0dwk7c4000k1rjja11kwbcr","_id":"cj0dwk7ch000w1rjj369p0qj5"},{"post_id":"cj0dwk7c8000p1rjj02xz9kyf","category_id":"cj0dwk7c0000e1rjj5vnerph7","_id":"cj0dwk7cl00111rjjw9959e2x"},{"post_id":"cj0dwk7bz000d1rjjjmup2ynn","category_id":"cj0dwk7c4000k1rjja11kwbcr","_id":"cj0dwk7cn00141rjjimt5inln"},{"post_id":"cj0dwk7ce000v1rjjg88t3nor","category_id":"cj0dwk7bh00021rjja80ocw5o","_id":"cj0dwk7co00181rjjtob8tfb0"},{"post_id":"cj0dwk7c1000h1rjjoa1haq4t","category_id":"cj0dwk7c4000k1rjja11kwbcr","_id":"cj0dwk7co001a1rjja4j86gir"},{"post_id":"cj0dwk7cm00131rjjygf7zdcp","category_id":"cj0dwk7bh00021rjja80ocw5o","_id":"cj0dwk7cq001e1rjjg77conre"},{"post_id":"cj0dwk7c2000j1rjjehvoq8y4","category_id":"cj0dwk7cn00151rjjrk001ex6","_id":"cj0dwk7cr001g1rjjmsfb0svt"},{"post_id":"cj0dwk7c6000n1rjjww1xihdp","category_id":"cj0dwk7co001c1rjjf6yti5zs","_id":"cj0dwk7cs001l1rjjvzo3doag"},{"post_id":"cj0dwk7cd000u1rjjp3qb5tx8","category_id":"cj0dwk7cr001i1rjjmq069nyg","_id":"cj0dwk7cu001q1rjj5gooio2f"},{"post_id":"cj0dwk7ck00101rjjktxf2xjp","category_id":"cj0dwk7cs001n1rjjc6n83fti","_id":"cj0dwk7cw001t1rjjercbklmp"}],"PostTag":[{"post_id":"cj0dwk7b900001rjjh5cesaxq","tag_id":"cj0dwk7bj00031rjji79jfp94","_id":"cj0dwk7bt00091rjj8f6888q5"},{"post_id":"cj0dwk7bo00061rjjlg4w7olg","tag_id":"cj0dwk7bj00031rjji79jfp94","_id":"cj0dwk7by000c1rjjvhinv5a3"},{"post_id":"cj0dwk7be00011rjjm4l2x5c1","tag_id":"cj0dwk7bj00031rjji79jfp94","_id":"cj0dwk7c7000o1rjj7ubjnfih"},{"post_id":"cj0dwk7be00011rjjm4l2x5c1","tag_id":"cj0dwk7c0000f1rjjfsfmau0l","_id":"cj0dwk7c9000r1rjjqauar0l6"},{"post_id":"cj0dwk7cd000u1rjjp3qb5tx8","tag_id":"cj0dwk7c0000f1rjjfsfmau0l","_id":"cj0dwk7ci000z1rjj0wpfg6nv"},{"post_id":"cj0dwk7cd000u1rjjp3qb5tx8","tag_id":"cj0dwk7bj00031rjji79jfp94","_id":"cj0dwk7cl00121rjj3j3l81ka"},{"post_id":"cj0dwk7bj00041rjjduvxjx5y","tag_id":"cj0dwk7c5000l1rjjbyrsooyh","_id":"cj0dwk7cn00171rjjvonam6gs"},{"post_id":"cj0dwk7bj00041rjjduvxjx5y","tag_id":"cj0dwk7c0000f1rjjfsfmau0l","_id":"cj0dwk7co00191rjjamzutkqi"},{"post_id":"cj0dwk7ck00101rjjktxf2xjp","tag_id":"cj0dwk7bj00031rjji79jfp94","_id":"cj0dwk7co001b1rjjq30deq8s"},{"post_id":"cj0dwk7bl00051rjjnf30wxgg","tag_id":"cj0dwk7c5000l1rjjbyrsooyh","_id":"cj0dwk7cq001f1rjjhcahdqe9"},{"post_id":"cj0dwk7bt000a1rjjhxhl52a6","tag_id":"cj0dwk7bj00031rjji79jfp94","_id":"cj0dwk7cr001h1rjjxbrmhh06"},{"post_id":"cj0dwk7bt000a1rjjhxhl52a6","tag_id":"cj0dwk7cn00161rjj3xbc4rhs","_id":"cj0dwk7cs001k1rjjloz7j3ee"},{"post_id":"cj0dwk7bz000d1rjjjmup2ynn","tag_id":"cj0dwk7cp001d1rjjvxsc48ns","_id":"cj0dwk7cu001o1rjjrt0xyw0y"},{"post_id":"cj0dwk7bz000d1rjjjmup2ynn","tag_id":"cj0dwk7c5000l1rjjbyrsooyh","_id":"cj0dwk7cu001p1rjjq1o09ovz"},{"post_id":"cj0dwk7c1000h1rjjoa1haq4t","tag_id":"cj0dwk7c5000l1rjjbyrsooyh","_id":"cj0dwk7cv001s1rjja2wrhpt9"},{"post_id":"cj0dwk7c2000j1rjjehvoq8y4","tag_id":"cj0dwk7cu001r1rjjv991uenp","_id":"cj0dwk7cw001v1rjjulw2avxi"},{"post_id":"cj0dwk7c6000n1rjjww1xihdp","tag_id":"cj0dwk7cw001u1rjj04tnl3gv","_id":"cj0dwk7cx001x1rjj0e1d18q0"},{"post_id":"cj0dwk7c8000p1rjj02xz9kyf","tag_id":"cj0dwk7cx001w1rjjotnfcjlt","_id":"cj0dwk7cy001z1rjj37kgynxj"},{"post_id":"cj0dwk7ce000v1rjjg88t3nor","tag_id":"cj0dwk7bj00031rjji79jfp94","_id":"cj0dwk7cy00211rjjgpjmj6lm"},{"post_id":"cj0dwk7ce000v1rjjg88t3nor","tag_id":"cj0dwk7cy001y1rjj3umg3mat","_id":"cj0dwk7cz00221rjj92mt3n7o"},{"post_id":"cj0dwk7cm00131rjjygf7zdcp","tag_id":"cj0dwk7bj00031rjji79jfp94","_id":"cj0dwk7cz00231rjjquuproa9"},{"post_id":"cj0dwk7cm00131rjjygf7zdcp","tag_id":"cj0dwk7cy00201rjjwwnxlzq8","_id":"cj0dwk7cz00241rjjk34q669c"}],"Tag":[{"name":"Android","_id":"cj0dwk7bj00031rjji79jfp94"},{"name":"打包","_id":"cj0dwk7c0000f1rjjfsfmau0l"},{"name":"工具","_id":"cj0dwk7c5000l1rjjbyrsooyh"},{"name":"模块化","_id":"cj0dwk7cn00161rjj3xbc4rhs"},{"name":"github","_id":"cj0dwk7cp001d1rjjvxsc48ns"},{"name":"其他","_id":"cj0dwk7cu001r1rjjv991uenp"},{"name":"ios入门","_id":"cj0dwk7cw001u1rjj04tnl3gv"},{"name":"网络层","_id":"cj0dwk7cx001w1rjjotnfcjlt"},{"name":"性能","_id":"cj0dwk7cy001y1rjj3umg3mat"},{"name":"热补丁","_id":"cj0dwk7cy00201rjjwwnxlzq8"}]}}