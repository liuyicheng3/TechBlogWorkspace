{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"acb7316a6652b30255a960a22ad963ce7fba06e8","modified":1520179292000},{"_id":"themes/hexo-theme-next/.DS_Store","hash":"f09a86bb4ce7d04901ec1bb4cb55bee99909840c","modified":1489759579000},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1489756015000},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1489756015000},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1489756015000},{"_id":"themes/hexo-theme-next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1489756015000},{"_id":"themes/hexo-theme-next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1489756015000},{"_id":"themes/hexo-theme-next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1489756015000},{"_id":"themes/hexo-theme-next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1489756015000},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1489756015000},{"_id":"themes/hexo-theme-next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1489756015000},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1489756015000},{"_id":"themes/hexo-theme-next/_config.yml","hash":"1c7150916f6a43cf46e28bc8acd255cb401e15f3","modified":1489759709000},{"_id":"themes/hexo-theme-next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1489756015000},{"_id":"themes/hexo-theme-next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1489756015000},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1489756015000},{"_id":"themes/hexo-theme-next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1489756015000},{"_id":"themes/hexo-theme-next/package.json","hash":"7e87b2621104b39a30488654c2a8a0c6a563574b","modified":1489756015000},{"_id":"source/_posts/AMS浅析_01.md","hash":"d863db396f448aacba8be64715ed5f7db123f3ca","modified":1520180413000},{"_id":"source/_posts/AMS浅析_02.md","hash":"9da24c8050ed563d2689894e55726ca6bbb67be2","modified":1520180413000},{"_id":"source/_posts/AS导入工程配置.md","hash":"a40a1b683e5868a0f3b984fa76ae0bfe7ce3738e","modified":1520180413000},{"_id":"source/_posts/Android分包.md","hash":"08866ecef30d9a28cc655f592e29a709bfd7446c","modified":1520180413000},{"_id":"source/_posts/Android模块化方案.md","hash":"e6019db302fd962b4bebca1193aeccf0c74f69f6","modified":1520180413000},{"_id":"source/_posts/App核心指标.md","hash":"cbab52666d51bbd5611f3e86ae601963b3a12884","modified":1520180413000},{"_id":"source/_posts/EventBus版本升级.md","hash":"08a7b0e714d788ce6ae4ed50a7b3f426c63d7c4b","modified":1520180413000},{"_id":"source/_posts/Gradle小结.md","hash":"264640f0a8eaf6f83106dc1c22aa7a252d52c182","modified":1520180413000},{"_id":"source/_posts/Hugo方法耗时监控.md","hash":"d89b44429aebaa91bdb5dc0851d73043b3044ba9","modified":1520180413000},{"_id":"source/_posts/Okhttp核心流程.md","hash":"b004ae808ad3f0df92ed54d7c83940589df19b25","modified":1520180413000},{"_id":"source/_posts/Xcode 和Android  studio 快捷键及设置对比.md","hash":"eb317879f8abbb6e349c04f720c3d85323b0ff5a","modified":1520180413000},{"_id":"source/_posts/android全屏模键盘冲突.md","hash":"31f3a87b1bc5c0a4bfdca33e1650374a64b99f0b","modified":1520180413000},{"_id":"source/_posts/deep_link设计方案.md","hash":"0e3b73abb4dd9ebbb85667da9e955bffe1885520","modified":1520180413000},{"_id":"source/_posts/github_guide.md","hash":"81623331d1b0ebf3e5902e68c195fa4cbfef991f","modified":1520180413000},{"_id":"source/_posts/gradle坑.md","hash":"1624be3d3a925d24da2cb040a037c7975debe37c","modified":1520180413000},{"_id":"source/_posts/iOS学习笔记.md","hash":"4dc41bf097a3639b4cbea16e4b41b1db68ffe1f3","modified":1520180413000},{"_id":"source/_posts/xml处理.md","hash":"82d9b2967fab5ee462027e7d2bdeb18e37022333","modified":1520180413000},{"_id":"source/_posts/全屏模式adjustadjustResize.md","hash":"ef042c1ec79737719b387ddf3746a8c5bb8b109f","modified":1520180413000},{"_id":"source/_posts/公众号爬取.md","hash":"7d8e1664de0a50efaa7e0e316534ff897a36fa45","modified":1520180413000},{"_id":"source/_posts/分析UI流畅度.md","hash":"2969c51bcb93046dbcebf63565017f43b9b33312","modified":1520180413000},{"_id":"source/_posts/动态往apk写入信息.md","hash":"c532c91fcab1c7820dcc8f27c740b762c101a36a","modified":1520180413000},{"_id":"source/_posts/图标跟随主题色方案.md","hash":"b552ff423f268adfa13d41523df62d0dffd0b956","modified":1520180413000},{"_id":"source/_posts/图片不同尺寸缓存的优化方案.md","hash":"c22e37ded234efb86d2e5a297f9fcb7662d2a5b5","modified":1520180413000},{"_id":"source/_posts/数据库.md","hash":"de7041245d13234dd166ef36d6910c1d3870ab98","modified":1520180413000},{"_id":"source/_posts/沉浸式.md","hash":"01fdf15b0a54ecf56b04c38ae458a4f42157c526","modified":1520180413000},{"_id":"source/_posts/混淆写法.md","hash":"64462e9327883e46dfeb6d8ebf2762c06b6b669c","modified":1520180413000},{"_id":"source/_posts/点赞爱心动画.md","hash":"f2889a80bf22809f0ec9416283e802158c7886d0","modified":1520180413000},{"_id":"source/_posts/生成分享图片.md","hash":"999eb706e87be23d1fc0557b27d3401d35b560f1","modified":1520180413000},{"_id":"source/_posts/用户数据统计和行为分析.md","hash":"61d443e28d9545d958254a25a9127310302b870a","modified":1520180413000},{"_id":"source/_posts/简易java热补丁.md","hash":"a87b0ec01af8521433a03cab2f76256a8f184031","modified":1520180413000},{"_id":"source/_posts/首页崩溃解决方案.md","hash":"0f207b1d1b1bcb951a31f57486ea0ddb66ddcbe7","modified":1520180413000},{"_id":"themes/hexo-theme-next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/config","hash":"a33539305f85ea695520b496f67659d5751acff8","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/index","hash":"3f490b592a86019c6f96f792077486fc5babb880","modified":1520143240000},{"_id":"themes/hexo-theme-next/.git/packed-refs","hash":"f834a58defdb1370a8c87a22959c1b5796f149e1","modified":1489756015000},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1489756015000},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"7462c3017dae88e5f80ff308db0b95baf960c83f","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1489756015000},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/.DS_Store","hash":"b8e5951c497e1060bfccf7be197be3bad8cb1885","modified":1489759711000},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1489756015000},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1489756015000},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1489755991000},{"_id":"themes/hexo-theme-next/.git/logs/HEAD","hash":"7fec182c6bf2d6767deda48c343f2b458febc88f","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"b16fcbf0efd20c018d7545257a8533c497ea7647","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"cf0e192eedaa1a1bbbab9e7a7e6979c4e24cda31","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"911b99ba0445b2c07373128d87a4ef2eb7de341a","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1489756015000},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_components/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/refs/heads/master","hash":"533ae954cefa2c28a5098c31d0004dfe28d1b399","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"2d1075f4cabcb3956b7b84a8e210f5a66f0a5562","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/exturl.swig","hash":"8e20dd2078d7dfdf4a5a6daa142bb94d002300f5","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/localsearch.swig","hash":"f4dbd4c896e6510ded8ebe05394c28f8a86e71bf","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"28a7f84242ca816a6452a0a79669ca963d824607","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"e13c9ccf70d593bdf3b8cc1d768f595abd610e6e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/logs/refs/heads/master","hash":"7fec182c6bf2d6767deda48c343f2b458febc88f","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1489756015000},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"1eb34b9c1f6d541605ff23333eeb133e1c4daf17","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-db8380a31c84a7f5890f15e7f043256176657aa0.idx","hash":"cecc3655019d441a02821f72e3b0dd74238f2b30","modified":1489756014000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/logs/refs/remotes/origin/HEAD","hash":"7fec182c6bf2d6767deda48c343f2b458febc88f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"755b04edbbfbdd981a783edb09c9cc34cb79cea7","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"8c0276883398651336853d5ec0e9da267a00dd86","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"dd310c2d999185e881db007360176ee2f811df10","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1489756015000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1489756015000},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-db8380a31c84a7f5890f15e7f043256176657aa0.pack","hash":"56eadafb5345ec7707545df50f44c80058779c9c","modified":1489756014000}],"Category":[{"name":"Android","_id":"cjed06law0002sfjf5wqwekzw"},{"name":"android","_id":"cjed06lbx000lsfjfcdp0eq9f"},{"name":"工具","_id":"cjed06lcc0011sfjflpxed7om"},{"name":"iOS","_id":"cjed06lcm001hsfjfhm1ekoyb"},{"name":"Python","_id":"cjed06ld0001psfjfbubxea1o"},{"name":"Android快速打包","_id":"cjed06ldf0024sfjfngv39yug"},{"name":"打包","_id":"cjed06ldm002esfjfxpl1ooj2"}],"Data":[],"Page":[],"Post":[{"title":"AMS client端分析","date":"2017-07-31T16:00:00.000Z","_content":"\n# Activity启动理解\nPS：  \n一定要下载官方对应版本SDK，然后应用的SDK版本也要对应  \n建议配合GrepCode 查找类的位置，\n\n# 1. Android的CS模式\n\nAndroid启动是通过AtivityThread的main函数启动的，\n四大组件的生命周期都是通过AMS远程控制的，比如我们启动一个Acitivity,Service等都不是直接启动的，都是binder告诉AMS我们要启动四大组件，然后AMS通过binder处理（比如Activity A要启动Activity B，但是中途涉及到A的onpause  onStop和B 的oncreate，都是AMS依据ActivityRecord进行处理的）\n\n# 2. 三个核心部分\n## client端：\nActivityThread  \nActivityMangerNative   和ActivityManagerProxy  \nApplicationThread和ApplicationThreadNative  \n\n其实还涉及到：其它的比如 Instrumentation但是这个不是核心类\n\n## Server端\n\nApplicationThreadProxy  \nActivityMangerService  \nProcessRecord  \nActivityStack  \nActivityRecord  \n\n## 跨进程通讯Binder\nBinder 和 Parcel\n\n# 3. Activity A 启动Activity B的流程详解  \n\nps：  \nActivityMangerNative是往AMS发送消息的  \nApplicationThread是从AMS接受指令消息的\n\n\n\n## 1、Client发送Intent\nActivity#startActivity(Intent) >> Instrumentation#execStartActivity()  >>  \nActivityManagerNative#startActivity() >>\n\n## 2、AMS 查询栈，告诉要Pause\nActivityMangerNative#onTransact() >>    \n\nActivityMangerNative#schedulePauseActivity()这里是抽象的具体实现在\nActivityThread$ApplicationThread#schedulePauseActivity() >>   \n\nActivityThread#sendMessage() 也就是通过H mH 发送Message>>  \nActivityThread$H#handleMessage()>>    \nActivityThread#handlePauseActivity这里先要取出当前Activity ActivityClientRecord r = mActivities.get(token) >>\nActivityThread#performPauseActivity()>>    \n\nInstrumentation#callActivityOnPause >>\n\n ActivityManagerNative#activityPaused(token) 这个是在上一步Instrumentation pause完Activity后顺序执行的\n 这里也就是通过binder发送消息>>  \n \n \n \n PS:Activity切换要不要调用onstop 要看Theme，如果是android:style/Theme.Translucent就不会调用Onstop。所以我是不讲stop这个流程（实际上鄙人是有点懒。。。）\n ## 3、AMS正式启动 Activity B    \n ActivityMangerNative#onTransact() >>    \n\nActivityMangerNative#scheduleLaunchActivity()这里是抽象的具体实现在\nActivityThread$ApplicationThread#scheduleLaunchActivity() >>  \n\n经过H mH转到主线程里面\nActivityThread#handleLaunchActivity>> \n\nActivityThread#performLaunchActivity\n初始化Activity包括以下几步  \n1. 生成Activity B ，这里仅仅是生成简单的java类 \n \n       java.lang.ClassLoader cl = r.packageInfo.getClassLoader();\n                activity = mInstrumentation.newActivity(\n                        cl, component.getClassName(), r.intent);  \n\n2. 附加给Activity 各种Android系统类型\n \n        attach(Context context, ActivityThread aThread,\n            Instrumentation instr, IBinder token, int ident,\n            Application application, Intent intent, ActivityInfo info,\n            CharSequence title, Activity parent, String id,\n            NonConfigurationInstances lastNonConfigurationInstances,\n            Configuration config, String referrer, IVoiceInteractor voiceInteractor) \n\n3. 回调oncreate  注意这个地方不会通知AMS\n  \n        mInstrumentation.callActivityOnCreate(activity, r.state);  \n\n最终这个会调用到Activity的oncreate\n\n\n\nps：ActivityThread.H 的Message可以看看，就可以知道有哪些操作需要和AMS打交道 \n\n\n\n>> \n\nActivityThread#handleResumeActivity  \n这里会依次调用\n\n1. ActivityThread#performResumeActivity(token, clearHide)   \n2. ActivityManagerNative#willActivityBeVisible（）  \n告诉AMS Activity已经准备好了   \n3. ActivityManagerNative#activityResumed（）  \n告诉AMS Activity已经resumed\n\n\n在2、3步骤里面就是做Activity B的界面绘制工作:\n        \n        r.window = r.activity.getWindow();\n        View decor = r.window.getDecorView();\n        decor.setVisibility(View.INVISIBLE);\n        ViewManager wm = a.getWindowManager();\n        a.mDecor = decor;\n        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n        l.softInputMode |= forwardBit;\n        if (a.mVisibleFromClient) {\n            a.mWindowAdded = true;\n            wm.addView(decor, l);\n            }\n            \n            \n具体流程参考ActivityThread#handleResumeActivity()流程\n\n涉及到window，DecroView等\n        \n\n\n\n\n## AMS 通知显示Acitivity B已经Onresume，  \n然后就是和onpause一样的流程并且回调Activity的onResume\n\n\n\n\n \n \n \n\n\n\n\n\n\n\n\n\n\n\n# 4. 哪些是公用的，为hook做准备\n\n\n\n\n\n\n\n\n","source":"_posts/AMS浅析_01.md","raw":"title: AMS client端分析\ndate: 2017-8-1 \ncategories:\n- Android\ntags:\n- Android\n- AMS\n\n---\n\n# Activity启动理解\nPS：  \n一定要下载官方对应版本SDK，然后应用的SDK版本也要对应  \n建议配合GrepCode 查找类的位置，\n\n# 1. Android的CS模式\n\nAndroid启动是通过AtivityThread的main函数启动的，\n四大组件的生命周期都是通过AMS远程控制的，比如我们启动一个Acitivity,Service等都不是直接启动的，都是binder告诉AMS我们要启动四大组件，然后AMS通过binder处理（比如Activity A要启动Activity B，但是中途涉及到A的onpause  onStop和B 的oncreate，都是AMS依据ActivityRecord进行处理的）\n\n# 2. 三个核心部分\n## client端：\nActivityThread  \nActivityMangerNative   和ActivityManagerProxy  \nApplicationThread和ApplicationThreadNative  \n\n其实还涉及到：其它的比如 Instrumentation但是这个不是核心类\n\n## Server端\n\nApplicationThreadProxy  \nActivityMangerService  \nProcessRecord  \nActivityStack  \nActivityRecord  \n\n## 跨进程通讯Binder\nBinder 和 Parcel\n\n# 3. Activity A 启动Activity B的流程详解  \n\nps：  \nActivityMangerNative是往AMS发送消息的  \nApplicationThread是从AMS接受指令消息的\n\n\n\n## 1、Client发送Intent\nActivity#startActivity(Intent) >> Instrumentation#execStartActivity()  >>  \nActivityManagerNative#startActivity() >>\n\n## 2、AMS 查询栈，告诉要Pause\nActivityMangerNative#onTransact() >>    \n\nActivityMangerNative#schedulePauseActivity()这里是抽象的具体实现在\nActivityThread$ApplicationThread#schedulePauseActivity() >>   \n\nActivityThread#sendMessage() 也就是通过H mH 发送Message>>  \nActivityThread$H#handleMessage()>>    \nActivityThread#handlePauseActivity这里先要取出当前Activity ActivityClientRecord r = mActivities.get(token) >>\nActivityThread#performPauseActivity()>>    \n\nInstrumentation#callActivityOnPause >>\n\n ActivityManagerNative#activityPaused(token) 这个是在上一步Instrumentation pause完Activity后顺序执行的\n 这里也就是通过binder发送消息>>  \n \n \n \n PS:Activity切换要不要调用onstop 要看Theme，如果是android:style/Theme.Translucent就不会调用Onstop。所以我是不讲stop这个流程（实际上鄙人是有点懒。。。）\n ## 3、AMS正式启动 Activity B    \n ActivityMangerNative#onTransact() >>    \n\nActivityMangerNative#scheduleLaunchActivity()这里是抽象的具体实现在\nActivityThread$ApplicationThread#scheduleLaunchActivity() >>  \n\n经过H mH转到主线程里面\nActivityThread#handleLaunchActivity>> \n\nActivityThread#performLaunchActivity\n初始化Activity包括以下几步  \n1. 生成Activity B ，这里仅仅是生成简单的java类 \n \n       java.lang.ClassLoader cl = r.packageInfo.getClassLoader();\n                activity = mInstrumentation.newActivity(\n                        cl, component.getClassName(), r.intent);  \n\n2. 附加给Activity 各种Android系统类型\n \n        attach(Context context, ActivityThread aThread,\n            Instrumentation instr, IBinder token, int ident,\n            Application application, Intent intent, ActivityInfo info,\n            CharSequence title, Activity parent, String id,\n            NonConfigurationInstances lastNonConfigurationInstances,\n            Configuration config, String referrer, IVoiceInteractor voiceInteractor) \n\n3. 回调oncreate  注意这个地方不会通知AMS\n  \n        mInstrumentation.callActivityOnCreate(activity, r.state);  \n\n最终这个会调用到Activity的oncreate\n\n\n\nps：ActivityThread.H 的Message可以看看，就可以知道有哪些操作需要和AMS打交道 \n\n\n\n>> \n\nActivityThread#handleResumeActivity  \n这里会依次调用\n\n1. ActivityThread#performResumeActivity(token, clearHide)   \n2. ActivityManagerNative#willActivityBeVisible（）  \n告诉AMS Activity已经准备好了   \n3. ActivityManagerNative#activityResumed（）  \n告诉AMS Activity已经resumed\n\n\n在2、3步骤里面就是做Activity B的界面绘制工作:\n        \n        r.window = r.activity.getWindow();\n        View decor = r.window.getDecorView();\n        decor.setVisibility(View.INVISIBLE);\n        ViewManager wm = a.getWindowManager();\n        a.mDecor = decor;\n        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n        l.softInputMode |= forwardBit;\n        if (a.mVisibleFromClient) {\n            a.mWindowAdded = true;\n            wm.addView(decor, l);\n            }\n            \n            \n具体流程参考ActivityThread#handleResumeActivity()流程\n\n涉及到window，DecroView等\n        \n\n\n\n\n## AMS 通知显示Acitivity B已经Onresume，  \n然后就是和onpause一样的流程并且回调Activity的onResume\n\n\n\n\n \n \n \n\n\n\n\n\n\n\n\n\n\n\n# 4. 哪些是公用的，为hook做准备\n\n\n\n\n\n\n\n\n","slug":"AMS浅析_01","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lam0000sfjf5db2oz96","content":"<h1 id=\"Activity启动理解\"><a href=\"#Activity启动理解\" class=\"headerlink\" title=\"Activity启动理解\"></a>Activity启动理解</h1><p>PS：<br>一定要下载官方对应版本SDK，然后应用的SDK版本也要对应<br>建议配合GrepCode 查找类的位置，</p>\n<h1 id=\"1-Android的CS模式\"><a href=\"#1-Android的CS模式\" class=\"headerlink\" title=\"1. Android的CS模式\"></a>1. Android的CS模式</h1><p>Android启动是通过AtivityThread的main函数启动的，<br>四大组件的生命周期都是通过AMS远程控制的，比如我们启动一个Acitivity,Service等都不是直接启动的，都是binder告诉AMS我们要启动四大组件，然后AMS通过binder处理（比如Activity A要启动Activity B，但是中途涉及到A的onpause  onStop和B 的oncreate，都是AMS依据ActivityRecord进行处理的）</p>\n<h1 id=\"2-三个核心部分\"><a href=\"#2-三个核心部分\" class=\"headerlink\" title=\"2. 三个核心部分\"></a>2. 三个核心部分</h1><h2 id=\"client端：\"><a href=\"#client端：\" class=\"headerlink\" title=\"client端：\"></a>client端：</h2><p>ActivityThread<br>ActivityMangerNative   和ActivityManagerProxy<br>ApplicationThread和ApplicationThreadNative  </p>\n<p>其实还涉及到：其它的比如 Instrumentation但是这个不是核心类</p>\n<h2 id=\"Server端\"><a href=\"#Server端\" class=\"headerlink\" title=\"Server端\"></a>Server端</h2><p>ApplicationThreadProxy<br>ActivityMangerService<br>ProcessRecord<br>ActivityStack<br>ActivityRecord  </p>\n<h2 id=\"跨进程通讯Binder\"><a href=\"#跨进程通讯Binder\" class=\"headerlink\" title=\"跨进程通讯Binder\"></a>跨进程通讯Binder</h2><p>Binder 和 Parcel</p>\n<h1 id=\"3-Activity-A-启动Activity-B的流程详解\"><a href=\"#3-Activity-A-启动Activity-B的流程详解\" class=\"headerlink\" title=\"3. Activity A 启动Activity B的流程详解\"></a>3. Activity A 启动Activity B的流程详解</h1><p>ps：<br>ActivityMangerNative是往AMS发送消息的<br>ApplicationThread是从AMS接受指令消息的</p>\n<h2 id=\"1、Client发送Intent\"><a href=\"#1、Client发送Intent\" class=\"headerlink\" title=\"1、Client发送Intent\"></a>1、Client发送Intent</h2><p>Activity#startActivity(Intent) &gt;&gt; Instrumentation#execStartActivity()  &gt;&gt;<br>ActivityManagerNative#startActivity() &gt;&gt;</p>\n<h2 id=\"2、AMS-查询栈，告诉要Pause\"><a href=\"#2、AMS-查询栈，告诉要Pause\" class=\"headerlink\" title=\"2、AMS 查询栈，告诉要Pause\"></a>2、AMS 查询栈，告诉要Pause</h2><p>ActivityMangerNative#onTransact() &gt;&gt;    </p>\n<p>ActivityMangerNative#schedulePauseActivity()这里是抽象的具体实现在<br>ActivityThread$ApplicationThread#schedulePauseActivity() &gt;&gt;   </p>\n<p>ActivityThread#sendMessage() 也就是通过H mH 发送Message&gt;&gt;<br>ActivityThread$H#handleMessage()&gt;&gt;<br>ActivityThread#handlePauseActivity这里先要取出当前Activity ActivityClientRecord r = mActivities.get(token) &gt;&gt;<br>ActivityThread#performPauseActivity()&gt;&gt;    </p>\n<p>Instrumentation#callActivityOnPause &gt;&gt;</p>\n<p> ActivityManagerNative#activityPaused(token) 这个是在上一步Instrumentation pause完Activity后顺序执行的<br> 这里也就是通过binder发送消息&gt;&gt;  </p>\n<p> PS:Activity切换要不要调用onstop 要看Theme，如果是android:style/Theme.Translucent就不会调用Onstop。所以我是不讲stop这个流程（实际上鄙人是有点懒。。。）</p>\n<h2 id=\"3、AMS正式启动-Activity-B\"><a href=\"#3、AMS正式启动-Activity-B\" class=\"headerlink\" title=\"3、AMS正式启动 Activity B\"></a>3、AMS正式启动 Activity B</h2><p> ActivityMangerNative#onTransact() &gt;&gt;    </p>\n<p>ActivityMangerNative#scheduleLaunchActivity()这里是抽象的具体实现在<br>ActivityThread$ApplicationThread#scheduleLaunchActivity() &gt;&gt;  </p>\n<p>经过H mH转到主线程里面<br>ActivityThread#handleLaunchActivity&gt;&gt; </p>\n<p>ActivityThread#performLaunchActivity<br>初始化Activity包括以下几步  </p>\n<ol>\n<li><p>生成Activity B ，这里仅仅是生成简单的java类 </p>\n<pre><code>java.lang.ClassLoader cl = r.packageInfo.getClassLoader();\n         activity = mInstrumentation.newActivity(\n                 cl, component.getClassName(), r.intent);  \n</code></pre></li>\n<li><p>附加给Activity 各种Android系统类型</p>\n<pre><code>attach(Context context, ActivityThread aThread,\n    Instrumentation instr, IBinder token, int ident,\n    Application application, Intent intent, ActivityInfo info,\n    CharSequence title, Activity parent, String id,\n    NonConfigurationInstances lastNonConfigurationInstances,\n    Configuration config, String referrer, IVoiceInteractor voiceInteractor) \n</code></pre></li>\n<li><p>回调oncreate  注意这个地方不会通知AMS</p>\n<pre><code>mInstrumentation.callActivityOnCreate(activity, r.state);  \n</code></pre></li>\n</ol>\n<p>最终这个会调用到Activity的oncreate</p>\n<p>ps：ActivityThread.H 的Message可以看看，就可以知道有哪些操作需要和AMS打交道 </p>\n<blockquote>\n<blockquote>\n</blockquote>\n</blockquote>\n<p>ActivityThread#handleResumeActivity<br>这里会依次调用</p>\n<ol>\n<li>ActivityThread#performResumeActivity(token, clearHide)   </li>\n<li>ActivityManagerNative#willActivityBeVisible（）<br>告诉AMS Activity已经准备好了   </li>\n<li>ActivityManagerNative#activityResumed（）<br>告诉AMS Activity已经resumed</li>\n</ol>\n<p>在2、3步骤里面就是做Activity B的界面绘制工作:</p>\n<pre><code>r.window = r.activity.getWindow();\nView decor = r.window.getDecorView();\ndecor.setVisibility(View.INVISIBLE);\nViewManager wm = a.getWindowManager();\na.mDecor = decor;\nl.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\nl.softInputMode |= forwardBit;\nif (a.mVisibleFromClient) {\n    a.mWindowAdded = true;\n    wm.addView(decor, l);\n    }\n</code></pre><p>具体流程参考ActivityThread#handleResumeActivity()流程</p>\n<p>涉及到window，DecroView等</p>\n<h2 id=\"AMS-通知显示Acitivity-B已经Onresume，\"><a href=\"#AMS-通知显示Acitivity-B已经Onresume，\" class=\"headerlink\" title=\"AMS 通知显示Acitivity B已经Onresume，\"></a>AMS 通知显示Acitivity B已经Onresume，</h2><p>然后就是和onpause一样的流程并且回调Activity的onResume</p>\n<h1 id=\"4-哪些是公用的，为hook做准备\"><a href=\"#4-哪些是公用的，为hook做准备\" class=\"headerlink\" title=\"4. 哪些是公用的，为hook做准备\"></a>4. 哪些是公用的，为hook做准备</h1>","excerpt":"","more":"<h1 id=\"Activity启动理解\"><a href=\"#Activity启动理解\" class=\"headerlink\" title=\"Activity启动理解\"></a>Activity启动理解</h1><p>PS：<br>一定要下载官方对应版本SDK，然后应用的SDK版本也要对应<br>建议配合GrepCode 查找类的位置，</p>\n<h1 id=\"1-Android的CS模式\"><a href=\"#1-Android的CS模式\" class=\"headerlink\" title=\"1. Android的CS模式\"></a>1. Android的CS模式</h1><p>Android启动是通过AtivityThread的main函数启动的，<br>四大组件的生命周期都是通过AMS远程控制的，比如我们启动一个Acitivity,Service等都不是直接启动的，都是binder告诉AMS我们要启动四大组件，然后AMS通过binder处理（比如Activity A要启动Activity B，但是中途涉及到A的onpause  onStop和B 的oncreate，都是AMS依据ActivityRecord进行处理的）</p>\n<h1 id=\"2-三个核心部分\"><a href=\"#2-三个核心部分\" class=\"headerlink\" title=\"2. 三个核心部分\"></a>2. 三个核心部分</h1><h2 id=\"client端：\"><a href=\"#client端：\" class=\"headerlink\" title=\"client端：\"></a>client端：</h2><p>ActivityThread<br>ActivityMangerNative   和ActivityManagerProxy<br>ApplicationThread和ApplicationThreadNative  </p>\n<p>其实还涉及到：其它的比如 Instrumentation但是这个不是核心类</p>\n<h2 id=\"Server端\"><a href=\"#Server端\" class=\"headerlink\" title=\"Server端\"></a>Server端</h2><p>ApplicationThreadProxy<br>ActivityMangerService<br>ProcessRecord<br>ActivityStack<br>ActivityRecord  </p>\n<h2 id=\"跨进程通讯Binder\"><a href=\"#跨进程通讯Binder\" class=\"headerlink\" title=\"跨进程通讯Binder\"></a>跨进程通讯Binder</h2><p>Binder 和 Parcel</p>\n<h1 id=\"3-Activity-A-启动Activity-B的流程详解\"><a href=\"#3-Activity-A-启动Activity-B的流程详解\" class=\"headerlink\" title=\"3. Activity A 启动Activity B的流程详解\"></a>3. Activity A 启动Activity B的流程详解</h1><p>ps：<br>ActivityMangerNative是往AMS发送消息的<br>ApplicationThread是从AMS接受指令消息的</p>\n<h2 id=\"1、Client发送Intent\"><a href=\"#1、Client发送Intent\" class=\"headerlink\" title=\"1、Client发送Intent\"></a>1、Client发送Intent</h2><p>Activity#startActivity(Intent) &gt;&gt; Instrumentation#execStartActivity()  &gt;&gt;<br>ActivityManagerNative#startActivity() &gt;&gt;</p>\n<h2 id=\"2、AMS-查询栈，告诉要Pause\"><a href=\"#2、AMS-查询栈，告诉要Pause\" class=\"headerlink\" title=\"2、AMS 查询栈，告诉要Pause\"></a>2、AMS 查询栈，告诉要Pause</h2><p>ActivityMangerNative#onTransact() &gt;&gt;    </p>\n<p>ActivityMangerNative#schedulePauseActivity()这里是抽象的具体实现在<br>ActivityThread$ApplicationThread#schedulePauseActivity() &gt;&gt;   </p>\n<p>ActivityThread#sendMessage() 也就是通过H mH 发送Message&gt;&gt;<br>ActivityThread$H#handleMessage()&gt;&gt;<br>ActivityThread#handlePauseActivity这里先要取出当前Activity ActivityClientRecord r = mActivities.get(token) &gt;&gt;<br>ActivityThread#performPauseActivity()&gt;&gt;    </p>\n<p>Instrumentation#callActivityOnPause &gt;&gt;</p>\n<p> ActivityManagerNative#activityPaused(token) 这个是在上一步Instrumentation pause完Activity后顺序执行的<br> 这里也就是通过binder发送消息&gt;&gt;  </p>\n<p> PS:Activity切换要不要调用onstop 要看Theme，如果是android:style/Theme.Translucent就不会调用Onstop。所以我是不讲stop这个流程（实际上鄙人是有点懒。。。）</p>\n<h2 id=\"3、AMS正式启动-Activity-B\"><a href=\"#3、AMS正式启动-Activity-B\" class=\"headerlink\" title=\"3、AMS正式启动 Activity B\"></a>3、AMS正式启动 Activity B</h2><p> ActivityMangerNative#onTransact() &gt;&gt;    </p>\n<p>ActivityMangerNative#scheduleLaunchActivity()这里是抽象的具体实现在<br>ActivityThread$ApplicationThread#scheduleLaunchActivity() &gt;&gt;  </p>\n<p>经过H mH转到主线程里面<br>ActivityThread#handleLaunchActivity&gt;&gt; </p>\n<p>ActivityThread#performLaunchActivity<br>初始化Activity包括以下几步  </p>\n<ol>\n<li><p>生成Activity B ，这里仅仅是生成简单的java类 </p>\n<pre><code>java.lang.ClassLoader cl = r.packageInfo.getClassLoader();\n         activity = mInstrumentation.newActivity(\n                 cl, component.getClassName(), r.intent);  \n</code></pre></li>\n<li><p>附加给Activity 各种Android系统类型</p>\n<pre><code>attach(Context context, ActivityThread aThread,\n    Instrumentation instr, IBinder token, int ident,\n    Application application, Intent intent, ActivityInfo info,\n    CharSequence title, Activity parent, String id,\n    NonConfigurationInstances lastNonConfigurationInstances,\n    Configuration config, String referrer, IVoiceInteractor voiceInteractor) \n</code></pre></li>\n<li><p>回调oncreate  注意这个地方不会通知AMS</p>\n<pre><code>mInstrumentation.callActivityOnCreate(activity, r.state);  \n</code></pre></li>\n</ol>\n<p>最终这个会调用到Activity的oncreate</p>\n<p>ps：ActivityThread.H 的Message可以看看，就可以知道有哪些操作需要和AMS打交道 </p>\n<blockquote>\n<blockquote>\n</blockquote>\n</blockquote>\n<p>ActivityThread#handleResumeActivity<br>这里会依次调用</p>\n<ol>\n<li>ActivityThread#performResumeActivity(token, clearHide)   </li>\n<li>ActivityManagerNative#willActivityBeVisible（）<br>告诉AMS Activity已经准备好了   </li>\n<li>ActivityManagerNative#activityResumed（）<br>告诉AMS Activity已经resumed</li>\n</ol>\n<p>在2、3步骤里面就是做Activity B的界面绘制工作:</p>\n<pre><code>r.window = r.activity.getWindow();\nView decor = r.window.getDecorView();\ndecor.setVisibility(View.INVISIBLE);\nViewManager wm = a.getWindowManager();\na.mDecor = decor;\nl.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\nl.softInputMode |= forwardBit;\nif (a.mVisibleFromClient) {\n    a.mWindowAdded = true;\n    wm.addView(decor, l);\n    }\n</code></pre><p>具体流程参考ActivityThread#handleResumeActivity()流程</p>\n<p>涉及到window，DecroView等</p>\n<h2 id=\"AMS-通知显示Acitivity-B已经Onresume，\"><a href=\"#AMS-通知显示Acitivity-B已经Onresume，\" class=\"headerlink\" title=\"AMS 通知显示Acitivity B已经Onresume，\"></a>AMS 通知显示Acitivity B已经Onresume，</h2><p>然后就是和onpause一样的流程并且回调Activity的onResume</p>\n<h1 id=\"4-哪些是公用的，为hook做准备\"><a href=\"#4-哪些是公用的，为hook做准备\" class=\"headerlink\" title=\"4. 哪些是公用的，为hook做准备\"></a>4. 哪些是公用的，为hook做准备</h1>"},{"title":"AMS server端分析","date":"2017-08-02T16:00:00.000Z","_content":"\n\n\n# Ams  server端\n\n## 核心类：  \nActivityManagerNative是从Client接受binder 消息  \nApplicationThreadNative 是从AMS向Client发送指令  \nActivityStackSupervisor\nActivityStack就是存储ActivityRecord的容器，主要操作都是通过ActivityStackSupervisor来做的\n\nps:注意接IApplicationThread   \n\n    A. ApplicationThreadNative实现了一部分，ActivityMangerService继承ApplicationThreadNative,然后实现了剩余的    \n    B. ApplicationThreadNative.ApplicationThreadProxy完全实现了IApplicationThread\n## Activity A启动Activity B流程  \n\n## 1. Activity A启动Activity B流程  \n\nActivityManagerNative#onTransact（）>>   \nActivityManagerService#startActivity()>>    \nActivityManagerService#startActivityAsUser()>>   \nActivityStackSupervisor#startActivityMayWait()>>   \nActivityStack#resumeTopActivityLocked（）>>  \nActivityStack#startPausingLocked（）>>  \npause上一个Activity的调用方法\n\n     prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,  userLeaving, prev.configChangeFlags);\n\nActivityMangerNative.ApplicationThreadProxy.schedulePauseActivity  >>  \n）\n\n等client pause完了后\nActivityManagerNative#activityPaused（）  \n这里实际调用的是ActivityManagerService的activityPaused（）>>  \nActivityStack#completePauseLocked() >>  \nActivityStack#resumeTopActivityLocked（）>>  \nActivityStackSupervisor#resumeTopActivitiesLocked(topStack, prev, null);  \n\n这时候有两部分，如果当前应用还没有启动就通过Process  \n\n        if (app != null && app.thread != null) {\n            try {\n                app.addPackage(r.info.packageName, mService.mProcessStats);\n                realStartActivityLocked(r, app, andResume, checkConfig);\n                return;\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Exception when starting activity \"\n                        + r.intent.getComponent().flattenToShortString(), e);\n            }\n\n            // If a dead object exception was thrown -- fall through to\n            // restart the application.\n        }\n\n        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n    }\n\n### 1.1 在已有进程中启动\n\nActivityStackSupervisor#realStartActivityLocked（）>>  \n   \n        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n        System.identityHashCode(r), r.info,\n        new Configuration(mService.mConfiguration), r.compat,\n        app.repProcState, r.icicle, results, newIntents, !andResume,\n        mService.isNextTransitionForward(), profileFile, profileFd,profileAutoStop;  \n        \nActivityMangerNative.ApplicationThreadProxy.scheduleLaunchActivity  >>  \n\n\n\n### 1.2 App进程不存在，需要新建  \nActivityManagerService#startProcessLocked()>>      \n\n#### 1.2.1 fork一个新的进程的三个步骤：  \n①AMS通过Socket通信，向Zygote发送一个创建进程请求，Zygote创建新进程。  \n②创建好进程后，调用ActivityThread.main()。到此，我们到了新了一个进程中，也是程序的入口出。  \n③调用ActivityThread.attach()开始新的应用程序，接着同过Binder通信通知AMS，新的进程已经创建好了，可以开始新的程序了。  \n\n#### 1.2.2  ActivityManagerNative.attachApplication()  \nps：实际调用的是ActivityManagerService.attachApplication  \n①根据Binder.getCallingPid(),或得客户进程pid，并调用attachApplicationLocked(IApplicationThreadthread,int pid)  \n②在attachApplicationLocked中，根据pid找到对应的ProcessRecord对象，如果找不到说明改pid客户进程是一个没经过AMS允许的进程。  \n③为ProcessRecordapp对象内部变量赋值  \n④确保目标程序（APK）文件已经被转换为了odex文件。Android中安装程序是APK文件，实际上是一个zip文件。  \n⑤调用ActivityStack.realStartActivityLocked通知客户进程运行指定Activity.  \n⑥调用ApplicationThread.scheduleLaunchActivity，启动指定Activity。  \n\n#### 1.2.3 客户进程启动指定Activity  \nAMS通过IPC通行，通知客户进程启动指定Activity：  \n①调用ApplicationThread.scheduleLaunchActivity  \n②经过Handler消息传动，调用ActivityThread.handleLaunchActivity()  \n③调用ActivityThread.performLaunchActivity()完成Activity的加载，并最终调用Activity生命周期的onCreate()方法  \n④performLaunchActivity返回，继续调用ActivityThread.handleResumeActivity(),该方法内部又调用ActivityThread.performResumeActivity(),其内部仅仅调用了目标Activity的onResume()方法。到此Activity启动完成。  \n⑤添加一个IdleHandler对象，因为在一般情况下，该步骤执行完毕后，Activity就会进入空闲状态，所以就可以进行内存回收。  \n\n## 2. ActivityStack 、TaskRecord和ActivityRecord\n\n从ActivityStack#destroyActivityLocked（）>>     \n\nActivityStack#removeActivityFromHistoryLocked（）>>  \n\n    final TaskRecord task = r.task;\n    if (task != null && task.removeActivity(r)) {\n        if (DEBUG_STACK) Slog.i(TAG,\n                 \"removeActivityFromHistoryLocked: last activity removed from \" + this);\n         if (mStackSupervisor.isFrontStack(this) && task == topTask() && task.mOnTopOfHome) {\n              mStackSupervisor.moveHomeToTop();\n          }\n           mStackSupervisor.removeTask(task);\n      }\n     r.takeFromHistory()\n\n这里正式开始处理TaskRecord栈里面Activity记录\n\n","source":"_posts/AMS浅析_02.md","raw":"title: AMS server端分析\ndate: 2017-8-3 \ncategories:\n- Android\ntags:\n- Android\n- AMS\n\n---\n\n\n\n# Ams  server端\n\n## 核心类：  \nActivityManagerNative是从Client接受binder 消息  \nApplicationThreadNative 是从AMS向Client发送指令  \nActivityStackSupervisor\nActivityStack就是存储ActivityRecord的容器，主要操作都是通过ActivityStackSupervisor来做的\n\nps:注意接IApplicationThread   \n\n    A. ApplicationThreadNative实现了一部分，ActivityMangerService继承ApplicationThreadNative,然后实现了剩余的    \n    B. ApplicationThreadNative.ApplicationThreadProxy完全实现了IApplicationThread\n## Activity A启动Activity B流程  \n\n## 1. Activity A启动Activity B流程  \n\nActivityManagerNative#onTransact（）>>   \nActivityManagerService#startActivity()>>    \nActivityManagerService#startActivityAsUser()>>   \nActivityStackSupervisor#startActivityMayWait()>>   \nActivityStack#resumeTopActivityLocked（）>>  \nActivityStack#startPausingLocked（）>>  \npause上一个Activity的调用方法\n\n     prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,  userLeaving, prev.configChangeFlags);\n\nActivityMangerNative.ApplicationThreadProxy.schedulePauseActivity  >>  \n）\n\n等client pause完了后\nActivityManagerNative#activityPaused（）  \n这里实际调用的是ActivityManagerService的activityPaused（）>>  \nActivityStack#completePauseLocked() >>  \nActivityStack#resumeTopActivityLocked（）>>  \nActivityStackSupervisor#resumeTopActivitiesLocked(topStack, prev, null);  \n\n这时候有两部分，如果当前应用还没有启动就通过Process  \n\n        if (app != null && app.thread != null) {\n            try {\n                app.addPackage(r.info.packageName, mService.mProcessStats);\n                realStartActivityLocked(r, app, andResume, checkConfig);\n                return;\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Exception when starting activity \"\n                        + r.intent.getComponent().flattenToShortString(), e);\n            }\n\n            // If a dead object exception was thrown -- fall through to\n            // restart the application.\n        }\n\n        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n    }\n\n### 1.1 在已有进程中启动\n\nActivityStackSupervisor#realStartActivityLocked（）>>  \n   \n        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n        System.identityHashCode(r), r.info,\n        new Configuration(mService.mConfiguration), r.compat,\n        app.repProcState, r.icicle, results, newIntents, !andResume,\n        mService.isNextTransitionForward(), profileFile, profileFd,profileAutoStop;  \n        \nActivityMangerNative.ApplicationThreadProxy.scheduleLaunchActivity  >>  \n\n\n\n### 1.2 App进程不存在，需要新建  \nActivityManagerService#startProcessLocked()>>      \n\n#### 1.2.1 fork一个新的进程的三个步骤：  \n①AMS通过Socket通信，向Zygote发送一个创建进程请求，Zygote创建新进程。  \n②创建好进程后，调用ActivityThread.main()。到此，我们到了新了一个进程中，也是程序的入口出。  \n③调用ActivityThread.attach()开始新的应用程序，接着同过Binder通信通知AMS，新的进程已经创建好了，可以开始新的程序了。  \n\n#### 1.2.2  ActivityManagerNative.attachApplication()  \nps：实际调用的是ActivityManagerService.attachApplication  \n①根据Binder.getCallingPid(),或得客户进程pid，并调用attachApplicationLocked(IApplicationThreadthread,int pid)  \n②在attachApplicationLocked中，根据pid找到对应的ProcessRecord对象，如果找不到说明改pid客户进程是一个没经过AMS允许的进程。  \n③为ProcessRecordapp对象内部变量赋值  \n④确保目标程序（APK）文件已经被转换为了odex文件。Android中安装程序是APK文件，实际上是一个zip文件。  \n⑤调用ActivityStack.realStartActivityLocked通知客户进程运行指定Activity.  \n⑥调用ApplicationThread.scheduleLaunchActivity，启动指定Activity。  \n\n#### 1.2.3 客户进程启动指定Activity  \nAMS通过IPC通行，通知客户进程启动指定Activity：  \n①调用ApplicationThread.scheduleLaunchActivity  \n②经过Handler消息传动，调用ActivityThread.handleLaunchActivity()  \n③调用ActivityThread.performLaunchActivity()完成Activity的加载，并最终调用Activity生命周期的onCreate()方法  \n④performLaunchActivity返回，继续调用ActivityThread.handleResumeActivity(),该方法内部又调用ActivityThread.performResumeActivity(),其内部仅仅调用了目标Activity的onResume()方法。到此Activity启动完成。  \n⑤添加一个IdleHandler对象，因为在一般情况下，该步骤执行完毕后，Activity就会进入空闲状态，所以就可以进行内存回收。  \n\n## 2. ActivityStack 、TaskRecord和ActivityRecord\n\n从ActivityStack#destroyActivityLocked（）>>     \n\nActivityStack#removeActivityFromHistoryLocked（）>>  \n\n    final TaskRecord task = r.task;\n    if (task != null && task.removeActivity(r)) {\n        if (DEBUG_STACK) Slog.i(TAG,\n                 \"removeActivityFromHistoryLocked: last activity removed from \" + this);\n         if (mStackSupervisor.isFrontStack(this) && task == topTask() && task.mOnTopOfHome) {\n              mStackSupervisor.moveHomeToTop();\n          }\n           mStackSupervisor.removeTask(task);\n      }\n     r.takeFromHistory()\n\n这里正式开始处理TaskRecord栈里面Activity记录\n\n","slug":"AMS浅析_02","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lar0001sfjfgjmveyws","content":"<h1 id=\"Ams-server端\"><a href=\"#Ams-server端\" class=\"headerlink\" title=\"Ams  server端\"></a>Ams  server端</h1><h2 id=\"核心类：\"><a href=\"#核心类：\" class=\"headerlink\" title=\"核心类：\"></a>核心类：</h2><p>ActivityManagerNative是从Client接受binder 消息<br>ApplicationThreadNative 是从AMS向Client发送指令<br>ActivityStackSupervisor<br>ActivityStack就是存储ActivityRecord的容器，主要操作都是通过ActivityStackSupervisor来做的</p>\n<p>ps:注意接IApplicationThread   </p>\n<pre><code>A. ApplicationThreadNative实现了一部分，ActivityMangerService继承ApplicationThreadNative,然后实现了剩余的    \nB. ApplicationThreadNative.ApplicationThreadProxy完全实现了IApplicationThread\n</code></pre><h2 id=\"Activity-A启动Activity-B流程\"><a href=\"#Activity-A启动Activity-B流程\" class=\"headerlink\" title=\"Activity A启动Activity B流程\"></a>Activity A启动Activity B流程</h2><h2 id=\"1-Activity-A启动Activity-B流程\"><a href=\"#1-Activity-A启动Activity-B流程\" class=\"headerlink\" title=\"1. Activity A启动Activity B流程\"></a>1. Activity A启动Activity B流程</h2><p>ActivityManagerNative#onTransact（）&gt;&gt;<br>ActivityManagerService#startActivity()&gt;&gt;<br>ActivityManagerService#startActivityAsUser()&gt;&gt;<br>ActivityStackSupervisor#startActivityMayWait()&gt;&gt;<br>ActivityStack#resumeTopActivityLocked（）&gt;&gt;<br>ActivityStack#startPausingLocked（）&gt;&gt;<br>pause上一个Activity的调用方法</p>\n<pre><code>prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,  userLeaving, prev.configChangeFlags);\n</code></pre><p>ActivityMangerNative.ApplicationThreadProxy.schedulePauseActivity  &gt;&gt;<br>）</p>\n<p>等client pause完了后<br>ActivityManagerNative#activityPaused（）<br>这里实际调用的是ActivityManagerService的activityPaused（）&gt;&gt;<br>ActivityStack#completePauseLocked() &gt;&gt;<br>ActivityStack#resumeTopActivityLocked（）&gt;&gt;<br>ActivityStackSupervisor#resumeTopActivitiesLocked(topStack, prev, null);  </p>\n<p>这时候有两部分，如果当前应用还没有启动就通过Process  </p>\n<pre><code>    if (app != null &amp;&amp; app.thread != null) {\n        try {\n            app.addPackage(r.info.packageName, mService.mProcessStats);\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        } catch (RemoteException e) {\n            Slog.w(TAG, &quot;Exception when starting activity &quot;\n                    + r.intent.getComponent().flattenToShortString(), e);\n        }\n\n        // If a dead object exception was thrown -- fall through to\n        // restart the application.\n    }\n\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n            &quot;activity&quot;, r.intent.getComponent(), false, false, true);\n}\n</code></pre><h3 id=\"1-1-在已有进程中启动\"><a href=\"#1-1-在已有进程中启动\" class=\"headerlink\" title=\"1.1 在已有进程中启动\"></a>1.1 在已有进程中启动</h3><p>ActivityStackSupervisor#realStartActivityLocked（）&gt;&gt;  </p>\n<pre><code>app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\nSystem.identityHashCode(r), r.info,\nnew Configuration(mService.mConfiguration), r.compat,\napp.repProcState, r.icicle, results, newIntents, !andResume,\nmService.isNextTransitionForward(), profileFile, profileFd,profileAutoStop;  \n</code></pre><p>ActivityMangerNative.ApplicationThreadProxy.scheduleLaunchActivity  &gt;&gt;  </p>\n<h3 id=\"1-2-App进程不存在，需要新建\"><a href=\"#1-2-App进程不存在，需要新建\" class=\"headerlink\" title=\"1.2 App进程不存在，需要新建\"></a>1.2 App进程不存在，需要新建</h3><p>ActivityManagerService#startProcessLocked()&gt;&gt;      </p>\n<h4 id=\"1-2-1-fork一个新的进程的三个步骤：\"><a href=\"#1-2-1-fork一个新的进程的三个步骤：\" class=\"headerlink\" title=\"1.2.1 fork一个新的进程的三个步骤：\"></a>1.2.1 fork一个新的进程的三个步骤：</h4><p>①AMS通过Socket通信，向Zygote发送一个创建进程请求，Zygote创建新进程。<br>②创建好进程后，调用ActivityThread.main()。到此，我们到了新了一个进程中，也是程序的入口出。<br>③调用ActivityThread.attach()开始新的应用程序，接着同过Binder通信通知AMS，新的进程已经创建好了，可以开始新的程序了。  </p>\n<h4 id=\"1-2-2-ActivityManagerNative-attachApplication\"><a href=\"#1-2-2-ActivityManagerNative-attachApplication\" class=\"headerlink\" title=\"1.2.2  ActivityManagerNative.attachApplication()\"></a>1.2.2  ActivityManagerNative.attachApplication()</h4><p>ps：实际调用的是ActivityManagerService.attachApplication<br>①根据Binder.getCallingPid(),或得客户进程pid，并调用attachApplicationLocked(IApplicationThreadthread,int pid)<br>②在attachApplicationLocked中，根据pid找到对应的ProcessRecord对象，如果找不到说明改pid客户进程是一个没经过AMS允许的进程。<br>③为ProcessRecordapp对象内部变量赋值<br>④确保目标程序（APK）文件已经被转换为了odex文件。Android中安装程序是APK文件，实际上是一个zip文件。<br>⑤调用ActivityStack.realStartActivityLocked通知客户进程运行指定Activity.<br>⑥调用ApplicationThread.scheduleLaunchActivity，启动指定Activity。  </p>\n<h4 id=\"1-2-3-客户进程启动指定Activity\"><a href=\"#1-2-3-客户进程启动指定Activity\" class=\"headerlink\" title=\"1.2.3 客户进程启动指定Activity\"></a>1.2.3 客户进程启动指定Activity</h4><p>AMS通过IPC通行，通知客户进程启动指定Activity：<br>①调用ApplicationThread.scheduleLaunchActivity<br>②经过Handler消息传动，调用ActivityThread.handleLaunchActivity()<br>③调用ActivityThread.performLaunchActivity()完成Activity的加载，并最终调用Activity生命周期的onCreate()方法<br>④performLaunchActivity返回，继续调用ActivityThread.handleResumeActivity(),该方法内部又调用ActivityThread.performResumeActivity(),其内部仅仅调用了目标Activity的onResume()方法。到此Activity启动完成。<br>⑤添加一个IdleHandler对象，因为在一般情况下，该步骤执行完毕后，Activity就会进入空闲状态，所以就可以进行内存回收。  </p>\n<h2 id=\"2-ActivityStack-、TaskRecord和ActivityRecord\"><a href=\"#2-ActivityStack-、TaskRecord和ActivityRecord\" class=\"headerlink\" title=\"2. ActivityStack 、TaskRecord和ActivityRecord\"></a>2. ActivityStack 、TaskRecord和ActivityRecord</h2><p>从ActivityStack#destroyActivityLocked（）&gt;&gt;     </p>\n<p>ActivityStack#removeActivityFromHistoryLocked（）&gt;&gt;  </p>\n<pre><code>final TaskRecord task = r.task;\nif (task != null &amp;&amp; task.removeActivity(r)) {\n    if (DEBUG_STACK) Slog.i(TAG,\n             &quot;removeActivityFromHistoryLocked: last activity removed from &quot; + this);\n     if (mStackSupervisor.isFrontStack(this) &amp;&amp; task == topTask() &amp;&amp; task.mOnTopOfHome) {\n          mStackSupervisor.moveHomeToTop();\n      }\n       mStackSupervisor.removeTask(task);\n  }\n r.takeFromHistory()\n</code></pre><p>这里正式开始处理TaskRecord栈里面Activity记录</p>\n","excerpt":"","more":"<h1 id=\"Ams-server端\"><a href=\"#Ams-server端\" class=\"headerlink\" title=\"Ams  server端\"></a>Ams  server端</h1><h2 id=\"核心类：\"><a href=\"#核心类：\" class=\"headerlink\" title=\"核心类：\"></a>核心类：</h2><p>ActivityManagerNative是从Client接受binder 消息<br>ApplicationThreadNative 是从AMS向Client发送指令<br>ActivityStackSupervisor<br>ActivityStack就是存储ActivityRecord的容器，主要操作都是通过ActivityStackSupervisor来做的</p>\n<p>ps:注意接IApplicationThread   </p>\n<pre><code>A. ApplicationThreadNative实现了一部分，ActivityMangerService继承ApplicationThreadNative,然后实现了剩余的    \nB. ApplicationThreadNative.ApplicationThreadProxy完全实现了IApplicationThread\n</code></pre><h2 id=\"Activity-A启动Activity-B流程\"><a href=\"#Activity-A启动Activity-B流程\" class=\"headerlink\" title=\"Activity A启动Activity B流程\"></a>Activity A启动Activity B流程</h2><h2 id=\"1-Activity-A启动Activity-B流程\"><a href=\"#1-Activity-A启动Activity-B流程\" class=\"headerlink\" title=\"1. Activity A启动Activity B流程\"></a>1. Activity A启动Activity B流程</h2><p>ActivityManagerNative#onTransact（）&gt;&gt;<br>ActivityManagerService#startActivity()&gt;&gt;<br>ActivityManagerService#startActivityAsUser()&gt;&gt;<br>ActivityStackSupervisor#startActivityMayWait()&gt;&gt;<br>ActivityStack#resumeTopActivityLocked（）&gt;&gt;<br>ActivityStack#startPausingLocked（）&gt;&gt;<br>pause上一个Activity的调用方法</p>\n<pre><code>prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,  userLeaving, prev.configChangeFlags);\n</code></pre><p>ActivityMangerNative.ApplicationThreadProxy.schedulePauseActivity  &gt;&gt;<br>）</p>\n<p>等client pause完了后<br>ActivityManagerNative#activityPaused（）<br>这里实际调用的是ActivityManagerService的activityPaused（）&gt;&gt;<br>ActivityStack#completePauseLocked() &gt;&gt;<br>ActivityStack#resumeTopActivityLocked（）&gt;&gt;<br>ActivityStackSupervisor#resumeTopActivitiesLocked(topStack, prev, null);  </p>\n<p>这时候有两部分，如果当前应用还没有启动就通过Process  </p>\n<pre><code>    if (app != null &amp;&amp; app.thread != null) {\n        try {\n            app.addPackage(r.info.packageName, mService.mProcessStats);\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        } catch (RemoteException e) {\n            Slog.w(TAG, &quot;Exception when starting activity &quot;\n                    + r.intent.getComponent().flattenToShortString(), e);\n        }\n\n        // If a dead object exception was thrown -- fall through to\n        // restart the application.\n    }\n\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n            &quot;activity&quot;, r.intent.getComponent(), false, false, true);\n}\n</code></pre><h3 id=\"1-1-在已有进程中启动\"><a href=\"#1-1-在已有进程中启动\" class=\"headerlink\" title=\"1.1 在已有进程中启动\"></a>1.1 在已有进程中启动</h3><p>ActivityStackSupervisor#realStartActivityLocked（）&gt;&gt;  </p>\n<pre><code>app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\nSystem.identityHashCode(r), r.info,\nnew Configuration(mService.mConfiguration), r.compat,\napp.repProcState, r.icicle, results, newIntents, !andResume,\nmService.isNextTransitionForward(), profileFile, profileFd,profileAutoStop;  \n</code></pre><p>ActivityMangerNative.ApplicationThreadProxy.scheduleLaunchActivity  &gt;&gt;  </p>\n<h3 id=\"1-2-App进程不存在，需要新建\"><a href=\"#1-2-App进程不存在，需要新建\" class=\"headerlink\" title=\"1.2 App进程不存在，需要新建\"></a>1.2 App进程不存在，需要新建</h3><p>ActivityManagerService#startProcessLocked()&gt;&gt;      </p>\n<h4 id=\"1-2-1-fork一个新的进程的三个步骤：\"><a href=\"#1-2-1-fork一个新的进程的三个步骤：\" class=\"headerlink\" title=\"1.2.1 fork一个新的进程的三个步骤：\"></a>1.2.1 fork一个新的进程的三个步骤：</h4><p>①AMS通过Socket通信，向Zygote发送一个创建进程请求，Zygote创建新进程。<br>②创建好进程后，调用ActivityThread.main()。到此，我们到了新了一个进程中，也是程序的入口出。<br>③调用ActivityThread.attach()开始新的应用程序，接着同过Binder通信通知AMS，新的进程已经创建好了，可以开始新的程序了。  </p>\n<h4 id=\"1-2-2-ActivityManagerNative-attachApplication\"><a href=\"#1-2-2-ActivityManagerNative-attachApplication\" class=\"headerlink\" title=\"1.2.2  ActivityManagerNative.attachApplication()\"></a>1.2.2  ActivityManagerNative.attachApplication()</h4><p>ps：实际调用的是ActivityManagerService.attachApplication<br>①根据Binder.getCallingPid(),或得客户进程pid，并调用attachApplicationLocked(IApplicationThreadthread,int pid)<br>②在attachApplicationLocked中，根据pid找到对应的ProcessRecord对象，如果找不到说明改pid客户进程是一个没经过AMS允许的进程。<br>③为ProcessRecordapp对象内部变量赋值<br>④确保目标程序（APK）文件已经被转换为了odex文件。Android中安装程序是APK文件，实际上是一个zip文件。<br>⑤调用ActivityStack.realStartActivityLocked通知客户进程运行指定Activity.<br>⑥调用ApplicationThread.scheduleLaunchActivity，启动指定Activity。  </p>\n<h4 id=\"1-2-3-客户进程启动指定Activity\"><a href=\"#1-2-3-客户进程启动指定Activity\" class=\"headerlink\" title=\"1.2.3 客户进程启动指定Activity\"></a>1.2.3 客户进程启动指定Activity</h4><p>AMS通过IPC通行，通知客户进程启动指定Activity：<br>①调用ApplicationThread.scheduleLaunchActivity<br>②经过Handler消息传动，调用ActivityThread.handleLaunchActivity()<br>③调用ActivityThread.performLaunchActivity()完成Activity的加载，并最终调用Activity生命周期的onCreate()方法<br>④performLaunchActivity返回，继续调用ActivityThread.handleResumeActivity(),该方法内部又调用ActivityThread.performResumeActivity(),其内部仅仅调用了目标Activity的onResume()方法。到此Activity启动完成。<br>⑤添加一个IdleHandler对象，因为在一般情况下，该步骤执行完毕后，Activity就会进入空闲状态，所以就可以进行内存回收。  </p>\n<h2 id=\"2-ActivityStack-、TaskRecord和ActivityRecord\"><a href=\"#2-ActivityStack-、TaskRecord和ActivityRecord\" class=\"headerlink\" title=\"2. ActivityStack 、TaskRecord和ActivityRecord\"></a>2. ActivityStack 、TaskRecord和ActivityRecord</h2><p>从ActivityStack#destroyActivityLocked（）&gt;&gt;     </p>\n<p>ActivityStack#removeActivityFromHistoryLocked（）&gt;&gt;  </p>\n<pre><code>final TaskRecord task = r.task;\nif (task != null &amp;&amp; task.removeActivity(r)) {\n    if (DEBUG_STACK) Slog.i(TAG,\n             &quot;removeActivityFromHistoryLocked: last activity removed from &quot; + this);\n     if (mStackSupervisor.isFrontStack(this) &amp;&amp; task == topTask() &amp;&amp; task.mOnTopOfHome) {\n          mStackSupervisor.moveHomeToTop();\n      }\n       mStackSupervisor.removeTask(task);\n  }\n r.takeFromHistory()\n</code></pre><p>这里正式开始处理TaskRecord栈里面Activity记录</p>\n"},{"title":"AS工程导入","date":"2015-11-01T12:10:33.000Z","_content":"\n# 1.工程导入\n## 1.1 普通eclipse  工程导入\n直接import，AS会提示转成eclipse工程\n## 1.2 github上的工程导入  \n用AS打开top level的settings.gradle选择进行配置导入   \nps：如果这一步直接导入的话就会报   Could not find method android() for arguments   \n\n可能遇到的问题：  \n\n1. 配置sdk位置（顶层build.gradle同级）\nlocal.properties（建议从已有工程拷贝一个）  \nsdk.dir=/Users/lyc/codeTools/android-sdk  \n\n2. 配置模块的build.gradle的gradletoolVersion版本\nbuildToolsVersion '23.0.2'\n\n建议从已有工程的里面找一个可用的版本填上去\n\n查看自己已经有哪些版本的buildTools的方法，\n\n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B01.png?raw=true)  \n\n3. modle配置模块的工程compileSdkVersionversion\n为一个已有版本的\n\n \n\n\n4. 配置\ndependencies中的com.android.support的版本，要求是于compileSdkVersionversion的版本一直\n，但是这个不好处理\n\ncompile 'com.android.support:design:25.1.1'\ncompile 'com.android.support:appcompat-v7:25.1.1'\ncompile 'com.android.support:cardview-v7:25.1.1'\n\n英文有子序列号\n建议按照以下方法写\ncompile 'com.android.support:cardview-v7:25.+'\n这样就会取本版本号下面最大的一个\n\n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B02.png?raw=true)   \n\n5.配置本地Gradel版本  \n这个常见于直接从别人那里拷贝的工程（也就是带有gradle/wrapper/**）的工程\n\n    distributionBase=GRADLE_USER_HOME\n    distributionPath=wrapper/dists\n    zipStoreBase=GRADLE_USER_HOME\n    zipStorePath=wrapper/dists\n    distributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip \ngradle会去找这个版本的gradle，如果找不到就会重新下载  \ngradle的默认下载目录在用户目录的.gradle/wrapper/dists文件夹中（隐藏的）  里面会有所有已经下载的gradle 版本，可以把它改成一个已经有的版本就行\n\n## 1.3 本地工程导入  \n直接import\n\n\n\n\n","source":"_posts/AS导入工程配置.md","raw":"title: AS工程导入\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n---\n\n# 1.工程导入\n## 1.1 普通eclipse  工程导入\n直接import，AS会提示转成eclipse工程\n## 1.2 github上的工程导入  \n用AS打开top level的settings.gradle选择进行配置导入   \nps：如果这一步直接导入的话就会报   Could not find method android() for arguments   \n\n可能遇到的问题：  \n\n1. 配置sdk位置（顶层build.gradle同级）\nlocal.properties（建议从已有工程拷贝一个）  \nsdk.dir=/Users/lyc/codeTools/android-sdk  \n\n2. 配置模块的build.gradle的gradletoolVersion版本\nbuildToolsVersion '23.0.2'\n\n建议从已有工程的里面找一个可用的版本填上去\n\n查看自己已经有哪些版本的buildTools的方法，\n\n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B01.png?raw=true)  \n\n3. modle配置模块的工程compileSdkVersionversion\n为一个已有版本的\n\n \n\n\n4. 配置\ndependencies中的com.android.support的版本，要求是于compileSdkVersionversion的版本一直\n，但是这个不好处理\n\ncompile 'com.android.support:design:25.1.1'\ncompile 'com.android.support:appcompat-v7:25.1.1'\ncompile 'com.android.support:cardview-v7:25.1.1'\n\n英文有子序列号\n建议按照以下方法写\ncompile 'com.android.support:cardview-v7:25.+'\n这样就会取本版本号下面最大的一个\n\n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B02.png?raw=true)   \n\n5.配置本地Gradel版本  \n这个常见于直接从别人那里拷贝的工程（也就是带有gradle/wrapper/**）的工程\n\n    distributionBase=GRADLE_USER_HOME\n    distributionPath=wrapper/dists\n    zipStoreBase=GRADLE_USER_HOME\n    zipStorePath=wrapper/dists\n    distributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip \ngradle会去找这个版本的gradle，如果找不到就会重新下载  \ngradle的默认下载目录在用户目录的.gradle/wrapper/dists文件夹中（隐藏的）  里面会有所有已经下载的gradle 版本，可以把它改成一个已经有的版本就行\n\n## 1.3 本地工程导入  \n直接import\n\n\n\n\n","slug":"AS导入工程配置","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06laz0004sfjf59mm7ayd","content":"<h1 id=\"1-工程导入\"><a href=\"#1-工程导入\" class=\"headerlink\" title=\"1.工程导入\"></a>1.工程导入</h1><h2 id=\"1-1-普通eclipse-工程导入\"><a href=\"#1-1-普通eclipse-工程导入\" class=\"headerlink\" title=\"1.1 普通eclipse  工程导入\"></a>1.1 普通eclipse  工程导入</h2><p>直接import，AS会提示转成eclipse工程</p>\n<h2 id=\"1-2-github上的工程导入\"><a href=\"#1-2-github上的工程导入\" class=\"headerlink\" title=\"1.2 github上的工程导入\"></a>1.2 github上的工程导入</h2><p>用AS打开top level的settings.gradle选择进行配置导入<br>ps：如果这一步直接导入的话就会报   Could not find method android() for arguments   </p>\n<p>可能遇到的问题：  </p>\n<ol>\n<li><p>配置sdk位置（顶层build.gradle同级）<br>local.properties（建议从已有工程拷贝一个）<br>sdk.dir=/Users/lyc/codeTools/android-sdk  </p>\n</li>\n<li><p>配置模块的build.gradle的gradletoolVersion版本<br>buildToolsVersion ‘23.0.2’</p>\n</li>\n</ol>\n<p>建议从已有工程的里面找一个可用的版本填上去</p>\n<p>查看自己已经有哪些版本的buildTools的方法，</p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B01.png?raw=true\" alt=\"see\">  </p>\n<ol>\n<li>modle配置模块的工程compileSdkVersionversion<br>为一个已有版本的</li>\n</ol>\n<ol>\n<li>配置<br>dependencies中的com.android.support的版本，要求是于compileSdkVersionversion的版本一直<br>，但是这个不好处理</li>\n</ol>\n<p>compile ‘com.android.support:design:25.1.1’<br>compile ‘com.android.support:appcompat-v7:25.1.1’<br>compile ‘com.android.support:cardview-v7:25.1.1’</p>\n<p>英文有子序列号<br>建议按照以下方法写<br>compile ‘com.android.support:cardview-v7:25.+’<br>这样就会取本版本号下面最大的一个</p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B02.png?raw=true\" alt=\"see\">   </p>\n<p>5.配置本地Gradel版本<br>这个常见于直接从别人那里拷贝的工程（也就是带有gradle/wrapper/**）的工程</p>\n<pre><code>distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip \n</code></pre><p>gradle会去找这个版本的gradle，如果找不到就会重新下载<br>gradle的默认下载目录在用户目录的.gradle/wrapper/dists文件夹中（隐藏的）  里面会有所有已经下载的gradle 版本，可以把它改成一个已经有的版本就行</p>\n<h2 id=\"1-3-本地工程导入\"><a href=\"#1-3-本地工程导入\" class=\"headerlink\" title=\"1.3 本地工程导入\"></a>1.3 本地工程导入</h2><p>直接import</p>\n","excerpt":"","more":"<h1 id=\"1-工程导入\"><a href=\"#1-工程导入\" class=\"headerlink\" title=\"1.工程导入\"></a>1.工程导入</h1><h2 id=\"1-1-普通eclipse-工程导入\"><a href=\"#1-1-普通eclipse-工程导入\" class=\"headerlink\" title=\"1.1 普通eclipse  工程导入\"></a>1.1 普通eclipse  工程导入</h2><p>直接import，AS会提示转成eclipse工程</p>\n<h2 id=\"1-2-github上的工程导入\"><a href=\"#1-2-github上的工程导入\" class=\"headerlink\" title=\"1.2 github上的工程导入\"></a>1.2 github上的工程导入</h2><p>用AS打开top level的settings.gradle选择进行配置导入<br>ps：如果这一步直接导入的话就会报   Could not find method android() for arguments   </p>\n<p>可能遇到的问题：  </p>\n<ol>\n<li><p>配置sdk位置（顶层build.gradle同级）<br>local.properties（建议从已有工程拷贝一个）<br>sdk.dir=/Users/lyc/codeTools/android-sdk  </p>\n</li>\n<li><p>配置模块的build.gradle的gradletoolVersion版本<br>buildToolsVersion ‘23.0.2’</p>\n</li>\n</ol>\n<p>建议从已有工程的里面找一个可用的版本填上去</p>\n<p>查看自己已经有哪些版本的buildTools的方法，</p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B01.png?raw=true\" alt=\"see\">  </p>\n<ol>\n<li>modle配置模块的工程compileSdkVersionversion<br>为一个已有版本的</li>\n</ol>\n<ol>\n<li>配置<br>dependencies中的com.android.support的版本，要求是于compileSdkVersionversion的版本一直<br>，但是这个不好处理</li>\n</ol>\n<p>compile ‘com.android.support:design:25.1.1’<br>compile ‘com.android.support:appcompat-v7:25.1.1’<br>compile ‘com.android.support:cardview-v7:25.1.1’</p>\n<p>英文有子序列号<br>建议按照以下方法写<br>compile ‘com.android.support:cardview-v7:25.+’<br>这样就会取本版本号下面最大的一个</p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B02.png?raw=true\" alt=\"see\">   </p>\n<p>5.配置本地Gradel版本<br>这个常见于直接从别人那里拷贝的工程（也就是带有gradle/wrapper/**）的工程</p>\n<pre><code>distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip \n</code></pre><p>gradle会去找这个版本的gradle，如果找不到就会重新下载<br>gradle的默认下载目录在用户目录的.gradle/wrapper/dists文件夹中（隐藏的）  里面会有所有已经下载的gradle 版本，可以把它改成一个已经有的版本就行</p>\n<h2 id=\"1-3-本地工程导入\"><a href=\"#1-3-本地工程导入\" class=\"headerlink\" title=\"1.3 本地工程导入\"></a>1.3 本地工程导入</h2><p>直接import</p>\n"},{"title":"Android分包","date":"2015-11-01T12:10:33.000Z","_content":"\n## 第一步：  gradle引入以及配置\n\n        compile 'com.android.support:multidex:1.0.1'\n\n        defaultConfig {\n            minSdkVersion 14\n            targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n            versionCode 5210\n            versionName \"5.2.1\"\n            //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:\"googleMarket\" ]\n            multiDexEnabled true\n            multiDexKeepProguard file('multiDexKeep.pro')\n            // resConfigs \"en\", \"zh_CN\", \"zh_TW\" 暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n        }\n\n## 第二步：修改Application  \n\n        @Override\n        protected void attachBaseContext(Context base) {\n            super.attachBaseContext(base);\n            MultiDex.install(base);\n        }\n\n## 第三步：保证关键类在主dex中 \n\n 就是通过multiDexKeep.pro文件控制的  \n 个推 sdk强制在主dex 中\n\n        -dontwarn com.igexin.**\n        -keep class com.igexin.**{*;}\n","source":"_posts/Android分包.md","raw":"title: Android分包\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n- 打包\n---\n\n## 第一步：  gradle引入以及配置\n\n        compile 'com.android.support:multidex:1.0.1'\n\n        defaultConfig {\n            minSdkVersion 14\n            targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n            versionCode 5210\n            versionName \"5.2.1\"\n            //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:\"googleMarket\" ]\n            multiDexEnabled true\n            multiDexKeepProguard file('multiDexKeep.pro')\n            // resConfigs \"en\", \"zh_CN\", \"zh_TW\" 暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n        }\n\n## 第二步：修改Application  \n\n        @Override\n        protected void attachBaseContext(Context base) {\n            super.attachBaseContext(base);\n            MultiDex.install(base);\n        }\n\n## 第三步：保证关键类在主dex中 \n\n 就是通过multiDexKeep.pro文件控制的  \n 个推 sdk强制在主dex 中\n\n        -dontwarn com.igexin.**\n        -keep class com.igexin.**{*;}\n","slug":"Android分包","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lb10005sfjf6ijgd6pt","content":"<h2 id=\"第一步：-gradle引入以及配置\"><a href=\"#第一步：-gradle引入以及配置\" class=\"headerlink\" title=\"第一步：  gradle引入以及配置\"></a>第一步：  gradle引入以及配置</h2><pre><code>compile &apos;com.android.support:multidex:1.0.1&apos;\n\ndefaultConfig {\n    minSdkVersion 14\n    targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n    versionCode 5210\n    versionName &quot;5.2.1&quot;\n    //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:&quot;googleMarket&quot; ]\n    multiDexEnabled true\n    multiDexKeepProguard file(&apos;multiDexKeep.pro&apos;)\n    // resConfigs &quot;en&quot;, &quot;zh_CN&quot;, &quot;zh_TW&quot; 暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n}\n</code></pre><h2 id=\"第二步：修改Application\"><a href=\"#第二步：修改Application\" class=\"headerlink\" title=\"第二步：修改Application\"></a>第二步：修改Application</h2><pre><code>@Override\nprotected void attachBaseContext(Context base) {\n    super.attachBaseContext(base);\n    MultiDex.install(base);\n}\n</code></pre><h2 id=\"第三步：保证关键类在主dex中\"><a href=\"#第三步：保证关键类在主dex中\" class=\"headerlink\" title=\"第三步：保证关键类在主dex中\"></a>第三步：保证关键类在主dex中</h2><p> 就是通过multiDexKeep.pro文件控制的<br> 个推 sdk强制在主dex 中</p>\n<pre><code>-dontwarn com.igexin.**\n-keep class com.igexin.**{*;}\n</code></pre>","excerpt":"","more":"<h2 id=\"第一步：-gradle引入以及配置\"><a href=\"#第一步：-gradle引入以及配置\" class=\"headerlink\" title=\"第一步：  gradle引入以及配置\"></a>第一步：  gradle引入以及配置</h2><pre><code>compile &apos;com.android.support:multidex:1.0.1&apos;\n\ndefaultConfig {\n    minSdkVersion 14\n    targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n    versionCode 5210\n    versionName &quot;5.2.1&quot;\n    //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:&quot;googleMarket&quot; ]\n    multiDexEnabled true\n    multiDexKeepProguard file(&apos;multiDexKeep.pro&apos;)\n    // resConfigs &quot;en&quot;, &quot;zh_CN&quot;, &quot;zh_TW&quot; 暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n}\n</code></pre><h2 id=\"第二步：修改Application\"><a href=\"#第二步：修改Application\" class=\"headerlink\" title=\"第二步：修改Application\"></a>第二步：修改Application</h2><pre><code>@Override\nprotected void attachBaseContext(Context base) {\n    super.attachBaseContext(base);\n    MultiDex.install(base);\n}\n</code></pre><h2 id=\"第三步：保证关键类在主dex中\"><a href=\"#第三步：保证关键类在主dex中\" class=\"headerlink\" title=\"第三步：保证关键类在主dex中\"></a>第三步：保证关键类在主dex中</h2><p> 就是通过multiDexKeep.pro文件控制的<br> 个推 sdk强制在主dex 中</p>\n<pre><code>-dontwarn com.igexin.**\n-keep class com.igexin.**{*;}\n</code></pre>"},{"title":"Android模块化方案","date":"2015-11-01T12:10:33.000Z","_content":"\n## AAR模块化方案  \n1、首先 按照应用分层（common  view），注意每个module最好配置一下resourcePrefix \"mc_\"  \n2、上层再按照功能模块比如  信用卡和个人中心\n\n这样每个都会打出一个aar，府工程引入所有的aar就可以引入这个模块\n\n## 问题\n但是这个距离一个可以发布出去的aar还有距离，有以下几个问题需要解决：  \n1. 本地jar依赖（主工程很有可能也公用这个jar）；  \n2. 混淆的问题；  \n3. 多个aar合并；   \n4. 兄弟模块互相调用，基模块调用父模块的方法；\n\n\n### 问题1:  \nAndroid dependency的几种方法：\neg：  \n\n        testCompile 'junit:junit:4.12'\n    //compile fileTree(dir: 'libs', include: ['*.jar'])  \n    provided fileTree(dir: 'libs',include: ['*.jar'])  \n    compile 'com.android.support:support-v4:23.0.1'  \n    compile project(':Module_common')   \n- testCompile ：  debug 会编译  正式打包不会编译\n- compile ： 除去\"compile jar\"会编译进arr，其余的都不会编译进去\n- provided：编译时候不会把jar编译进去\n\n传递依赖的问题\n（例如 modle A 依赖 Module B，Module B 又依赖Module  C ）   jar  都放在C里面，Module A不引入jar 也能引用到jar。\n\n但是正式打包时候不需要这些jar，本地的jar必须以provided方式引入，这样aar里面就不会打进去这些jar了。\n\n这会引入另外一个问题：C改成provide 这些jar后，A和B找不到这些依赖的jar 会编译失败\n\n解决方案：\n把jar单独成一个module D，写成provided\n（也可在module A  和 B里面  把这些jar 都拷贝进去，然后统统写成provided）\n\n### 问题2\n\n首先要明白，我们要去混淆的是A和主工程的接口，而A和B以及C直接的调用都需要混淆，但是不能在B和C里面混淆，因为这样一混淆的话，A与B、C调用的接口也混淆了\n\n所以混淆只能在A里面打开，A和B都不能打开混淆\n\n### 问题3\n默认会打出三个aar，但是我们只能发布一个aar出去，所以必须使用到 https://github.com/adwiv/android-fat-aar 写的合并aar的gradle\n\n方法：  \n1、拷贝 fat-aar.gradle到build.gradle 同级目录\n2、module的build.gradle新增  \napply from: 'fat-aar.gradle'  ，\n\ncompile project(':Module_common')   \n改成  \nembedded project(':Module_common')\n\n这样在打B的aar时候，会把基moduel的aar合并进来\n\n\n如果这个模块工程就一个工程，就只需要解决问题1，同时配置一下混淆就行\n\n## 问题4\n通过hook调用\n基模块：\n\n    public class CommonModuleDataEngine {\n    \n        private static CommonModuleDataEngine INSTANCE;\n    \n        private AppInfo appInfo;//这个必须要父模块或者兄弟模块\n        public static CommonModuleDataEngine getInstance() {\n            if (INSTANCE == null) {\n                INSTANCE = new CommonModuleDataEngine();\n            }\n            return INSTANCE;\n        }\n    \n        private CommonModuleDataEngine() {\n        }\n    \n        public String getAppInfo() {\n            return appInfo.getAppInfo();\n        }\n    \n        public static class Builder {\n            private AppInfo appInfo;\n    \n            public Builder setAppInfo(AppInfo appInfo) {\n                this.appInfo = appInfo;\n                return this;\n            }\n            public void build() {\n                CommonModuleDataEngine engin = CommonModuleDataEngine.getInstance();\n                engin.appInfo = this.appInfo;\n    \n            }\n    \n        }\n        public interface AppInfo {\n    \n            String getAppInfo();\n    \n        }\n    \n    }\n\n\n主工程  \n\n在Application初始化的时候初始几个基类CommonModuleDataEngine，\n\n\nps：内部类的去混淆  \n\n        -keepclasseswithmembers  class CommonModuleDataEngine {*;}\n    -keepclasseswithmembers  class CommonModuleDataEngine$* {*;}\n\n\n\n\n### 其它注意事项  \n1、主程序和Module里面的Manifest里面的一些配置同名。必须在manifest  中的相应的配置里面 添加  \n\n        tools:replace=\"android:icon,theme,label\"\n例如基module和主程序都包含了高德定位，manifest必然也有相同的配置信息\n\n    <meta-data\n        tools:replace=\"android:value\"\n        android:name=\"com.amap.api.v2.apikey\"\n        android:value=\"*******\" />\n\nApp组件化与业务拆分: http://www.jianshu.com/p/60c1b9ddd8ab\n\n\n\n","source":"_posts/Android模块化方案.md","raw":"title: Android模块化方案\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n- 模块化\n---\n\n## AAR模块化方案  \n1、首先 按照应用分层（common  view），注意每个module最好配置一下resourcePrefix \"mc_\"  \n2、上层再按照功能模块比如  信用卡和个人中心\n\n这样每个都会打出一个aar，府工程引入所有的aar就可以引入这个模块\n\n## 问题\n但是这个距离一个可以发布出去的aar还有距离，有以下几个问题需要解决：  \n1. 本地jar依赖（主工程很有可能也公用这个jar）；  \n2. 混淆的问题；  \n3. 多个aar合并；   \n4. 兄弟模块互相调用，基模块调用父模块的方法；\n\n\n### 问题1:  \nAndroid dependency的几种方法：\neg：  \n\n        testCompile 'junit:junit:4.12'\n    //compile fileTree(dir: 'libs', include: ['*.jar'])  \n    provided fileTree(dir: 'libs',include: ['*.jar'])  \n    compile 'com.android.support:support-v4:23.0.1'  \n    compile project(':Module_common')   \n- testCompile ：  debug 会编译  正式打包不会编译\n- compile ： 除去\"compile jar\"会编译进arr，其余的都不会编译进去\n- provided：编译时候不会把jar编译进去\n\n传递依赖的问题\n（例如 modle A 依赖 Module B，Module B 又依赖Module  C ）   jar  都放在C里面，Module A不引入jar 也能引用到jar。\n\n但是正式打包时候不需要这些jar，本地的jar必须以provided方式引入，这样aar里面就不会打进去这些jar了。\n\n这会引入另外一个问题：C改成provide 这些jar后，A和B找不到这些依赖的jar 会编译失败\n\n解决方案：\n把jar单独成一个module D，写成provided\n（也可在module A  和 B里面  把这些jar 都拷贝进去，然后统统写成provided）\n\n### 问题2\n\n首先要明白，我们要去混淆的是A和主工程的接口，而A和B以及C直接的调用都需要混淆，但是不能在B和C里面混淆，因为这样一混淆的话，A与B、C调用的接口也混淆了\n\n所以混淆只能在A里面打开，A和B都不能打开混淆\n\n### 问题3\n默认会打出三个aar，但是我们只能发布一个aar出去，所以必须使用到 https://github.com/adwiv/android-fat-aar 写的合并aar的gradle\n\n方法：  \n1、拷贝 fat-aar.gradle到build.gradle 同级目录\n2、module的build.gradle新增  \napply from: 'fat-aar.gradle'  ，\n\ncompile project(':Module_common')   \n改成  \nembedded project(':Module_common')\n\n这样在打B的aar时候，会把基moduel的aar合并进来\n\n\n如果这个模块工程就一个工程，就只需要解决问题1，同时配置一下混淆就行\n\n## 问题4\n通过hook调用\n基模块：\n\n    public class CommonModuleDataEngine {\n    \n        private static CommonModuleDataEngine INSTANCE;\n    \n        private AppInfo appInfo;//这个必须要父模块或者兄弟模块\n        public static CommonModuleDataEngine getInstance() {\n            if (INSTANCE == null) {\n                INSTANCE = new CommonModuleDataEngine();\n            }\n            return INSTANCE;\n        }\n    \n        private CommonModuleDataEngine() {\n        }\n    \n        public String getAppInfo() {\n            return appInfo.getAppInfo();\n        }\n    \n        public static class Builder {\n            private AppInfo appInfo;\n    \n            public Builder setAppInfo(AppInfo appInfo) {\n                this.appInfo = appInfo;\n                return this;\n            }\n            public void build() {\n                CommonModuleDataEngine engin = CommonModuleDataEngine.getInstance();\n                engin.appInfo = this.appInfo;\n    \n            }\n    \n        }\n        public interface AppInfo {\n    \n            String getAppInfo();\n    \n        }\n    \n    }\n\n\n主工程  \n\n在Application初始化的时候初始几个基类CommonModuleDataEngine，\n\n\nps：内部类的去混淆  \n\n        -keepclasseswithmembers  class CommonModuleDataEngine {*;}\n    -keepclasseswithmembers  class CommonModuleDataEngine$* {*;}\n\n\n\n\n### 其它注意事项  \n1、主程序和Module里面的Manifest里面的一些配置同名。必须在manifest  中的相应的配置里面 添加  \n\n        tools:replace=\"android:icon,theme,label\"\n例如基module和主程序都包含了高德定位，manifest必然也有相同的配置信息\n\n    <meta-data\n        tools:replace=\"android:value\"\n        android:name=\"com.amap.api.v2.apikey\"\n        android:value=\"*******\" />\n\nApp组件化与业务拆分: http://www.jianshu.com/p/60c1b9ddd8ab\n\n\n\n","slug":"Android模块化方案","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lb30006sfjf2nmryn83","content":"<h2 id=\"AAR模块化方案\"><a href=\"#AAR模块化方案\" class=\"headerlink\" title=\"AAR模块化方案\"></a>AAR模块化方案</h2><p>1、首先 按照应用分层（common  view），注意每个module最好配置一下resourcePrefix “mc_”<br>2、上层再按照功能模块比如  信用卡和个人中心</p>\n<p>这样每个都会打出一个aar，府工程引入所有的aar就可以引入这个模块</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>但是这个距离一个可以发布出去的aar还有距离，有以下几个问题需要解决：  </p>\n<ol>\n<li>本地jar依赖（主工程很有可能也公用这个jar）；  </li>\n<li>混淆的问题；  </li>\n<li>多个aar合并；   </li>\n<li>兄弟模块互相调用，基模块调用父模块的方法；</li>\n</ol>\n<h3 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1:\"></a>问题1:</h3><p>Android dependency的几种方法：<br>eg：  </p>\n<pre><code>    testCompile &apos;junit:junit:4.12&apos;\n//compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])  \nprovided fileTree(dir: &apos;libs&apos;,include: [&apos;*.jar&apos;])  \ncompile &apos;com.android.support:support-v4:23.0.1&apos;  \ncompile project(&apos;:Module_common&apos;)   \n</code></pre><ul>\n<li>testCompile ：  debug 会编译  正式打包不会编译</li>\n<li>compile ： 除去”compile jar”会编译进arr，其余的都不会编译进去</li>\n<li>provided：编译时候不会把jar编译进去</li>\n</ul>\n<p>传递依赖的问题<br>（例如 modle A 依赖 Module B，Module B 又依赖Module  C ）   jar  都放在C里面，Module A不引入jar 也能引用到jar。</p>\n<p>但是正式打包时候不需要这些jar，本地的jar必须以provided方式引入，这样aar里面就不会打进去这些jar了。</p>\n<p>这会引入另外一个问题：C改成provide 这些jar后，A和B找不到这些依赖的jar 会编译失败</p>\n<p>解决方案：<br>把jar单独成一个module D，写成provided<br>（也可在module A  和 B里面  把这些jar 都拷贝进去，然后统统写成provided）</p>\n<h3 id=\"问题2\"><a href=\"#问题2\" class=\"headerlink\" title=\"问题2\"></a>问题2</h3><p>首先要明白，我们要去混淆的是A和主工程的接口，而A和B以及C直接的调用都需要混淆，但是不能在B和C里面混淆，因为这样一混淆的话，A与B、C调用的接口也混淆了</p>\n<p>所以混淆只能在A里面打开，A和B都不能打开混淆</p>\n<h3 id=\"问题3\"><a href=\"#问题3\" class=\"headerlink\" title=\"问题3\"></a>问题3</h3><p>默认会打出三个aar，但是我们只能发布一个aar出去，所以必须使用到 <a href=\"https://github.com/adwiv/android-fat-aar\" target=\"_blank\" rel=\"external\">https://github.com/adwiv/android-fat-aar</a> 写的合并aar的gradle</p>\n<p>方法：<br>1、拷贝 fat-aar.gradle到build.gradle 同级目录<br>2、module的build.gradle新增<br>apply from: ‘fat-aar.gradle’  ，</p>\n<p>compile project(‘:Module_common’)<br>改成<br>embedded project(‘:Module_common’)</p>\n<p>这样在打B的aar时候，会把基moduel的aar合并进来</p>\n<p>如果这个模块工程就一个工程，就只需要解决问题1，同时配置一下混淆就行</p>\n<h2 id=\"问题4\"><a href=\"#问题4\" class=\"headerlink\" title=\"问题4\"></a>问题4</h2><p>通过hook调用<br>基模块：</p>\n<pre><code>public class CommonModuleDataEngine {\n\n    private static CommonModuleDataEngine INSTANCE;\n\n    private AppInfo appInfo;//这个必须要父模块或者兄弟模块\n    public static CommonModuleDataEngine getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new CommonModuleDataEngine();\n        }\n        return INSTANCE;\n    }\n\n    private CommonModuleDataEngine() {\n    }\n\n    public String getAppInfo() {\n        return appInfo.getAppInfo();\n    }\n\n    public static class Builder {\n        private AppInfo appInfo;\n\n        public Builder setAppInfo(AppInfo appInfo) {\n            this.appInfo = appInfo;\n            return this;\n        }\n        public void build() {\n            CommonModuleDataEngine engin = CommonModuleDataEngine.getInstance();\n            engin.appInfo = this.appInfo;\n\n        }\n\n    }\n    public interface AppInfo {\n\n        String getAppInfo();\n\n    }\n\n}\n</code></pre><p>主工程  </p>\n<p>在Application初始化的时候初始几个基类CommonModuleDataEngine，</p>\n<p>ps：内部类的去混淆  </p>\n<pre><code>    -keepclasseswithmembers  class CommonModuleDataEngine {*;}\n-keepclasseswithmembers  class CommonModuleDataEngine$* {*;}\n</code></pre><h3 id=\"其它注意事项\"><a href=\"#其它注意事项\" class=\"headerlink\" title=\"其它注意事项\"></a>其它注意事项</h3><p>1、主程序和Module里面的Manifest里面的一些配置同名。必须在manifest  中的相应的配置里面 添加  </p>\n<pre><code>tools:replace=&quot;android:icon,theme,label&quot;\n</code></pre><p>例如基module和主程序都包含了高德定位，manifest必然也有相同的配置信息</p>\n<pre><code>&lt;meta-data\n    tools:replace=&quot;android:value&quot;\n    android:name=&quot;com.amap.api.v2.apikey&quot;\n    android:value=&quot;*******&quot; /&gt;\n</code></pre><p>App组件化与业务拆分: <a href=\"http://www.jianshu.com/p/60c1b9ddd8ab\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/60c1b9ddd8ab</a></p>\n","excerpt":"","more":"<h2 id=\"AAR模块化方案\"><a href=\"#AAR模块化方案\" class=\"headerlink\" title=\"AAR模块化方案\"></a>AAR模块化方案</h2><p>1、首先 按照应用分层（common  view），注意每个module最好配置一下resourcePrefix “mc_”<br>2、上层再按照功能模块比如  信用卡和个人中心</p>\n<p>这样每个都会打出一个aar，府工程引入所有的aar就可以引入这个模块</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>但是这个距离一个可以发布出去的aar还有距离，有以下几个问题需要解决：  </p>\n<ol>\n<li>本地jar依赖（主工程很有可能也公用这个jar）；  </li>\n<li>混淆的问题；  </li>\n<li>多个aar合并；   </li>\n<li>兄弟模块互相调用，基模块调用父模块的方法；</li>\n</ol>\n<h3 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1:\"></a>问题1:</h3><p>Android dependency的几种方法：<br>eg：  </p>\n<pre><code>    testCompile &apos;junit:junit:4.12&apos;\n//compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])  \nprovided fileTree(dir: &apos;libs&apos;,include: [&apos;*.jar&apos;])  \ncompile &apos;com.android.support:support-v4:23.0.1&apos;  \ncompile project(&apos;:Module_common&apos;)   \n</code></pre><ul>\n<li>testCompile ：  debug 会编译  正式打包不会编译</li>\n<li>compile ： 除去”compile jar”会编译进arr，其余的都不会编译进去</li>\n<li>provided：编译时候不会把jar编译进去</li>\n</ul>\n<p>传递依赖的问题<br>（例如 modle A 依赖 Module B，Module B 又依赖Module  C ）   jar  都放在C里面，Module A不引入jar 也能引用到jar。</p>\n<p>但是正式打包时候不需要这些jar，本地的jar必须以provided方式引入，这样aar里面就不会打进去这些jar了。</p>\n<p>这会引入另外一个问题：C改成provide 这些jar后，A和B找不到这些依赖的jar 会编译失败</p>\n<p>解决方案：<br>把jar单独成一个module D，写成provided<br>（也可在module A  和 B里面  把这些jar 都拷贝进去，然后统统写成provided）</p>\n<h3 id=\"问题2\"><a href=\"#问题2\" class=\"headerlink\" title=\"问题2\"></a>问题2</h3><p>首先要明白，我们要去混淆的是A和主工程的接口，而A和B以及C直接的调用都需要混淆，但是不能在B和C里面混淆，因为这样一混淆的话，A与B、C调用的接口也混淆了</p>\n<p>所以混淆只能在A里面打开，A和B都不能打开混淆</p>\n<h3 id=\"问题3\"><a href=\"#问题3\" class=\"headerlink\" title=\"问题3\"></a>问题3</h3><p>默认会打出三个aar，但是我们只能发布一个aar出去，所以必须使用到 <a href=\"https://github.com/adwiv/android-fat-aar\">https://github.com/adwiv/android-fat-aar</a> 写的合并aar的gradle</p>\n<p>方法：<br>1、拷贝 fat-aar.gradle到build.gradle 同级目录<br>2、module的build.gradle新增<br>apply from: ‘fat-aar.gradle’  ，</p>\n<p>compile project(‘:Module_common’)<br>改成<br>embedded project(‘:Module_common’)</p>\n<p>这样在打B的aar时候，会把基moduel的aar合并进来</p>\n<p>如果这个模块工程就一个工程，就只需要解决问题1，同时配置一下混淆就行</p>\n<h2 id=\"问题4\"><a href=\"#问题4\" class=\"headerlink\" title=\"问题4\"></a>问题4</h2><p>通过hook调用<br>基模块：</p>\n<pre><code>public class CommonModuleDataEngine {\n\n    private static CommonModuleDataEngine INSTANCE;\n\n    private AppInfo appInfo;//这个必须要父模块或者兄弟模块\n    public static CommonModuleDataEngine getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new CommonModuleDataEngine();\n        }\n        return INSTANCE;\n    }\n\n    private CommonModuleDataEngine() {\n    }\n\n    public String getAppInfo() {\n        return appInfo.getAppInfo();\n    }\n\n    public static class Builder {\n        private AppInfo appInfo;\n\n        public Builder setAppInfo(AppInfo appInfo) {\n            this.appInfo = appInfo;\n            return this;\n        }\n        public void build() {\n            CommonModuleDataEngine engin = CommonModuleDataEngine.getInstance();\n            engin.appInfo = this.appInfo;\n\n        }\n\n    }\n    public interface AppInfo {\n\n        String getAppInfo();\n\n    }\n\n}\n</code></pre><p>主工程  </p>\n<p>在Application初始化的时候初始几个基类CommonModuleDataEngine，</p>\n<p>ps：内部类的去混淆  </p>\n<pre><code>    -keepclasseswithmembers  class CommonModuleDataEngine {*;}\n-keepclasseswithmembers  class CommonModuleDataEngine$* {*;}\n</code></pre><h3 id=\"其它注意事项\"><a href=\"#其它注意事项\" class=\"headerlink\" title=\"其它注意事项\"></a>其它注意事项</h3><p>1、主程序和Module里面的Manifest里面的一些配置同名。必须在manifest  中的相应的配置里面 添加  </p>\n<pre><code>tools:replace=&quot;android:icon,theme,label&quot;\n</code></pre><p>例如基module和主程序都包含了高德定位，manifest必然也有相同的配置信息</p>\n<pre><code>&lt;meta-data\n    tools:replace=&quot;android:value&quot;\n    android:name=&quot;com.amap.api.v2.apikey&quot;\n    android:value=&quot;*******&quot; /&gt;\n</code></pre><p>App组件化与业务拆分: <a href=\"http://www.jianshu.com/p/60c1b9ddd8ab\">http://www.jianshu.com/p/60c1b9ddd8ab</a></p>\n"},{"title":"App核心指标和广告计费方式","date":"2017-10-19T16:00:00.000Z","_content":"\n# App核心指标\n1. pv     \n2. uv     \n3. ctr     \n4. 次日/7日留存/30日留存        \n一般目标是在40/20/10     \n参考文章：http://www.pmcaff.com/discuss/index/369885221299264?pmc_param=1\n\n5. dau  \n6. mau\n7. 时长\n\n\n\n# 广告计费方式：\n1. CPC\n\n按点击付费，原英文为Cost Per Click 每点击成本，网络广告每次点击的费用。是做为网络广告投放效果的重要参考数据。CPC是网络广告界一种常见的定价形式。例如，关键词广告等依据效果付费的广告形式，一般采用这种定价模式。\n\n2. CPM\n\n按千次展示付费，其原始英文为Cost Per Mille，简称CPM。现在也有人将其译成cost per one thousand impressions 或cost per thousand。前者中文名为每千人印象成本。后者称谓相同，但简称为CPT。所指内涵与CPM相同。其计算公式为：\n千人成本=（广告费用/到达人数）×1000。\n\n3. CPA\n\n按行为付费，其原始英文为 Cost Per Activity(Action)，每次动作成本，即根据每个访问者对网络广告所采取的行动收费的定价模式。对于用户行动有特别的定义，包括形成一次交易、获得一个注册用户、或者对网络广告的一次点击等。\n\n4. CPD\n\n按天收费，其原始英文为 Cost per day是广告合作的一种常见方式，相比当前比较流行的CPS（按销售付费 Cost per sales），优势在于对合作的基础条件没有过高要求，容易促成双方合作；劣势在于其在长期合作中，不如CPS形式实时有效。\n\n5. CPS\n\n按实际销售产品的提成来换算广告刊登金额，其原始英文为Cost Per Sales，CPS广告同CPA广告一样广告主为规避广告费用风险，按照广告点击之后产生的实际销售的提成付给广告站点销售提成费用。\n\n6. dCPM\n\nDSP普遍采用dCPM作为结算体系，dCPM指的是dynamic CPM，与目前网络广告市场长讲的CPM方式（此CPM相应的成为flat CPM）区别。dCPM基于RTB技术诞生，指的是每一次的impression出价是变化的。其每次出价均依据广告主广告投放的效果(一般是CPS）来实时计算，以得出对广告主最有利的价格，从而保证了广告主的利益。同时又因为以impression与媒体结算，也确保了媒体的收益。\n\nhttps://www.umeng.com/reports.html  \n中国移动互联网发展报告 会有说明行业普遍的留存情况\n","source":"_posts/App核心指标.md","raw":"title: App核心指标和广告计费方式\ndate: 2017-10-20 \ncategories:\n- Android\ntags:\n- Android\n- 指标\n- 广告计费\n\n---\n\n# App核心指标\n1. pv     \n2. uv     \n3. ctr     \n4. 次日/7日留存/30日留存        \n一般目标是在40/20/10     \n参考文章：http://www.pmcaff.com/discuss/index/369885221299264?pmc_param=1\n\n5. dau  \n6. mau\n7. 时长\n\n\n\n# 广告计费方式：\n1. CPC\n\n按点击付费，原英文为Cost Per Click 每点击成本，网络广告每次点击的费用。是做为网络广告投放效果的重要参考数据。CPC是网络广告界一种常见的定价形式。例如，关键词广告等依据效果付费的广告形式，一般采用这种定价模式。\n\n2. CPM\n\n按千次展示付费，其原始英文为Cost Per Mille，简称CPM。现在也有人将其译成cost per one thousand impressions 或cost per thousand。前者中文名为每千人印象成本。后者称谓相同，但简称为CPT。所指内涵与CPM相同。其计算公式为：\n千人成本=（广告费用/到达人数）×1000。\n\n3. CPA\n\n按行为付费，其原始英文为 Cost Per Activity(Action)，每次动作成本，即根据每个访问者对网络广告所采取的行动收费的定价模式。对于用户行动有特别的定义，包括形成一次交易、获得一个注册用户、或者对网络广告的一次点击等。\n\n4. CPD\n\n按天收费，其原始英文为 Cost per day是广告合作的一种常见方式，相比当前比较流行的CPS（按销售付费 Cost per sales），优势在于对合作的基础条件没有过高要求，容易促成双方合作；劣势在于其在长期合作中，不如CPS形式实时有效。\n\n5. CPS\n\n按实际销售产品的提成来换算广告刊登金额，其原始英文为Cost Per Sales，CPS广告同CPA广告一样广告主为规避广告费用风险，按照广告点击之后产生的实际销售的提成付给广告站点销售提成费用。\n\n6. dCPM\n\nDSP普遍采用dCPM作为结算体系，dCPM指的是dynamic CPM，与目前网络广告市场长讲的CPM方式（此CPM相应的成为flat CPM）区别。dCPM基于RTB技术诞生，指的是每一次的impression出价是变化的。其每次出价均依据广告主广告投放的效果(一般是CPS）来实时计算，以得出对广告主最有利的价格，从而保证了广告主的利益。同时又因为以impression与媒体结算，也确保了媒体的收益。\n\nhttps://www.umeng.com/reports.html  \n中国移动互联网发展报告 会有说明行业普遍的留存情况\n","slug":"App核心指标","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lb70009sfjfq4nhc9nd","content":"<h1 id=\"App核心指标\"><a href=\"#App核心指标\" class=\"headerlink\" title=\"App核心指标\"></a>App核心指标</h1><ol>\n<li>pv     </li>\n<li>uv     </li>\n<li>ctr     </li>\n<li><p>次日/7日留存/30日留存<br>一般目标是在40/20/10<br>参考文章：<a href=\"http://www.pmcaff.com/discuss/index/369885221299264?pmc_param=1\" target=\"_blank\" rel=\"external\">http://www.pmcaff.com/discuss/index/369885221299264?pmc_param=1</a></p>\n</li>\n<li><p>dau  </p>\n</li>\n<li>mau</li>\n<li>时长</li>\n</ol>\n<h1 id=\"广告计费方式：\"><a href=\"#广告计费方式：\" class=\"headerlink\" title=\"广告计费方式：\"></a>广告计费方式：</h1><ol>\n<li>CPC</li>\n</ol>\n<p>按点击付费，原英文为Cost Per Click 每点击成本，网络广告每次点击的费用。是做为网络广告投放效果的重要参考数据。CPC是网络广告界一种常见的定价形式。例如，关键词广告等依据效果付费的广告形式，一般采用这种定价模式。</p>\n<ol>\n<li>CPM</li>\n</ol>\n<p>按千次展示付费，其原始英文为Cost Per Mille，简称CPM。现在也有人将其译成cost per one thousand impressions 或cost per thousand。前者中文名为每千人印象成本。后者称谓相同，但简称为CPT。所指内涵与CPM相同。其计算公式为：<br>千人成本=（广告费用/到达人数）×1000。</p>\n<ol>\n<li>CPA</li>\n</ol>\n<p>按行为付费，其原始英文为 Cost Per Activity(Action)，每次动作成本，即根据每个访问者对网络广告所采取的行动收费的定价模式。对于用户行动有特别的定义，包括形成一次交易、获得一个注册用户、或者对网络广告的一次点击等。</p>\n<ol>\n<li>CPD</li>\n</ol>\n<p>按天收费，其原始英文为 Cost per day是广告合作的一种常见方式，相比当前比较流行的CPS（按销售付费 Cost per sales），优势在于对合作的基础条件没有过高要求，容易促成双方合作；劣势在于其在长期合作中，不如CPS形式实时有效。</p>\n<ol>\n<li>CPS</li>\n</ol>\n<p>按实际销售产品的提成来换算广告刊登金额，其原始英文为Cost Per Sales，CPS广告同CPA广告一样广告主为规避广告费用风险，按照广告点击之后产生的实际销售的提成付给广告站点销售提成费用。</p>\n<ol>\n<li>dCPM</li>\n</ol>\n<p>DSP普遍采用dCPM作为结算体系，dCPM指的是dynamic CPM，与目前网络广告市场长讲的CPM方式（此CPM相应的成为flat CPM）区别。dCPM基于RTB技术诞生，指的是每一次的impression出价是变化的。其每次出价均依据广告主广告投放的效果(一般是CPS）来实时计算，以得出对广告主最有利的价格，从而保证了广告主的利益。同时又因为以impression与媒体结算，也确保了媒体的收益。</p>\n<p><a href=\"https://www.umeng.com/reports.html\" target=\"_blank\" rel=\"external\">https://www.umeng.com/reports.html</a><br>中国移动互联网发展报告 会有说明行业普遍的留存情况</p>\n","excerpt":"","more":"<h1 id=\"App核心指标\"><a href=\"#App核心指标\" class=\"headerlink\" title=\"App核心指标\"></a>App核心指标</h1><ol>\n<li>pv     </li>\n<li>uv     </li>\n<li>ctr     </li>\n<li><p>次日/7日留存/30日留存<br>一般目标是在40/20/10<br>参考文章：<a href=\"http://www.pmcaff.com/discuss/index/369885221299264?pmc_param=1\">http://www.pmcaff.com/discuss/index/369885221299264?pmc_param=1</a></p>\n</li>\n<li><p>dau  </p>\n</li>\n<li>mau</li>\n<li>时长</li>\n</ol>\n<h1 id=\"广告计费方式：\"><a href=\"#广告计费方式：\" class=\"headerlink\" title=\"广告计费方式：\"></a>广告计费方式：</h1><ol>\n<li>CPC</li>\n</ol>\n<p>按点击付费，原英文为Cost Per Click 每点击成本，网络广告每次点击的费用。是做为网络广告投放效果的重要参考数据。CPC是网络广告界一种常见的定价形式。例如，关键词广告等依据效果付费的广告形式，一般采用这种定价模式。</p>\n<ol>\n<li>CPM</li>\n</ol>\n<p>按千次展示付费，其原始英文为Cost Per Mille，简称CPM。现在也有人将其译成cost per one thousand impressions 或cost per thousand。前者中文名为每千人印象成本。后者称谓相同，但简称为CPT。所指内涵与CPM相同。其计算公式为：<br>千人成本=（广告费用/到达人数）×1000。</p>\n<ol>\n<li>CPA</li>\n</ol>\n<p>按行为付费，其原始英文为 Cost Per Activity(Action)，每次动作成本，即根据每个访问者对网络广告所采取的行动收费的定价模式。对于用户行动有特别的定义，包括形成一次交易、获得一个注册用户、或者对网络广告的一次点击等。</p>\n<ol>\n<li>CPD</li>\n</ol>\n<p>按天收费，其原始英文为 Cost per day是广告合作的一种常见方式，相比当前比较流行的CPS（按销售付费 Cost per sales），优势在于对合作的基础条件没有过高要求，容易促成双方合作；劣势在于其在长期合作中，不如CPS形式实时有效。</p>\n<ol>\n<li>CPS</li>\n</ol>\n<p>按实际销售产品的提成来换算广告刊登金额，其原始英文为Cost Per Sales，CPS广告同CPA广告一样广告主为规避广告费用风险，按照广告点击之后产生的实际销售的提成付给广告站点销售提成费用。</p>\n<ol>\n<li>dCPM</li>\n</ol>\n<p>DSP普遍采用dCPM作为结算体系，dCPM指的是dynamic CPM，与目前网络广告市场长讲的CPM方式（此CPM相应的成为flat CPM）区别。dCPM基于RTB技术诞生，指的是每一次的impression出价是变化的。其每次出价均依据广告主广告投放的效果(一般是CPS）来实时计算，以得出对广告主最有利的价格，从而保证了广告主的利益。同时又因为以impression与媒体结算，也确保了媒体的收益。</p>\n<p><a href=\"https://www.umeng.com/reports.html\">https://www.umeng.com/reports.html</a><br>中国移动互联网发展报告 会有说明行业普遍的留存情况</p>\n"},{"title":"EventBus3.0","date":"2018-02-09T16:00:00.000Z","_content":"\n# EventBus3.0 优点：\n\nEventBus 3由于使用了注解，比起使用反射来遍历方法的2.4版本逊色不少。但开挂之后(启用了索引)远远超出之前的版本。\n\n![性能对比](http://i.imgur.com/5evKXOx.png)\n\n参考资料：https://www.cnblogs.com/bugly/p/5475034.html\n\n\n## 开挂方法：  \n1. 在当前moudle的gradle 添加    \n\n\t\t\tapply plugin: 'com.neenbedankt.android-apt'   \n\n2. 在dependencies里面添加   \n\n\t\tdependencies \n\t\tcompile 'org.greenrobot:eventbus:3.0.0'\n\t\tapt 'org.greenrobot:eventbus-annotation-processor:3.0.1'   \n\n\n3. 在使用时候   \n\n\t\t@Subscribe\n\t\tpublic void helloEventBus(UserReLoginEvent  event){\n\t\t    // TODO: 17/6/27  这是是为了测试而使用的\n\t\t    UtilsManager.toast(mContext,\"这是eventbus 3.0 可以支持的\");\n\t\t}\n\n\n\n## 事件源定位：  \n为了防止事件环路对EventBus加一个Wrapper，每次发送Event时候打印一下路径   \n\n\t \tprivate static void printWrapPath(String tagStr, Object... objects) {\n\n\t        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n\t        final StackTraceElement ste = stackTrace[5];\n\n\t        StringBuilder stringBuilder = new StringBuilder();\n\t        String className = ste.getFileName();\n\t        if (!TextUtils.isEmpty(className)) {\n\t            String methodName = ste.getMethodName();\n\t            int lineNumber = ste.getLineNumber();\n\t            stringBuilder.append(\"(\").append(className).append(\":\").append(lineNumber).append(\") #\").append(methodName).append(\" : \");\n\t        } else {\n\t            stringBuilder.append(\" \");\n\t        }\n\n\t        String tag = (tagStr == null ? LOG_DEFAULT_TAG : tagStr);\n\t        String msg = (objects == null) ? \"null\" : getObjectsString(objects);\n\t        String headString = stringBuilder.toString();\n\n\t \t\tLog.println(type, tagStr, headString + msg);\n\n\t \t}\n\n\n## 混淆问题  ：  \n\n混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。\n\n首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报java.lang.NoSuchFieldError: No static field POSTING。网上给出的解决办法是keep住所有eventbus相关的代码：\n\n\t\t-keep class de.greenrobot.** {*;}  \n\n\n其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。\n\n\t\t-keep public enum org.greenrobot.eventbus.ThreadMode { public static *; }   \n\n\n这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule?\n\n这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法：\n\n\t-keepclassmembers class * {\n\t    @de.greenrobot.event.Subscribe <methods>;\n\t}\n\n\n所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。\n\n## Android APT\n  参考资料：https://segmentfault.com/a/1190000005100468\n\n","source":"_posts/EventBus版本升级.md","raw":"title: EventBus3.0\ndate: 2018-2-10 \ncategories:\n- Android\ntags:\n- Android\n- eventbus3.0\n- 注解\n- APT\n\n\n---\n\n# EventBus3.0 优点：\n\nEventBus 3由于使用了注解，比起使用反射来遍历方法的2.4版本逊色不少。但开挂之后(启用了索引)远远超出之前的版本。\n\n![性能对比](http://i.imgur.com/5evKXOx.png)\n\n参考资料：https://www.cnblogs.com/bugly/p/5475034.html\n\n\n## 开挂方法：  \n1. 在当前moudle的gradle 添加    \n\n\t\t\tapply plugin: 'com.neenbedankt.android-apt'   \n\n2. 在dependencies里面添加   \n\n\t\tdependencies \n\t\tcompile 'org.greenrobot:eventbus:3.0.0'\n\t\tapt 'org.greenrobot:eventbus-annotation-processor:3.0.1'   \n\n\n3. 在使用时候   \n\n\t\t@Subscribe\n\t\tpublic void helloEventBus(UserReLoginEvent  event){\n\t\t    // TODO: 17/6/27  这是是为了测试而使用的\n\t\t    UtilsManager.toast(mContext,\"这是eventbus 3.0 可以支持的\");\n\t\t}\n\n\n\n## 事件源定位：  \n为了防止事件环路对EventBus加一个Wrapper，每次发送Event时候打印一下路径   \n\n\t \tprivate static void printWrapPath(String tagStr, Object... objects) {\n\n\t        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n\t        final StackTraceElement ste = stackTrace[5];\n\n\t        StringBuilder stringBuilder = new StringBuilder();\n\t        String className = ste.getFileName();\n\t        if (!TextUtils.isEmpty(className)) {\n\t            String methodName = ste.getMethodName();\n\t            int lineNumber = ste.getLineNumber();\n\t            stringBuilder.append(\"(\").append(className).append(\":\").append(lineNumber).append(\") #\").append(methodName).append(\" : \");\n\t        } else {\n\t            stringBuilder.append(\" \");\n\t        }\n\n\t        String tag = (tagStr == null ? LOG_DEFAULT_TAG : tagStr);\n\t        String msg = (objects == null) ? \"null\" : getObjectsString(objects);\n\t        String headString = stringBuilder.toString();\n\n\t \t\tLog.println(type, tagStr, headString + msg);\n\n\t \t}\n\n\n## 混淆问题  ：  \n\n混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。\n\n首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报java.lang.NoSuchFieldError: No static field POSTING。网上给出的解决办法是keep住所有eventbus相关的代码：\n\n\t\t-keep class de.greenrobot.** {*;}  \n\n\n其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。\n\n\t\t-keep public enum org.greenrobot.eventbus.ThreadMode { public static *; }   \n\n\n这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule?\n\n这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法：\n\n\t-keepclassmembers class * {\n\t    @de.greenrobot.event.Subscribe <methods>;\n\t}\n\n\n所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。\n\n## Android APT\n  参考资料：https://segmentfault.com/a/1190000005100468\n\n","slug":"EventBus版本升级","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lbd000bsfjfbjpxlx4v","content":"<h1 id=\"EventBus3-0-优点：\"><a href=\"#EventBus3-0-优点：\" class=\"headerlink\" title=\"EventBus3.0 优点：\"></a>EventBus3.0 优点：</h1><p>EventBus 3由于使用了注解，比起使用反射来遍历方法的2.4版本逊色不少。但开挂之后(启用了索引)远远超出之前的版本。</p>\n<p><img src=\"http://i.imgur.com/5evKXOx.png\" alt=\"性能对比\"></p>\n<p>参考资料：<a href=\"https://www.cnblogs.com/bugly/p/5475034.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/bugly/p/5475034.html</a></p>\n<h2 id=\"开挂方法：\"><a href=\"#开挂方法：\" class=\"headerlink\" title=\"开挂方法：\"></a>开挂方法：</h2><ol>\n<li><p>在当前moudle的gradle 添加    </p>\n<pre><code>apply plugin: &apos;com.neenbedankt.android-apt&apos;   \n</code></pre></li>\n<li><p>在dependencies里面添加   </p>\n<pre><code>dependencies \ncompile &apos;org.greenrobot:eventbus:3.0.0&apos;\napt &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;   \n</code></pre></li>\n</ol>\n<ol>\n<li><p>在使用时候   </p>\n<pre><code>@Subscribe\npublic void helloEventBus(UserReLoginEvent  event){\n    // TODO: 17/6/27  这是是为了测试而使用的\n    UtilsManager.toast(mContext,&quot;这是eventbus 3.0 可以支持的&quot;);\n}\n</code></pre></li>\n</ol>\n<h2 id=\"事件源定位：\"><a href=\"#事件源定位：\" class=\"headerlink\" title=\"事件源定位：\"></a>事件源定位：</h2><p>为了防止事件环路对EventBus加一个Wrapper，每次发送Event时候打印一下路径   </p>\n<pre><code>private static void printWrapPath(String tagStr, Object... objects) {\n\n   StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n   final StackTraceElement ste = stackTrace[5];\n\n   StringBuilder stringBuilder = new StringBuilder();\n   String className = ste.getFileName();\n   if (!TextUtils.isEmpty(className)) {\n       String methodName = ste.getMethodName();\n       int lineNumber = ste.getLineNumber();\n       stringBuilder.append(&quot;(&quot;).append(className).append(&quot;:&quot;).append(lineNumber).append(&quot;) #&quot;).append(methodName).append(&quot; : &quot;);\n   } else {\n       stringBuilder.append(&quot; &quot;);\n   }\n\n   String tag = (tagStr == null ? LOG_DEFAULT_TAG : tagStr);\n   String msg = (objects == null) ? &quot;null&quot; : getObjectsString(objects);\n   String headString = stringBuilder.toString();\n\n    Log.println(type, tagStr, headString + msg);\n\n}\n</code></pre><h2 id=\"混淆问题-：\"><a href=\"#混淆问题-：\" class=\"headerlink\" title=\"混淆问题  ：\"></a>混淆问题  ：</h2><p>混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。</p>\n<p>首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报java.lang.NoSuchFieldError: No static field POSTING。网上给出的解决办法是keep住所有eventbus相关的代码：</p>\n<pre><code>-keep class de.greenrobot.** {*;}  \n</code></pre><p>其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。</p>\n<pre><code>-keep public enum org.greenrobot.eventbus.ThreadMode { public static *; }   \n</code></pre><p>这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule?</p>\n<p>这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法：</p>\n<pre><code>-keepclassmembers class * {\n    @de.greenrobot.event.Subscribe &lt;methods&gt;;\n}\n</code></pre><p>所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。</p>\n<h2 id=\"Android-APT\"><a href=\"#Android-APT\" class=\"headerlink\" title=\"Android APT\"></a>Android APT</h2><p>  参考资料：<a href=\"https://segmentfault.com/a/1190000005100468\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000005100468</a></p>\n","excerpt":"","more":"<h1 id=\"EventBus3-0-优点：\"><a href=\"#EventBus3-0-优点：\" class=\"headerlink\" title=\"EventBus3.0 优点：\"></a>EventBus3.0 优点：</h1><p>EventBus 3由于使用了注解，比起使用反射来遍历方法的2.4版本逊色不少。但开挂之后(启用了索引)远远超出之前的版本。</p>\n<p><img src=\"http://i.imgur.com/5evKXOx.png\" alt=\"性能对比\"></p>\n<p>参考资料：<a href=\"https://www.cnblogs.com/bugly/p/5475034.html\">https://www.cnblogs.com/bugly/p/5475034.html</a></p>\n<h2 id=\"开挂方法：\"><a href=\"#开挂方法：\" class=\"headerlink\" title=\"开挂方法：\"></a>开挂方法：</h2><ol>\n<li><p>在当前moudle的gradle 添加    </p>\n<pre><code>apply plugin: &apos;com.neenbedankt.android-apt&apos;   \n</code></pre></li>\n<li><p>在dependencies里面添加   </p>\n<pre><code>dependencies \ncompile &apos;org.greenrobot:eventbus:3.0.0&apos;\napt &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;   \n</code></pre></li>\n</ol>\n<ol>\n<li><p>在使用时候   </p>\n<pre><code>@Subscribe\npublic void helloEventBus(UserReLoginEvent  event){\n    // TODO: 17/6/27  这是是为了测试而使用的\n    UtilsManager.toast(mContext,&quot;这是eventbus 3.0 可以支持的&quot;);\n}\n</code></pre></li>\n</ol>\n<h2 id=\"事件源定位：\"><a href=\"#事件源定位：\" class=\"headerlink\" title=\"事件源定位：\"></a>事件源定位：</h2><p>为了防止事件环路对EventBus加一个Wrapper，每次发送Event时候打印一下路径   </p>\n<pre><code>private static void printWrapPath(String tagStr, Object... objects) {\n\n   StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n   final StackTraceElement ste = stackTrace[5];\n\n   StringBuilder stringBuilder = new StringBuilder();\n   String className = ste.getFileName();\n   if (!TextUtils.isEmpty(className)) {\n       String methodName = ste.getMethodName();\n       int lineNumber = ste.getLineNumber();\n       stringBuilder.append(&quot;(&quot;).append(className).append(&quot;:&quot;).append(lineNumber).append(&quot;) #&quot;).append(methodName).append(&quot; : &quot;);\n   } else {\n       stringBuilder.append(&quot; &quot;);\n   }\n\n   String tag = (tagStr == null ? LOG_DEFAULT_TAG : tagStr);\n   String msg = (objects == null) ? &quot;null&quot; : getObjectsString(objects);\n   String headString = stringBuilder.toString();\n\n    Log.println(type, tagStr, headString + msg);\n\n}\n</code></pre><h2 id=\"混淆问题-：\"><a href=\"#混淆问题-：\" class=\"headerlink\" title=\"混淆问题  ：\"></a>混淆问题  ：</h2><p>混淆作为版本发布必备的流程，经常会闹出很多奇奇怪怪的问题，且不方便定位，尤其是EventBus这种依赖反射技术的库。通常情况下都会把相关的类和回调方法都keep住，但这样其实会留下被人反编译后破解的后顾之忧，所以我们的目标是keep最少的代码。</p>\n<p>首先，因为EventBus 3弃用了反射的方式去寻找回调方法，改用注解的方式。作者的意思是在混淆时就不用再keep住相应的类和方法。但是我们在运行时，却会报java.lang.NoSuchFieldError: No static field POSTING。网上给出的解决办法是keep住所有eventbus相关的代码：</p>\n<pre><code>-keep class de.greenrobot.** {*;}  \n</code></pre><p>其实我们仔细分析，可以看到是因为在SubscriberMethodFinder的findUsingReflection方法中，在调用Method.getAnnotation()时获取ThreadMode这个enum失败了，所以我们只需要keep住这个enum就可以了（如下）。</p>\n<pre><code>-keep public enum org.greenrobot.eventbus.ThreadMode { public static *; }   \n</code></pre><p>这样就能正常编译通过了，但如果使用了索引加速，是不会有上面这个问题的。因为在找方法时，调用的不是findUsingReflection，而是findUsingInfo。但是使用了索引加速后，编译后却会报新的错误：Could not find subscriber method in XXX Class. Maybe a missing ProGuard rule?</p>\n<p>这就很好理解了，因为生成索引GeneratedSubscriberIndex是在代码混淆之前进行的，混淆之后类名和方法名都不一样了（上面这个错误是方法无法找到），得keep住所有被Subscribe注解标注的方法：</p>\n<pre><code>-keepclassmembers class * {\n    @de.greenrobot.event.Subscribe &lt;methods&gt;;\n}\n</code></pre><p>所以又倒退回了EventBus2.4时不能混淆onEvent开头的方法一样的处境了。所以这里就得权衡一下利弊：使用了注解不用索引加速，则只需要keep住EventBus相关的代码，现有的代码可以正常的进行混淆。而使用了索引加速的话，则需要keep住相关的方法和类。</p>\n<h2 id=\"Android-APT\"><a href=\"#Android-APT\" class=\"headerlink\" title=\"Android APT\"></a>Android APT</h2><p>  参考资料：<a href=\"https://segmentfault.com/a/1190000005100468\">https://segmentfault.com/a/1190000005100468</a></p>\n"},{"title":"Gradle配置分析","date":"2015-11-01T12:10:33.000Z","_content":"\n\nTopicLevel的gradle    \n\n    buildscript {\n        repositories {\n            jcenter()\n        }\n        dependencies {\n            classpath 'com.android.tools.build:gradle:2.2.2'\n    \n            // NOTE: Do not place your application dependencies here; they belong\n            // in the individual module build.gradle files\n        }\n    }\n    allprojects {\n        repositories {\n            jcenter()\n        }\n    }\n    task clean(type: Delete) {\n        delete rootProject.buildDir\n    }\n\n\n\n\nMudule level的build.gradle  \n    \n    apply plugin: 'com.android.application'\n    \n    android {\n        compileSdkVersion 20\n        buildToolsVersion \"24.0.0\"\n    \n    \n        compileOptions{\n            sourceCompatibility JavaVersion.VERSION_1_8\n            targetCompatibility JavaVersion.VERSION_1_8\n        }\n    \n        defaultConfig {\n            applicationId \"com.lyc.study\"\n            minSdkVersion 15\n            targetSdkVersion 20\n            versionCode 1\n            versionName \"1.0\"\n            jackOptions{\n                enabled true\n            }\n        }\n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            }\n        }\n    }\n    \n    dependencies {\n        compile fileTree(include: ['*.jar'], dir: 'libs')\n        compile 'com.android.support:support-v4:+'\n        compile 'com.android.support:support-annotations:22.2.0'\n        compile 'com.android.support:support-v13:20.1.1'\n    }\n\n\n以上是标准的打包方式,下面是常用的我们自定义的内容   \n        \n        dependencies {\n            compile fileTree(include: '*.jar', dir: 'libs')\n            compile project(':google_services')\n    \n            // compile 'com.android.support:multidex:1.0.1'\n            compile 'top.zibin:Luban:1.0.9'\n            debugCompile 'com.bugtags.library:bugtags-lib:latest.integration'\n            \n            testCompile 'junit:junit:4.12'\n           \n        }\n        \n        android {\n            compileSdkVersion 21\n            buildToolsVersion '23.0.2'\n        \n            sourceSets {\n                main {\n                    manifest.srcFile 'AndroidManifest.xml'\n                    java.srcDirs = ['src']\n                    resources.srcDirs = ['src']\n                    aidl.srcDirs = ['src']\n                    renderscript.srcDirs = ['src']\n                    res.srcDirs = ['res']\n                    assets.srcDirs = ['assets']\n                    jniLibs.srcDirs = ['libs']\n                }\n        \n                test.setRoot('test')\n              \n                debug.setRoot('build-types/debug')\n                release.setRoot('build-types/release')\n            }\n        \n            signingConfigs {\n                debug {\n                    // 请配置好pub.key及其密码，或者改为使用debug.keystore\n                    storeFile file('pub.key') // storeFile file('debug.keystore')\n                    storePassword STORE_PASSWORD\n                    keyAlias KEY_ALIAS\n                    keyPassword KEY_PASSWORD\n                }\n                release {\n                    storeFile file('pub.key')\n                    storePassword STORE_PASSWORD\n                    keyAlias KEY_ALIAS\n                    keyPassword KEY_PASSWORD\n                }\n            }\n        \n            buildTypes {\n                debug {\n                    buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"Not yet\\\"\"\n                    buildConfigField \"boolean\", \"DEVELOP_MODE\", \"true\"\n                    signingConfig signingConfigs.debug\n        \n                    ndk{\n                        abiFilters 'armeabi', 'armeabi-v7a', 'x86' //,'arm64-v8a', 'x86_64', 'mips', 'mips64'\n                    }\n                }\n                release {\n                    buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"2017/1/1\\\"\" //  发布时修改为当天日期\n                    buildConfigField \"boolean\", \"DEVELOP_MODE\", \"false\" // 关闭开发者模式\n                    proguardFiles 'proguard.cfg'\n                    minifyEnabled true\n                    shrinkResources true\n                    debuggable false\n                    jniDebuggable false\n                    signingConfig signingConfigs.release\n        \n                    applicationVariants.all { variant ->\n                        variant.outputs.each { output ->\n                            def outputFile = output.outputFile\n                            if (outputFile != null && outputFile.name.endsWith('.apk')) {\n                                // APK命名格式 Going-release.apk TODO 发布时使用\n                                def fileName = \"Going-v${defaultConfig.versionName}-${defaultConfig.versionCode}-release.apk\"\n        //                         def fileName = \"Going.apk\"\n                                output.outputFile = new File(outputFile.parent, fileName)\n                            }\n                        }\n                    }\n                }\n            }\n        \n            defaultConfig {\n                minSdkVersion 14\n                targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n                versionCode 1000\n                versionName \"1.0.0\"\n                //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:\"googleMarket\" ]\n                multiDexEnabled false\n                multiDexKeepProguard file('multiDexKeep.pro')\n                resConfigs \"en\", \"zh_CN\", \"zh_TW\" //暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n            }\n        \n            productFlavors {\n                  own {}\n                  googleMarket {}\n  \n                  tencent {}\n                  baidu {}\n        \n       \n            }\n        \n        //    productFlavors.all { flavor ->\n        //        flavor.manifestPlaceholders = [ UMENG_CHANNEL_VALUE:name ]\n        //    }\n        \n            packagingOptions {\n                exclude 'META-INF/LICENSE.txt'\n            }\n        \n            // 可以适当的打开Lint，检查是否存在隐藏问题\n            lintOptions {\n                checkReleaseBuilds false\n                abortOnError false\n            }\n        \n            android.dexOptions {\n                jumboMode = true\n                javaMaxHeapSize \"2g\"\n                maxProcessCount 8\n            }\n        \n        }\n        \n        // 替换编码方式，否则编译可能有中文乱码\n        tasks.withType(org.gradle.api.tasks.compile.JavaCompile) {\n            options.encoding = \"UTF-8\"\n        }\n\n\n\n\n相对于标准的我们在 android Task中新增了sourceSets这个Task制定了一些文件夹的目录，如果工程目录是标注的就不需要设置了\n\n\n在build.gradle同级新建一个gradle.properties\n里面可以用来存放build.gradle里面的一些参数\nSTORE_PASSWORD=nico\nKEY_ALIAS=nick\nKEY_PASSWORD=nico\n\n\n这个地方对应的脚本是signingConfigs》debug里面的参数 \n\n\n buildTypes 》debug 中的buildConfigField参数则会在编译时候  \n \n ![gradle01](https://github.com/liuyicheng3/learning-summary/blob/master/images/gradle%E5%88%86%E6%9E%9001.png?raw=true)\n \n                buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"Not yet\\\"\"\n                buildConfigField \"boolean\", \"DEVELOP_MODE\", \"true\"\n\n会在编译时候生成并存放在build/generated/source/buildConfig/...BuildConfig.java   \n\n\n\n            public final class BuildConfig {\n              public static final boolean DEBUG = Boolean.parseBoolean(\"true\");\n              public static final String APPLICATION_ID = \"com.lyc.study\";\n              public static final String BUILD_TYPE = \"debug\";\n              public static final String FLAVOR = \"own\";\n              public static final int VERSION_CODE = 100;\n              public static final String VERSION_NAME = \"1.0.0\";\n              // Fields from build type: debug\n              public static final boolean DEVELOP_MODE = true;\n              public static final String RELEASE_TIME = \"Not yet\";\n            }\n\n\n可以参考友盟的多渠道打包（github）\n\n\n一个介绍gradle比较好的网站   \nhttp://stormzhang.com/posts/\n\n\nhttps://segmentfault.com/a/1190000006915937\n\n这两个网站都是一系列的教程，建议一个一个的看\n","source":"_posts/Gradle小结.md","raw":"title: Gradle配置分析  \ndate: 2015-11-01 20:10:33\ncategories:\n- android\ntags:\n- 工具\n- 打包\n\n---\n\n\nTopicLevel的gradle    \n\n    buildscript {\n        repositories {\n            jcenter()\n        }\n        dependencies {\n            classpath 'com.android.tools.build:gradle:2.2.2'\n    \n            // NOTE: Do not place your application dependencies here; they belong\n            // in the individual module build.gradle files\n        }\n    }\n    allprojects {\n        repositories {\n            jcenter()\n        }\n    }\n    task clean(type: Delete) {\n        delete rootProject.buildDir\n    }\n\n\n\n\nMudule level的build.gradle  \n    \n    apply plugin: 'com.android.application'\n    \n    android {\n        compileSdkVersion 20\n        buildToolsVersion \"24.0.0\"\n    \n    \n        compileOptions{\n            sourceCompatibility JavaVersion.VERSION_1_8\n            targetCompatibility JavaVersion.VERSION_1_8\n        }\n    \n        defaultConfig {\n            applicationId \"com.lyc.study\"\n            minSdkVersion 15\n            targetSdkVersion 20\n            versionCode 1\n            versionName \"1.0\"\n            jackOptions{\n                enabled true\n            }\n        }\n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            }\n        }\n    }\n    \n    dependencies {\n        compile fileTree(include: ['*.jar'], dir: 'libs')\n        compile 'com.android.support:support-v4:+'\n        compile 'com.android.support:support-annotations:22.2.0'\n        compile 'com.android.support:support-v13:20.1.1'\n    }\n\n\n以上是标准的打包方式,下面是常用的我们自定义的内容   \n        \n        dependencies {\n            compile fileTree(include: '*.jar', dir: 'libs')\n            compile project(':google_services')\n    \n            // compile 'com.android.support:multidex:1.0.1'\n            compile 'top.zibin:Luban:1.0.9'\n            debugCompile 'com.bugtags.library:bugtags-lib:latest.integration'\n            \n            testCompile 'junit:junit:4.12'\n           \n        }\n        \n        android {\n            compileSdkVersion 21\n            buildToolsVersion '23.0.2'\n        \n            sourceSets {\n                main {\n                    manifest.srcFile 'AndroidManifest.xml'\n                    java.srcDirs = ['src']\n                    resources.srcDirs = ['src']\n                    aidl.srcDirs = ['src']\n                    renderscript.srcDirs = ['src']\n                    res.srcDirs = ['res']\n                    assets.srcDirs = ['assets']\n                    jniLibs.srcDirs = ['libs']\n                }\n        \n                test.setRoot('test')\n              \n                debug.setRoot('build-types/debug')\n                release.setRoot('build-types/release')\n            }\n        \n            signingConfigs {\n                debug {\n                    // 请配置好pub.key及其密码，或者改为使用debug.keystore\n                    storeFile file('pub.key') // storeFile file('debug.keystore')\n                    storePassword STORE_PASSWORD\n                    keyAlias KEY_ALIAS\n                    keyPassword KEY_PASSWORD\n                }\n                release {\n                    storeFile file('pub.key')\n                    storePassword STORE_PASSWORD\n                    keyAlias KEY_ALIAS\n                    keyPassword KEY_PASSWORD\n                }\n            }\n        \n            buildTypes {\n                debug {\n                    buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"Not yet\\\"\"\n                    buildConfigField \"boolean\", \"DEVELOP_MODE\", \"true\"\n                    signingConfig signingConfigs.debug\n        \n                    ndk{\n                        abiFilters 'armeabi', 'armeabi-v7a', 'x86' //,'arm64-v8a', 'x86_64', 'mips', 'mips64'\n                    }\n                }\n                release {\n                    buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"2017/1/1\\\"\" //  发布时修改为当天日期\n                    buildConfigField \"boolean\", \"DEVELOP_MODE\", \"false\" // 关闭开发者模式\n                    proguardFiles 'proguard.cfg'\n                    minifyEnabled true\n                    shrinkResources true\n                    debuggable false\n                    jniDebuggable false\n                    signingConfig signingConfigs.release\n        \n                    applicationVariants.all { variant ->\n                        variant.outputs.each { output ->\n                            def outputFile = output.outputFile\n                            if (outputFile != null && outputFile.name.endsWith('.apk')) {\n                                // APK命名格式 Going-release.apk TODO 发布时使用\n                                def fileName = \"Going-v${defaultConfig.versionName}-${defaultConfig.versionCode}-release.apk\"\n        //                         def fileName = \"Going.apk\"\n                                output.outputFile = new File(outputFile.parent, fileName)\n                            }\n                        }\n                    }\n                }\n            }\n        \n            defaultConfig {\n                minSdkVersion 14\n                targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n                versionCode 1000\n                versionName \"1.0.0\"\n                //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:\"googleMarket\" ]\n                multiDexEnabled false\n                multiDexKeepProguard file('multiDexKeep.pro')\n                resConfigs \"en\", \"zh_CN\", \"zh_TW\" //暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n            }\n        \n            productFlavors {\n                  own {}\n                  googleMarket {}\n  \n                  tencent {}\n                  baidu {}\n        \n       \n            }\n        \n        //    productFlavors.all { flavor ->\n        //        flavor.manifestPlaceholders = [ UMENG_CHANNEL_VALUE:name ]\n        //    }\n        \n            packagingOptions {\n                exclude 'META-INF/LICENSE.txt'\n            }\n        \n            // 可以适当的打开Lint，检查是否存在隐藏问题\n            lintOptions {\n                checkReleaseBuilds false\n                abortOnError false\n            }\n        \n            android.dexOptions {\n                jumboMode = true\n                javaMaxHeapSize \"2g\"\n                maxProcessCount 8\n            }\n        \n        }\n        \n        // 替换编码方式，否则编译可能有中文乱码\n        tasks.withType(org.gradle.api.tasks.compile.JavaCompile) {\n            options.encoding = \"UTF-8\"\n        }\n\n\n\n\n相对于标准的我们在 android Task中新增了sourceSets这个Task制定了一些文件夹的目录，如果工程目录是标注的就不需要设置了\n\n\n在build.gradle同级新建一个gradle.properties\n里面可以用来存放build.gradle里面的一些参数\nSTORE_PASSWORD=nico\nKEY_ALIAS=nick\nKEY_PASSWORD=nico\n\n\n这个地方对应的脚本是signingConfigs》debug里面的参数 \n\n\n buildTypes 》debug 中的buildConfigField参数则会在编译时候  \n \n ![gradle01](https://github.com/liuyicheng3/learning-summary/blob/master/images/gradle%E5%88%86%E6%9E%9001.png?raw=true)\n \n                buildConfigField \"String\", \"RELEASE_TIME\", \"\\\"Not yet\\\"\"\n                buildConfigField \"boolean\", \"DEVELOP_MODE\", \"true\"\n\n会在编译时候生成并存放在build/generated/source/buildConfig/...BuildConfig.java   \n\n\n\n            public final class BuildConfig {\n              public static final boolean DEBUG = Boolean.parseBoolean(\"true\");\n              public static final String APPLICATION_ID = \"com.lyc.study\";\n              public static final String BUILD_TYPE = \"debug\";\n              public static final String FLAVOR = \"own\";\n              public static final int VERSION_CODE = 100;\n              public static final String VERSION_NAME = \"1.0.0\";\n              // Fields from build type: debug\n              public static final boolean DEVELOP_MODE = true;\n              public static final String RELEASE_TIME = \"Not yet\";\n            }\n\n\n可以参考友盟的多渠道打包（github）\n\n\n一个介绍gradle比较好的网站   \nhttp://stormzhang.com/posts/\n\n\nhttps://segmentfault.com/a/1190000006915937\n\n这两个网站都是一系列的教程，建议一个一个的看\n","slug":"Gradle小结","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lbh000fsfjfnsimc2p1","content":"<p>TopicLevel的gradle    </p>\n<pre><code>buildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n</code></pre><p>Mudule level的build.gradle  </p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n\nandroid {\n    compileSdkVersion 20\n    buildToolsVersion &quot;24.0.0&quot;\n\n\n    compileOptions{\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    defaultConfig {\n        applicationId &quot;com.lyc.study&quot;\n        minSdkVersion 15\n        targetSdkVersion 20\n        versionCode 1\n        versionName &quot;1.0&quot;\n        jackOptions{\n            enabled true\n        }\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n\ndependencies {\n    compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)\n    compile &apos;com.android.support:support-v4:+&apos;\n    compile &apos;com.android.support:support-annotations:22.2.0&apos;\n    compile &apos;com.android.support:support-v13:20.1.1&apos;\n}\n</code></pre><p>以上是标准的打包方式,下面是常用的我们自定义的内容   </p>\n<pre><code>dependencies {\n    compile fileTree(include: &apos;*.jar&apos;, dir: &apos;libs&apos;)\n    compile project(&apos;:google_services&apos;)\n\n    // compile &apos;com.android.support:multidex:1.0.1&apos;\n    compile &apos;top.zibin:Luban:1.0.9&apos;\n    debugCompile &apos;com.bugtags.library:bugtags-lib:latest.integration&apos;\n\n    testCompile &apos;junit:junit:4.12&apos;\n\n}\n\nandroid {\n    compileSdkVersion 21\n    buildToolsVersion &apos;23.0.2&apos;\n\n    sourceSets {\n        main {\n            manifest.srcFile &apos;AndroidManifest.xml&apos;\n            java.srcDirs = [&apos;src&apos;]\n            resources.srcDirs = [&apos;src&apos;]\n            aidl.srcDirs = [&apos;src&apos;]\n            renderscript.srcDirs = [&apos;src&apos;]\n            res.srcDirs = [&apos;res&apos;]\n            assets.srcDirs = [&apos;assets&apos;]\n            jniLibs.srcDirs = [&apos;libs&apos;]\n        }\n\n        test.setRoot(&apos;test&apos;)\n\n        debug.setRoot(&apos;build-types/debug&apos;)\n        release.setRoot(&apos;build-types/release&apos;)\n    }\n\n    signingConfigs {\n        debug {\n            // 请配置好pub.key及其密码，或者改为使用debug.keystore\n            storeFile file(&apos;pub.key&apos;) // storeFile file(&apos;debug.keystore&apos;)\n            storePassword STORE_PASSWORD\n            keyAlias KEY_ALIAS\n            keyPassword KEY_PASSWORD\n        }\n        release {\n            storeFile file(&apos;pub.key&apos;)\n            storePassword STORE_PASSWORD\n            keyAlias KEY_ALIAS\n            keyPassword KEY_PASSWORD\n        }\n    }\n\n    buildTypes {\n        debug {\n            buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;Not yet\\&quot;&quot;\n            buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;true&quot;\n            signingConfig signingConfigs.debug\n\n            ndk{\n                abiFilters &apos;armeabi&apos;, &apos;armeabi-v7a&apos;, &apos;x86&apos; //,&apos;arm64-v8a&apos;, &apos;x86_64&apos;, &apos;mips&apos;, &apos;mips64&apos;\n            }\n        }\n        release {\n            buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;2017/1/1\\&quot;&quot; //  发布时修改为当天日期\n            buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;false&quot; // 关闭开发者模式\n            proguardFiles &apos;proguard.cfg&apos;\n            minifyEnabled true\n            shrinkResources true\n            debuggable false\n            jniDebuggable false\n            signingConfig signingConfigs.release\n\n            applicationVariants.all { variant -&gt;\n                variant.outputs.each { output -&gt;\n                    def outputFile = output.outputFile\n                    if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) {\n                        // APK命名格式 Going-release.apk TODO 发布时使用\n                        def fileName = &quot;Going-v${defaultConfig.versionName}-${defaultConfig.versionCode}-release.apk&quot;\n//                         def fileName = &quot;Going.apk&quot;\n                        output.outputFile = new File(outputFile.parent, fileName)\n                    }\n                }\n            }\n        }\n    }\n\n    defaultConfig {\n        minSdkVersion 14\n        targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n        versionCode 1000\n        versionName &quot;1.0.0&quot;\n        //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:&quot;googleMarket&quot; ]\n        multiDexEnabled false\n        multiDexKeepProguard file(&apos;multiDexKeep.pro&apos;)\n        resConfigs &quot;en&quot;, &quot;zh_CN&quot;, &quot;zh_TW&quot; //暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n    }\n\n    productFlavors {\n          own {}\n          googleMarket {}\n\n          tencent {}\n          baidu {}\n\n\n    }\n\n//    productFlavors.all { flavor -&gt;\n//        flavor.manifestPlaceholders = [ UMENG_CHANNEL_VALUE:name ]\n//    }\n\n    packagingOptions {\n        exclude &apos;META-INF/LICENSE.txt&apos;\n    }\n\n    // 可以适当的打开Lint，检查是否存在隐藏问题\n    lintOptions {\n        checkReleaseBuilds false\n        abortOnError false\n    }\n\n    android.dexOptions {\n        jumboMode = true\n        javaMaxHeapSize &quot;2g&quot;\n        maxProcessCount 8\n    }\n\n}\n\n// 替换编码方式，否则编译可能有中文乱码\ntasks.withType(org.gradle.api.tasks.compile.JavaCompile) {\n    options.encoding = &quot;UTF-8&quot;\n}\n</code></pre><p>相对于标准的我们在 android Task中新增了sourceSets这个Task制定了一些文件夹的目录，如果工程目录是标注的就不需要设置了</p>\n<p>在build.gradle同级新建一个gradle.properties<br>里面可以用来存放build.gradle里面的一些参数<br>STORE_PASSWORD=nico<br>KEY_ALIAS=nick<br>KEY_PASSWORD=nico</p>\n<p>这个地方对应的脚本是signingConfigs》debug里面的参数 </p>\n<p> buildTypes 》debug 中的buildConfigField参数则会在编译时候  </p>\n<p> <img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/gradle%E5%88%86%E6%9E%9001.png?raw=true\" alt=\"gradle01\"></p>\n<pre><code>buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;Not yet\\&quot;&quot;\nbuildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;true&quot;\n</code></pre><p>会在编译时候生成并存放在build/generated/source/buildConfig/…BuildConfig.java   </p>\n<pre><code>public final class BuildConfig {\n  public static final boolean DEBUG = Boolean.parseBoolean(&quot;true&quot;);\n  public static final String APPLICATION_ID = &quot;com.lyc.study&quot;;\n  public static final String BUILD_TYPE = &quot;debug&quot;;\n  public static final String FLAVOR = &quot;own&quot;;\n  public static final int VERSION_CODE = 100;\n  public static final String VERSION_NAME = &quot;1.0.0&quot;;\n  // Fields from build type: debug\n  public static final boolean DEVELOP_MODE = true;\n  public static final String RELEASE_TIME = &quot;Not yet&quot;;\n}\n</code></pre><p>可以参考友盟的多渠道打包（github）</p>\n<p>一个介绍gradle比较好的网站<br><a href=\"http://stormzhang.com/posts/\" target=\"_blank\" rel=\"external\">http://stormzhang.com/posts/</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006915937\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000006915937</a></p>\n<p>这两个网站都是一系列的教程，建议一个一个的看</p>\n","excerpt":"","more":"<p>TopicLevel的gradle    </p>\n<pre><code>buildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n</code></pre><p>Mudule level的build.gradle  </p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n\nandroid {\n    compileSdkVersion 20\n    buildToolsVersion &quot;24.0.0&quot;\n\n\n    compileOptions{\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    defaultConfig {\n        applicationId &quot;com.lyc.study&quot;\n        minSdkVersion 15\n        targetSdkVersion 20\n        versionCode 1\n        versionName &quot;1.0&quot;\n        jackOptions{\n            enabled true\n        }\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n\ndependencies {\n    compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)\n    compile &apos;com.android.support:support-v4:+&apos;\n    compile &apos;com.android.support:support-annotations:22.2.0&apos;\n    compile &apos;com.android.support:support-v13:20.1.1&apos;\n}\n</code></pre><p>以上是标准的打包方式,下面是常用的我们自定义的内容   </p>\n<pre><code>dependencies {\n    compile fileTree(include: &apos;*.jar&apos;, dir: &apos;libs&apos;)\n    compile project(&apos;:google_services&apos;)\n\n    // compile &apos;com.android.support:multidex:1.0.1&apos;\n    compile &apos;top.zibin:Luban:1.0.9&apos;\n    debugCompile &apos;com.bugtags.library:bugtags-lib:latest.integration&apos;\n\n    testCompile &apos;junit:junit:4.12&apos;\n\n}\n\nandroid {\n    compileSdkVersion 21\n    buildToolsVersion &apos;23.0.2&apos;\n\n    sourceSets {\n        main {\n            manifest.srcFile &apos;AndroidManifest.xml&apos;\n            java.srcDirs = [&apos;src&apos;]\n            resources.srcDirs = [&apos;src&apos;]\n            aidl.srcDirs = [&apos;src&apos;]\n            renderscript.srcDirs = [&apos;src&apos;]\n            res.srcDirs = [&apos;res&apos;]\n            assets.srcDirs = [&apos;assets&apos;]\n            jniLibs.srcDirs = [&apos;libs&apos;]\n        }\n\n        test.setRoot(&apos;test&apos;)\n\n        debug.setRoot(&apos;build-types/debug&apos;)\n        release.setRoot(&apos;build-types/release&apos;)\n    }\n\n    signingConfigs {\n        debug {\n            // 请配置好pub.key及其密码，或者改为使用debug.keystore\n            storeFile file(&apos;pub.key&apos;) // storeFile file(&apos;debug.keystore&apos;)\n            storePassword STORE_PASSWORD\n            keyAlias KEY_ALIAS\n            keyPassword KEY_PASSWORD\n        }\n        release {\n            storeFile file(&apos;pub.key&apos;)\n            storePassword STORE_PASSWORD\n            keyAlias KEY_ALIAS\n            keyPassword KEY_PASSWORD\n        }\n    }\n\n    buildTypes {\n        debug {\n            buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;Not yet\\&quot;&quot;\n            buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;true&quot;\n            signingConfig signingConfigs.debug\n\n            ndk{\n                abiFilters &apos;armeabi&apos;, &apos;armeabi-v7a&apos;, &apos;x86&apos; //,&apos;arm64-v8a&apos;, &apos;x86_64&apos;, &apos;mips&apos;, &apos;mips64&apos;\n            }\n        }\n        release {\n            buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;2017/1/1\\&quot;&quot; //  发布时修改为当天日期\n            buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;false&quot; // 关闭开发者模式\n            proguardFiles &apos;proguard.cfg&apos;\n            minifyEnabled true\n            shrinkResources true\n            debuggable false\n            jniDebuggable false\n            signingConfig signingConfigs.release\n\n            applicationVariants.all { variant -&gt;\n                variant.outputs.each { output -&gt;\n                    def outputFile = output.outputFile\n                    if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) {\n                        // APK命名格式 Going-release.apk TODO 发布时使用\n                        def fileName = &quot;Going-v${defaultConfig.versionName}-${defaultConfig.versionCode}-release.apk&quot;\n//                         def fileName = &quot;Going.apk&quot;\n                        output.outputFile = new File(outputFile.parent, fileName)\n                    }\n                }\n            }\n        }\n    }\n\n    defaultConfig {\n        minSdkVersion 14\n        targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限\n        versionCode 1000\n        versionName &quot;1.0.0&quot;\n        //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:&quot;googleMarket&quot; ]\n        multiDexEnabled false\n        multiDexKeepProguard file(&apos;multiDexKeep.pro&apos;)\n        resConfigs &quot;en&quot;, &quot;zh_CN&quot;, &quot;zh_TW&quot; //暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制\n    }\n\n    productFlavors {\n          own {}\n          googleMarket {}\n\n          tencent {}\n          baidu {}\n\n\n    }\n\n//    productFlavors.all { flavor -&gt;\n//        flavor.manifestPlaceholders = [ UMENG_CHANNEL_VALUE:name ]\n//    }\n\n    packagingOptions {\n        exclude &apos;META-INF/LICENSE.txt&apos;\n    }\n\n    // 可以适当的打开Lint，检查是否存在隐藏问题\n    lintOptions {\n        checkReleaseBuilds false\n        abortOnError false\n    }\n\n    android.dexOptions {\n        jumboMode = true\n        javaMaxHeapSize &quot;2g&quot;\n        maxProcessCount 8\n    }\n\n}\n\n// 替换编码方式，否则编译可能有中文乱码\ntasks.withType(org.gradle.api.tasks.compile.JavaCompile) {\n    options.encoding = &quot;UTF-8&quot;\n}\n</code></pre><p>相对于标准的我们在 android Task中新增了sourceSets这个Task制定了一些文件夹的目录，如果工程目录是标注的就不需要设置了</p>\n<p>在build.gradle同级新建一个gradle.properties<br>里面可以用来存放build.gradle里面的一些参数<br>STORE_PASSWORD=nico<br>KEY_ALIAS=nick<br>KEY_PASSWORD=nico</p>\n<p>这个地方对应的脚本是signingConfigs》debug里面的参数 </p>\n<p> buildTypes 》debug 中的buildConfigField参数则会在编译时候  </p>\n<p> <img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/gradle%E5%88%86%E6%9E%9001.png?raw=true\" alt=\"gradle01\"></p>\n<pre><code>buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\\&quot;Not yet\\&quot;&quot;\nbuildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;true&quot;\n</code></pre><p>会在编译时候生成并存放在build/generated/source/buildConfig/…BuildConfig.java   </p>\n<pre><code>public final class BuildConfig {\n  public static final boolean DEBUG = Boolean.parseBoolean(&quot;true&quot;);\n  public static final String APPLICATION_ID = &quot;com.lyc.study&quot;;\n  public static final String BUILD_TYPE = &quot;debug&quot;;\n  public static final String FLAVOR = &quot;own&quot;;\n  public static final int VERSION_CODE = 100;\n  public static final String VERSION_NAME = &quot;1.0.0&quot;;\n  // Fields from build type: debug\n  public static final boolean DEVELOP_MODE = true;\n  public static final String RELEASE_TIME = &quot;Not yet&quot;;\n}\n</code></pre><p>可以参考友盟的多渠道打包（github）</p>\n<p>一个介绍gradle比较好的网站<br><a href=\"http://stormzhang.com/posts/\">http://stormzhang.com/posts/</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006915937\">https://segmentfault.com/a/1190000006915937</a></p>\n<p>这两个网站都是一系列的教程，建议一个一个的看</p>\n"},{"title":"Hugo方法耗时监控","date":"2018-03-01T16:00:00.000Z","_content":"\n# 使用方法\n1. 在Android Project的build.gradle添加dependence： \n\n\t\tbuildscript {\n\t\t    repositories {\n\t\t        jcenter()\n\t\t    }\n\t\t    dependencies {\n\t\t        classpath 'com.android.tools.build:gradle:2.3.3'\n\t\t        classpath 'com.jakewharton.hugo:hugo-plugin:1.2.1'//关键所在\n\t\t    }\n\t\t}\n\n2. 在Module的build.gradle文件中添加Hugo Plugin的应用\n\n\t\tapply plugin:'com.jakewharton.hugo'//关键所在  \n\n3. 在相应的方法前，添加@DebugLog\n\n\timport hugo.weaving.DebugLog;\n\n\t......\n\n \t@DebugLog //关键所在\n    private int add(int a, int b){\n        return a+b;\n    }\n\n\nps：调用Hugo后，Hugo自动生效。由于仅在Debug中生效，因此，可以不用关闭\n\n# 参考文章  \n使用方法:http://blog.csdn.net/daihuimaozideren/article/details/78231983  \n原理分析:http://blog.csdn.net/xxxzhi/article/details/53048476  \n","source":"_posts/Hugo方法耗时监控.md","raw":"title: Hugo方法耗时监控\ndate: 2018-3-2 \ncategories:\n- Android\ntags:\n- Android\n- 性能监控\n\n\n---\n\n# 使用方法\n1. 在Android Project的build.gradle添加dependence： \n\n\t\tbuildscript {\n\t\t    repositories {\n\t\t        jcenter()\n\t\t    }\n\t\t    dependencies {\n\t\t        classpath 'com.android.tools.build:gradle:2.3.3'\n\t\t        classpath 'com.jakewharton.hugo:hugo-plugin:1.2.1'//关键所在\n\t\t    }\n\t\t}\n\n2. 在Module的build.gradle文件中添加Hugo Plugin的应用\n\n\t\tapply plugin:'com.jakewharton.hugo'//关键所在  \n\n3. 在相应的方法前，添加@DebugLog\n\n\timport hugo.weaving.DebugLog;\n\n\t......\n\n \t@DebugLog //关键所在\n    private int add(int a, int b){\n        return a+b;\n    }\n\n\nps：调用Hugo后，Hugo自动生效。由于仅在Debug中生效，因此，可以不用关闭\n\n# 参考文章  \n使用方法:http://blog.csdn.net/daihuimaozideren/article/details/78231983  \n原理分析:http://blog.csdn.net/xxxzhi/article/details/53048476  \n","slug":"Hugo方法耗时监控","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lbu000isfjf8lna899k","content":"<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><ol>\n<li><p>在Android Project的build.gradle添加dependence： </p>\n<pre><code>buildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:2.3.3&apos;\n        classpath &apos;com.jakewharton.hugo:hugo-plugin:1.2.1&apos;//关键所在\n    }\n}\n</code></pre></li>\n<li><p>在Module的build.gradle文件中添加Hugo Plugin的应用</p>\n<pre><code>apply plugin:&apos;com.jakewharton.hugo&apos;//关键所在  \n</code></pre></li>\n<li><p>在相应的方法前，添加@DebugLog</p>\n<p> import hugo.weaving.DebugLog;</p>\n<p> ……</p>\n<p>  @DebugLog //关键所在<br> private int add(int a, int b){</p>\n<pre><code>return a+b;\n</code></pre><p> }</p>\n</li>\n</ol>\n<p>ps：调用Hugo后，Hugo自动生效。由于仅在Debug中生效，因此，可以不用关闭</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p>使用方法:<a href=\"http://blog.csdn.net/daihuimaozideren/article/details/78231983\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/daihuimaozideren/article/details/78231983</a><br>原理分析:<a href=\"http://blog.csdn.net/xxxzhi/article/details/53048476\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/xxxzhi/article/details/53048476</a>  </p>\n","excerpt":"","more":"<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><ol>\n<li><p>在Android Project的build.gradle添加dependence： </p>\n<pre><code>buildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:2.3.3&apos;\n        classpath &apos;com.jakewharton.hugo:hugo-plugin:1.2.1&apos;//关键所在\n    }\n}\n</code></pre></li>\n<li><p>在Module的build.gradle文件中添加Hugo Plugin的应用</p>\n<pre><code>apply plugin:&apos;com.jakewharton.hugo&apos;//关键所在  \n</code></pre></li>\n<li><p>在相应的方法前，添加@DebugLog</p>\n<p> import hugo.weaving.DebugLog;</p>\n<p> ……</p>\n<p>  @DebugLog //关键所在<br> private int add(int a, int b){</p>\n<pre><code>return a+b;\n</code></pre><p> }</p>\n</li>\n</ol>\n<p>ps：调用Hugo后，Hugo自动生效。由于仅在Debug中生效，因此，可以不用关闭</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><p>使用方法:<a href=\"http://blog.csdn.net/daihuimaozideren/article/details/78231983\">http://blog.csdn.net/daihuimaozideren/article/details/78231983</a><br>原理分析:<a href=\"http://blog.csdn.net/xxxzhi/article/details/53048476\">http://blog.csdn.net/xxxzhi/article/details/53048476</a>  </p>\n"},{"title":"Okhttp核心流程","date":"2015-11-01T12:10:33.000Z","_content":"\n\n## Interface：OkhttpClient（singleton）  Request  Response\n\n## 主要由以下三部分 组成  \n\n### 1. 任务调度： 核心类disruptor（singleton） \n\na. 线程池   \nb. 队列\n\n\n      /** Ready async calls in the order they'll be run. */\n      private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n      \n      /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n      private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n      \n      /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n       private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n\n(由于okhttp两种 运行模式   sync  和async）\n\n### 2. 网络请求   \n* 核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） \n* 每个请求会生成一个Request  \n* 然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  \n\n\nokhttp一个请求的完整流程图  \n ![image](http://blog.piasy.com/img/201607/okhttp_full_process.png)\n\n在realcall的execute方法中会调用     \n\n\n    client.dispatcher().executed(this);//问题1  \n    Response result = getResponseWithInterceptorChain(false);//问题2  \n \n获得请求结果.    \n现在看问题1  在这里面干了写什么   \n其实就是 dispatcher记录任务而已 ，没有任何执行方法  \n核心在问题2中  \n她会  \n\n\n    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\n    return chain.proceed(originalRequest);\n也就是生成拦截器 ，并用这个拦截器启动这个请求\n继续进入proceed 可以看到\n进入了ApplicationInterceptorChain的getresponse方法\n开始构造HttpEngine    \n\n    engine.sendRequest();//问题21\n    engine.readResponse();//问题22\n   \n在问题21中其实就是  Rfc 标准的一种 实现  \n\n    InternalCache responseCache = Internal.instance.internalCache(client);\n    Response cacheCandidate = responseCache != null\n        ? responseCache.get(request)\n        : null;\n        \n就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache\n这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程 \n当取到值后还要根据http cache的rfc标准  判断  是否合理能使用\nnew CacheStrategy.Factory(now, request, cacheCandidate).get();\n在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  \n\n这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）\n\n      if (etag != null) {\n        conditionalRequestBuilder.header(\"If-None-Match\", etag);\n      } else if (lastModified != null) {\n        conditionalRequestBuilder.header(\"If-Modified-Since\", lastModifiedString);\n      } else if (servedDate != null) {\n        conditionalRequestBuilder.header(\"If-Modified-Since\", servedDateString);\n      }\n\n      Request conditionalRequest = conditionalRequestBuilder.build();\n\n这是请求前的工作\n现在开始发送请求\n\n      httpStream = connect();\n      httpStream.setHttpEngine(this);\n这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）\n\n    streamAllocation.newStream(client.connectTimeoutMillis(),\n    client.readTimeoutMillis(), client.writeTimeoutMillis(),\n    client.retryOnConnectionFailure(), doExtensiveHealthChecks);\n解决的问题 是socket连接重用和  route\n先是从连接池中找\n\n\n     // Attempt to get a connection from the pool.\n      RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);\n      if (pooledConnection != null) {\n        this.connection = pooledConnection;\n        return pooledConnection;\n      }\n如果没有的话就看route可以重用嘛\n\n     if (selectedRoute == null) {\n      selectedRoute = routeSelector.next();\n      synchronized (connectionPool) {\n        route = selectedRoute;\n      }\n    }\n    RealConnection newConnection = new RealConnection(selectedRoute);\n    acquire(newConnection);\n（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止\n\n    RouteDatabase里的Set<Route> failedRoutes = new LinkedHashSet<>()）\n弄完之后就是放如   \n\n     Internal.instance.put(connectionPool, newConnection);\n连接池中  方便下次继续使用\n下一步 就是建立socket连接的过程\n\n     newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),\n        connectionRetryEnabled);\n    routeDatabase().connected(newConnection.route());\n跟进去 就是\n\n       connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n继续\n\n     try {\n      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);\n    } catch (ConnectException e) {\n      throw new ConnectException(\"Failed to connect to \" + route.socketAddress());\n    }\n    source = Okio.buffer(Okio.source(rawSocket));\n    sink = Okio.buffer(Okio.sink(rawSocket));\n连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的\n然后才是真正发送这个请求的过程\n\n       httpStream.writeRequestHeaders(networkRequest);\n       requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);\n继续跟进\n\n     httpEngine.writingRequestHeaders();\n      String requestLine = RequestLine.get(\n        request, httpEngine.getConnection().route().proxy().type());\n    writeRequest(request.headers(), requestLine);\n\n》》\n\n    ** Returns bytes of a request header for sending on an HTTP transport. */\n    public void writeRequest(Headers headers, String requestLine) throws IOException {\n    if (state != STATE_IDLE) throw new IllegalStateException(\"state: \" + state);\n    sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\");\n    for (int i = 0, size = headers.size(); i < size; i++) {\n      sink.writeUtf8(headers.name(i))\n          .writeUtf8(\": \")\n          .writeUtf8(headers.value(i))\n          .writeUtf8(\"\\r\\n\");\n    }\n    sink.writeUtf8(\"\\r\\n\");\n    state = STATE_OPEN_REQUEST_BODY;\n    }\n\n\n读过程\n就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink\n\n\n\n\n\n\n\n到此 请求reponse的工作做完了\n现在 如果是需要真正发送网络请求就也就是问题22\n\n      networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);\n》》\n\n     engin.readResponse\n》》\n\n      // Write the request body to the socket.\n      if (requestBodyOut != null) {\n        if (bufferedRequestBody != null) {\n          // This also closes the wrapped requestBodyOut.\n          bufferedRequestBody.close();\n        } else {\n          requestBodyOut.close();\n        }\n        if (requestBodyOut instanceof RetryableSink) {\n          httpStream.writeRequestBody((RetryableSink) requestBodyOut);\n        }\n      }\n\n      networkResponse = readNetworkResponse();\n\n》》\n\n    Response readNetworkResponse() throws IOException {\n    httpStream.finishRequest();\n\n    Response networkResponse = httpStream.readResponseHeaders()\n        .request(networkRequest)\n        .handshake(streamAllocation.connection().handshake())\n        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))\n        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))\n        .build();\n\n    if (!forWebSocket) {\n      networkResponse = networkResponse.newBuilder()\n          .body(httpStream.openResponseBody(networkResponse))\n          .build();\n    }\n\n    if (\"close\".equalsIgnoreCase(networkResponse.request().header(\"Connection\"))\n        || \"close\".equalsIgnoreCase(networkResponse.header(\"Connection\"))) {\n      streamAllocation.noNewStreams();\n    }\n\n    return networkResponse;\n  }\n\n解析和返回\n\n      Response response = engine.getResponse();\n\n\n     //tobe continue（已经 cache过程 请求重试过程）\n      Request followUp = engine.followUpRequest();\n\n\n\n### 3. cache管理\n\n\n\n\n最后附上 相关的http请求cache的rfc内容\n ![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg)\n\n### 每个状态的详细说明如下：\n\n#### 1. Last-Modified  \n在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：  \nLast-Modified:Tue, 24 Feb 2009 08:01:04 GMT  \n客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：  \nIf-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT  \n如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。  \n注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  \n\n#### 2. Etag工作原理  \nHTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：  \nEtag:“5d8c72a5edda8d6a:3239″  \n客户端的查询更新格式是这样的： \nIf-None-Match:“5d8c72a5edda8d6a:3239″  \n如果ETag没改变，则返回状态304。  \n即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″  \n标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。  \nIf-None-Match:“5d8c72a5edda8d6a:3239“  \n,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  \n\n#### 3. Expires  \n给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT  \n需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  \n\n#### 4. Last-Modified和Expires  \nLast-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  \n\n\n#### 5. Etag和Expires  \n如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  \n\n\n#### 6. Last-Modified和Etag  \n分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败  \n分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)  \nLast-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存  \n过程如下:  \n* 客户端请求一个页面（A）。  \n* 服务器返回页面A，并在给A加上一个Last-Modified/ETag。  \n* 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  \n* 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  \n* 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  \n\n\n备注：   \n* Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  \n* WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  \n* 客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  \n* 通过上述值到服务器端检查，判断文件是否继续缓存；  \n\n\n#### 7.关于 Cache-Control: max-age=秒 和 Expires  \nExpires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）  \nmax-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。  \n如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。  \nExpires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。  \nExpires =max-age +   “每次下载时的当前的request时间”  \n所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   \n\n\n\n","source":"_posts/Okhttp核心流程.md","raw":"title: Okhttp核心流程\ndate: 2015-11-01 20:10:33\ncategories:\n- android\ntags:\n- 网络层\n\n---\n\n\n## Interface：OkhttpClient（singleton）  Request  Response\n\n## 主要由以下三部分 组成  \n\n### 1. 任务调度： 核心类disruptor（singleton） \n\na. 线程池   \nb. 队列\n\n\n      /** Ready async calls in the order they'll be run. */\n      private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n      \n      /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n      private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n      \n      /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n       private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n\n(由于okhttp两种 运行模式   sync  和async）\n\n### 2. 网络请求   \n* 核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） \n* 每个请求会生成一个Request  \n* 然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  \n\n\nokhttp一个请求的完整流程图  \n ![image](http://blog.piasy.com/img/201607/okhttp_full_process.png)\n\n在realcall的execute方法中会调用     \n\n\n    client.dispatcher().executed(this);//问题1  \n    Response result = getResponseWithInterceptorChain(false);//问题2  \n \n获得请求结果.    \n现在看问题1  在这里面干了写什么   \n其实就是 dispatcher记录任务而已 ，没有任何执行方法  \n核心在问题2中  \n她会  \n\n\n    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\n    return chain.proceed(originalRequest);\n也就是生成拦截器 ，并用这个拦截器启动这个请求\n继续进入proceed 可以看到\n进入了ApplicationInterceptorChain的getresponse方法\n开始构造HttpEngine    \n\n    engine.sendRequest();//问题21\n    engine.readResponse();//问题22\n   \n在问题21中其实就是  Rfc 标准的一种 实现  \n\n    InternalCache responseCache = Internal.instance.internalCache(client);\n    Response cacheCandidate = responseCache != null\n        ? responseCache.get(request)\n        : null;\n        \n就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache\n这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程 \n当取到值后还要根据http cache的rfc标准  判断  是否合理能使用\nnew CacheStrategy.Factory(now, request, cacheCandidate).get();\n在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  \n\n这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）\n\n      if (etag != null) {\n        conditionalRequestBuilder.header(\"If-None-Match\", etag);\n      } else if (lastModified != null) {\n        conditionalRequestBuilder.header(\"If-Modified-Since\", lastModifiedString);\n      } else if (servedDate != null) {\n        conditionalRequestBuilder.header(\"If-Modified-Since\", servedDateString);\n      }\n\n      Request conditionalRequest = conditionalRequestBuilder.build();\n\n这是请求前的工作\n现在开始发送请求\n\n      httpStream = connect();\n      httpStream.setHttpEngine(this);\n这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）\n\n    streamAllocation.newStream(client.connectTimeoutMillis(),\n    client.readTimeoutMillis(), client.writeTimeoutMillis(),\n    client.retryOnConnectionFailure(), doExtensiveHealthChecks);\n解决的问题 是socket连接重用和  route\n先是从连接池中找\n\n\n     // Attempt to get a connection from the pool.\n      RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);\n      if (pooledConnection != null) {\n        this.connection = pooledConnection;\n        return pooledConnection;\n      }\n如果没有的话就看route可以重用嘛\n\n     if (selectedRoute == null) {\n      selectedRoute = routeSelector.next();\n      synchronized (connectionPool) {\n        route = selectedRoute;\n      }\n    }\n    RealConnection newConnection = new RealConnection(selectedRoute);\n    acquire(newConnection);\n（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止\n\n    RouteDatabase里的Set<Route> failedRoutes = new LinkedHashSet<>()）\n弄完之后就是放如   \n\n     Internal.instance.put(connectionPool, newConnection);\n连接池中  方便下次继续使用\n下一步 就是建立socket连接的过程\n\n     newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),\n        connectionRetryEnabled);\n    routeDatabase().connected(newConnection.route());\n跟进去 就是\n\n       connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n继续\n\n     try {\n      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);\n    } catch (ConnectException e) {\n      throw new ConnectException(\"Failed to connect to \" + route.socketAddress());\n    }\n    source = Okio.buffer(Okio.source(rawSocket));\n    sink = Okio.buffer(Okio.sink(rawSocket));\n连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的\n然后才是真正发送这个请求的过程\n\n       httpStream.writeRequestHeaders(networkRequest);\n       requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);\n继续跟进\n\n     httpEngine.writingRequestHeaders();\n      String requestLine = RequestLine.get(\n        request, httpEngine.getConnection().route().proxy().type());\n    writeRequest(request.headers(), requestLine);\n\n》》\n\n    ** Returns bytes of a request header for sending on an HTTP transport. */\n    public void writeRequest(Headers headers, String requestLine) throws IOException {\n    if (state != STATE_IDLE) throw new IllegalStateException(\"state: \" + state);\n    sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\");\n    for (int i = 0, size = headers.size(); i < size; i++) {\n      sink.writeUtf8(headers.name(i))\n          .writeUtf8(\": \")\n          .writeUtf8(headers.value(i))\n          .writeUtf8(\"\\r\\n\");\n    }\n    sink.writeUtf8(\"\\r\\n\");\n    state = STATE_OPEN_REQUEST_BODY;\n    }\n\n\n读过程\n就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink\n\n\n\n\n\n\n\n到此 请求reponse的工作做完了\n现在 如果是需要真正发送网络请求就也就是问题22\n\n      networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);\n》》\n\n     engin.readResponse\n》》\n\n      // Write the request body to the socket.\n      if (requestBodyOut != null) {\n        if (bufferedRequestBody != null) {\n          // This also closes the wrapped requestBodyOut.\n          bufferedRequestBody.close();\n        } else {\n          requestBodyOut.close();\n        }\n        if (requestBodyOut instanceof RetryableSink) {\n          httpStream.writeRequestBody((RetryableSink) requestBodyOut);\n        }\n      }\n\n      networkResponse = readNetworkResponse();\n\n》》\n\n    Response readNetworkResponse() throws IOException {\n    httpStream.finishRequest();\n\n    Response networkResponse = httpStream.readResponseHeaders()\n        .request(networkRequest)\n        .handshake(streamAllocation.connection().handshake())\n        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))\n        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))\n        .build();\n\n    if (!forWebSocket) {\n      networkResponse = networkResponse.newBuilder()\n          .body(httpStream.openResponseBody(networkResponse))\n          .build();\n    }\n\n    if (\"close\".equalsIgnoreCase(networkResponse.request().header(\"Connection\"))\n        || \"close\".equalsIgnoreCase(networkResponse.header(\"Connection\"))) {\n      streamAllocation.noNewStreams();\n    }\n\n    return networkResponse;\n  }\n\n解析和返回\n\n      Response response = engine.getResponse();\n\n\n     //tobe continue（已经 cache过程 请求重试过程）\n      Request followUp = engine.followUpRequest();\n\n\n\n### 3. cache管理\n\n\n\n\n最后附上 相关的http请求cache的rfc内容\n ![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg)\n\n### 每个状态的详细说明如下：\n\n#### 1. Last-Modified  \n在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：  \nLast-Modified:Tue, 24 Feb 2009 08:01:04 GMT  \n客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：  \nIf-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT  \n如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。  \n注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  \n\n#### 2. Etag工作原理  \nHTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：  \nEtag:“5d8c72a5edda8d6a:3239″  \n客户端的查询更新格式是这样的： \nIf-None-Match:“5d8c72a5edda8d6a:3239″  \n如果ETag没改变，则返回状态304。  \n即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″  \n标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。  \nIf-None-Match:“5d8c72a5edda8d6a:3239“  \n,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  \n\n#### 3. Expires  \n给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT  \n需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  \n\n#### 4. Last-Modified和Expires  \nLast-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  \n\n\n#### 5. Etag和Expires  \n如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  \n\n\n#### 6. Last-Modified和Etag  \n分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败  \n分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)  \nLast-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存  \n过程如下:  \n* 客户端请求一个页面（A）。  \n* 服务器返回页面A，并在给A加上一个Last-Modified/ETag。  \n* 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  \n* 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  \n* 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  \n\n\n备注：   \n* Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  \n* WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  \n* 客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  \n* 通过上述值到服务器端检查，判断文件是否继续缓存；  \n\n\n#### 7.关于 Cache-Control: max-age=秒 和 Expires  \nExpires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）  \nmax-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。  \n如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。  \nExpires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。  \nExpires =max-age +   “每次下载时的当前的request时间”  \n所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   \n\n\n\n","slug":"Okhttp核心流程","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lby000nsfjfn1twsy0l","content":"<h2 id=\"Interface：OkhttpClient（singleton）-Request-Response\"><a href=\"#Interface：OkhttpClient（singleton）-Request-Response\" class=\"headerlink\" title=\"Interface：OkhttpClient（singleton）  Request  Response\"></a>Interface：OkhttpClient（singleton）  Request  Response</h2><h2 id=\"主要由以下三部分-组成\"><a href=\"#主要由以下三部分-组成\" class=\"headerlink\" title=\"主要由以下三部分 组成\"></a>主要由以下三部分 组成</h2><h3 id=\"1-任务调度：-核心类disruptor（singleton）\"><a href=\"#1-任务调度：-核心类disruptor（singleton）\" class=\"headerlink\" title=\"1. 任务调度： 核心类disruptor（singleton）\"></a>1. 任务调度： 核心类disruptor（singleton）</h3><p>a. 线程池<br>b. 队列</p>\n<pre><code>/** Ready async calls in the order they&apos;ll be run. */\nprivate final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */\n private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();\n</code></pre><p>(由于okhttp两种 运行模式   sync  和async）</p>\n<h3 id=\"2-网络请求\"><a href=\"#2-网络请求\" class=\"headerlink\" title=\"2. 网络请求\"></a>2. 网络请求</h3><ul>\n<li>核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） </li>\n<li>每个请求会生成一个Request  </li>\n<li>然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  </li>\n</ul>\n<p>okhttp一个请求的完整流程图<br> <img src=\"http://blog.piasy.com/img/201607/okhttp_full_process.png\" alt=\"image\"></p>\n<p>在realcall的execute方法中会调用     </p>\n<pre><code>client.dispatcher().executed(this);//问题1  \nResponse result = getResponseWithInterceptorChain(false);//问题2  \n</code></pre><p>获得请求结果.<br>现在看问题1  在这里面干了写什么<br>其实就是 dispatcher记录任务而已 ，没有任何执行方法<br>核心在问题2中<br>她会  </p>\n<pre><code>Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\nreturn chain.proceed(originalRequest);\n</code></pre><p>也就是生成拦截器 ，并用这个拦截器启动这个请求<br>继续进入proceed 可以看到<br>进入了ApplicationInterceptorChain的getresponse方法<br>开始构造HttpEngine    </p>\n<pre><code>engine.sendRequest();//问题21\nengine.readResponse();//问题22\n</code></pre><p>在问题21中其实就是  Rfc 标准的一种 实现  </p>\n<pre><code>InternalCache responseCache = Internal.instance.internalCache(client);\nResponse cacheCandidate = responseCache != null\n    ? responseCache.get(request)\n    : null;\n</code></pre><p>就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache<br>这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程<br>当取到值后还要根据http cache的rfc标准  判断  是否合理能使用<br>new CacheStrategy.Factory(now, request, cacheCandidate).get();<br>在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  </p>\n<p>这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）</p>\n<pre><code>if (etag != null) {\n  conditionalRequestBuilder.header(&quot;If-None-Match&quot;, etag);\n} else if (lastModified != null) {\n  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, lastModifiedString);\n} else if (servedDate != null) {\n  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, servedDateString);\n}\n\nRequest conditionalRequest = conditionalRequestBuilder.build();\n</code></pre><p>这是请求前的工作<br>现在开始发送请求</p>\n<pre><code>httpStream = connect();\nhttpStream.setHttpEngine(this);\n</code></pre><p>这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）</p>\n<pre><code>streamAllocation.newStream(client.connectTimeoutMillis(),\nclient.readTimeoutMillis(), client.writeTimeoutMillis(),\nclient.retryOnConnectionFailure(), doExtensiveHealthChecks);\n</code></pre><p>解决的问题 是socket连接重用和  route<br>先是从连接池中找</p>\n<pre><code>// Attempt to get a connection from the pool.\n RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);\n if (pooledConnection != null) {\n   this.connection = pooledConnection;\n   return pooledConnection;\n }\n</code></pre><p>如果没有的话就看route可以重用嘛</p>\n<pre><code> if (selectedRoute == null) {\n  selectedRoute = routeSelector.next();\n  synchronized (connectionPool) {\n    route = selectedRoute;\n  }\n}\nRealConnection newConnection = new RealConnection(selectedRoute);\nacquire(newConnection);\n</code></pre><p>（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止</p>\n<pre><code>RouteDatabase里的Set&lt;Route&gt; failedRoutes = new LinkedHashSet&lt;&gt;()）\n</code></pre><p>弄完之后就是放如   </p>\n<pre><code>Internal.instance.put(connectionPool, newConnection);\n</code></pre><p>连接池中  方便下次继续使用<br>下一步 就是建立socket连接的过程</p>\n<pre><code> newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),\n    connectionRetryEnabled);\nrouteDatabase().connected(newConnection.route());\n</code></pre><p>跟进去 就是</p>\n<pre><code>connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n</code></pre><p>继续</p>\n<pre><code> try {\n  Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);\n} catch (ConnectException e) {\n  throw new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress());\n}\nsource = Okio.buffer(Okio.source(rawSocket));\nsink = Okio.buffer(Okio.sink(rawSocket));\n</code></pre><p>连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的<br>然后才是真正发送这个请求的过程</p>\n<pre><code>httpStream.writeRequestHeaders(networkRequest);\nrequestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);\n</code></pre><p>继续跟进</p>\n<pre><code> httpEngine.writingRequestHeaders();\n  String requestLine = RequestLine.get(\n    request, httpEngine.getConnection().route().proxy().type());\nwriteRequest(request.headers(), requestLine);\n</code></pre><p>》》</p>\n<pre><code>** Returns bytes of a request header for sending on an HTTP transport. */\npublic void writeRequest(Headers headers, String requestLine) throws IOException {\nif (state != STATE_IDLE) throw new IllegalStateException(&quot;state: &quot; + state);\nsink.writeUtf8(requestLine).writeUtf8(&quot;\\r\\n&quot;);\nfor (int i = 0, size = headers.size(); i &lt; size; i++) {\n  sink.writeUtf8(headers.name(i))\n      .writeUtf8(&quot;: &quot;)\n      .writeUtf8(headers.value(i))\n      .writeUtf8(&quot;\\r\\n&quot;);\n}\nsink.writeUtf8(&quot;\\r\\n&quot;);\nstate = STATE_OPEN_REQUEST_BODY;\n}\n</code></pre><p>读过程<br>就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink</p>\n<p>到此 请求reponse的工作做完了<br>现在 如果是需要真正发送网络请求就也就是问题22</p>\n<pre><code>networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);\n</code></pre><p>》》</p>\n<pre><code>engin.readResponse\n</code></pre><p>》》</p>\n<pre><code>// Write the request body to the socket.\nif (requestBodyOut != null) {\n  if (bufferedRequestBody != null) {\n    // This also closes the wrapped requestBodyOut.\n    bufferedRequestBody.close();\n  } else {\n    requestBodyOut.close();\n  }\n  if (requestBodyOut instanceof RetryableSink) {\n    httpStream.writeRequestBody((RetryableSink) requestBodyOut);\n  }\n}\n\nnetworkResponse = readNetworkResponse();\n</code></pre><p>》》</p>\n<pre><code>Response readNetworkResponse() throws IOException {\nhttpStream.finishRequest();\n\nResponse networkResponse = httpStream.readResponseHeaders()\n    .request(networkRequest)\n    .handshake(streamAllocation.connection().handshake())\n    .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))\n    .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))\n    .build();\n\nif (!forWebSocket) {\n  networkResponse = networkResponse.newBuilder()\n      .body(httpStream.openResponseBody(networkResponse))\n      .build();\n}\n\nif (&quot;close&quot;.equalsIgnoreCase(networkResponse.request().header(&quot;Connection&quot;))\n    || &quot;close&quot;.equalsIgnoreCase(networkResponse.header(&quot;Connection&quot;))) {\n  streamAllocation.noNewStreams();\n}\n\nreturn networkResponse;\n</code></pre><p>  }</p>\n<p>解析和返回</p>\n<pre><code> Response response = engine.getResponse();\n\n\n//tobe continue（已经 cache过程 请求重试过程）\n Request followUp = engine.followUpRequest();\n</code></pre><h3 id=\"3-cache管理\"><a href=\"#3-cache管理\" class=\"headerlink\" title=\"3. cache管理\"></a>3. cache管理</h3><p>最后附上 相关的http请求cache的rfc内容<br> <img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg\" alt=\"image\"></p>\n<h3 id=\"每个状态的详细说明如下：\"><a href=\"#每个状态的详细说明如下：\" class=\"headerlink\" title=\"每个状态的详细说明如下：\"></a>每个状态的详细说明如下：</h3><h4 id=\"1-Last-Modified\"><a href=\"#1-Last-Modified\" class=\"headerlink\" title=\"1. Last-Modified\"></a>1. Last-Modified</h4><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：<br>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT<br>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：<br>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT<br>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。<br>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  </p>\n<h4 id=\"2-Etag工作原理\"><a href=\"#2-Etag工作原理\" class=\"headerlink\" title=\"2. Etag工作原理\"></a>2. Etag工作原理</h4><p>HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：<br>Etag:“5d8c72a5edda8d6a:3239″<br>客户端的查询更新格式是这样的：<br>If-None-Match:“5d8c72a5edda8d6a:3239″<br>如果ETag没改变，则返回状态304。<br>即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″<br>标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。<br>If-None-Match:“5d8c72a5edda8d6a:3239“<br>,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  </p>\n<h4 id=\"3-Expires\"><a href=\"#3-Expires\" class=\"headerlink\" title=\"3. Expires\"></a>3. Expires</h4><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT<br>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  </p>\n<h4 id=\"4-Last-Modified和Expires\"><a href=\"#4-Last-Modified和Expires\" class=\"headerlink\" title=\"4. Last-Modified和Expires\"></a>4. Last-Modified和Expires</h4><p>Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  </p>\n<h4 id=\"5-Etag和Expires\"><a href=\"#5-Etag和Expires\" class=\"headerlink\" title=\"5. Etag和Expires\"></a>5. Etag和Expires</h4><p>如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  </p>\n<h4 id=\"6-Last-Modified和Etag\"><a href=\"#6-Last-Modified和Etag\" class=\"headerlink\" title=\"6. Last-Modified和Etag\"></a>6. Last-Modified和Etag</h4><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败<br>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)<br>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存<br>过程如下:  </p>\n<ul>\n<li>客户端请求一个页面（A）。  </li>\n<li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。  </li>\n<li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  </li>\n<li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  </li>\n<li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  </li>\n</ul>\n<p>备注：   </p>\n<ul>\n<li>Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  </li>\n<li>WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  </li>\n<li>客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  </li>\n<li>通过上述值到服务器端检查，判断文件是否继续缓存；  </li>\n</ul>\n<h4 id=\"7-关于-Cache-Control-max-age-秒-和-Expires\"><a href=\"#7-关于-Cache-Control-max-age-秒-和-Expires\" class=\"headerlink\" title=\"7.关于 Cache-Control: max-age=秒 和 Expires\"></a>7.关于 Cache-Control: max-age=秒 和 Expires</h4><p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。<br>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。<br>Expires =max-age +   “每次下载时的当前的request时间”<br>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   </p>\n","excerpt":"","more":"<h2 id=\"Interface：OkhttpClient（singleton）-Request-Response\"><a href=\"#Interface：OkhttpClient（singleton）-Request-Response\" class=\"headerlink\" title=\"Interface：OkhttpClient（singleton）  Request  Response\"></a>Interface：OkhttpClient（singleton）  Request  Response</h2><h2 id=\"主要由以下三部分-组成\"><a href=\"#主要由以下三部分-组成\" class=\"headerlink\" title=\"主要由以下三部分 组成\"></a>主要由以下三部分 组成</h2><h3 id=\"1-任务调度：-核心类disruptor（singleton）\"><a href=\"#1-任务调度：-核心类disruptor（singleton）\" class=\"headerlink\" title=\"1. 任务调度： 核心类disruptor（singleton）\"></a>1. 任务调度： 核心类disruptor（singleton）</h3><p>a. 线程池<br>b. 队列</p>\n<pre><code>/** Ready async calls in the order they&apos;ll be run. */\nprivate final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */\n private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();\n</code></pre><p>(由于okhttp两种 运行模式   sync  和async）</p>\n<h3 id=\"2-网络请求\"><a href=\"#2-网络请求\" class=\"headerlink\" title=\"2. 网络请求\"></a>2. 网络请求</h3><ul>\n<li>核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） </li>\n<li>每个请求会生成一个Request  </li>\n<li>然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  </li>\n</ul>\n<p>okhttp一个请求的完整流程图<br> <img src=\"http://blog.piasy.com/img/201607/okhttp_full_process.png\" alt=\"image\"></p>\n<p>在realcall的execute方法中会调用     </p>\n<pre><code>client.dispatcher().executed(this);//问题1  \nResponse result = getResponseWithInterceptorChain(false);//问题2  \n</code></pre><p>获得请求结果.<br>现在看问题1  在这里面干了写什么<br>其实就是 dispatcher记录任务而已 ，没有任何执行方法<br>核心在问题2中<br>她会  </p>\n<pre><code>Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);\nreturn chain.proceed(originalRequest);\n</code></pre><p>也就是生成拦截器 ，并用这个拦截器启动这个请求<br>继续进入proceed 可以看到<br>进入了ApplicationInterceptorChain的getresponse方法<br>开始构造HttpEngine    </p>\n<pre><code>engine.sendRequest();//问题21\nengine.readResponse();//问题22\n</code></pre><p>在问题21中其实就是  Rfc 标准的一种 实现  </p>\n<pre><code>InternalCache responseCache = Internal.instance.internalCache(client);\nResponse cacheCandidate = responseCache != null\n    ? responseCache.get(request)\n    : null;\n</code></pre><p>就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache<br>这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程<br>当取到值后还要根据http cache的rfc标准  判断  是否合理能使用<br>new CacheStrategy.Factory(now, request, cacheCandidate).get();<br>在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  </p>\n<p>这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）</p>\n<pre><code>if (etag != null) {\n  conditionalRequestBuilder.header(&quot;If-None-Match&quot;, etag);\n} else if (lastModified != null) {\n  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, lastModifiedString);\n} else if (servedDate != null) {\n  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, servedDateString);\n}\n\nRequest conditionalRequest = conditionalRequestBuilder.build();\n</code></pre><p>这是请求前的工作<br>现在开始发送请求</p>\n<pre><code>httpStream = connect();\nhttpStream.setHttpEngine(this);\n</code></pre><p>这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）</p>\n<pre><code>streamAllocation.newStream(client.connectTimeoutMillis(),\nclient.readTimeoutMillis(), client.writeTimeoutMillis(),\nclient.retryOnConnectionFailure(), doExtensiveHealthChecks);\n</code></pre><p>解决的问题 是socket连接重用和  route<br>先是从连接池中找</p>\n<pre><code>// Attempt to get a connection from the pool.\n RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);\n if (pooledConnection != null) {\n   this.connection = pooledConnection;\n   return pooledConnection;\n }\n</code></pre><p>如果没有的话就看route可以重用嘛</p>\n<pre><code> if (selectedRoute == null) {\n  selectedRoute = routeSelector.next();\n  synchronized (connectionPool) {\n    route = selectedRoute;\n  }\n}\nRealConnection newConnection = new RealConnection(selectedRoute);\nacquire(newConnection);\n</code></pre><p>（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止</p>\n<pre><code>RouteDatabase里的Set&lt;Route&gt; failedRoutes = new LinkedHashSet&lt;&gt;()）\n</code></pre><p>弄完之后就是放如   </p>\n<pre><code>Internal.instance.put(connectionPool, newConnection);\n</code></pre><p>连接池中  方便下次继续使用<br>下一步 就是建立socket连接的过程</p>\n<pre><code> newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),\n    connectionRetryEnabled);\nrouteDatabase().connected(newConnection.route());\n</code></pre><p>跟进去 就是</p>\n<pre><code>connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n</code></pre><p>继续</p>\n<pre><code> try {\n  Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);\n} catch (ConnectException e) {\n  throw new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress());\n}\nsource = Okio.buffer(Okio.source(rawSocket));\nsink = Okio.buffer(Okio.sink(rawSocket));\n</code></pre><p>连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的<br>然后才是真正发送这个请求的过程</p>\n<pre><code>httpStream.writeRequestHeaders(networkRequest);\nrequestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);\n</code></pre><p>继续跟进</p>\n<pre><code> httpEngine.writingRequestHeaders();\n  String requestLine = RequestLine.get(\n    request, httpEngine.getConnection().route().proxy().type());\nwriteRequest(request.headers(), requestLine);\n</code></pre><p>》》</p>\n<pre><code>** Returns bytes of a request header for sending on an HTTP transport. */\npublic void writeRequest(Headers headers, String requestLine) throws IOException {\nif (state != STATE_IDLE) throw new IllegalStateException(&quot;state: &quot; + state);\nsink.writeUtf8(requestLine).writeUtf8(&quot;\\r\\n&quot;);\nfor (int i = 0, size = headers.size(); i &lt; size; i++) {\n  sink.writeUtf8(headers.name(i))\n      .writeUtf8(&quot;: &quot;)\n      .writeUtf8(headers.value(i))\n      .writeUtf8(&quot;\\r\\n&quot;);\n}\nsink.writeUtf8(&quot;\\r\\n&quot;);\nstate = STATE_OPEN_REQUEST_BODY;\n}\n</code></pre><p>读过程<br>就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink</p>\n<p>到此 请求reponse的工作做完了<br>现在 如果是需要真正发送网络请求就也就是问题22</p>\n<pre><code>networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);\n</code></pre><p>》》</p>\n<pre><code>engin.readResponse\n</code></pre><p>》》</p>\n<pre><code>// Write the request body to the socket.\nif (requestBodyOut != null) {\n  if (bufferedRequestBody != null) {\n    // This also closes the wrapped requestBodyOut.\n    bufferedRequestBody.close();\n  } else {\n    requestBodyOut.close();\n  }\n  if (requestBodyOut instanceof RetryableSink) {\n    httpStream.writeRequestBody((RetryableSink) requestBodyOut);\n  }\n}\n\nnetworkResponse = readNetworkResponse();\n</code></pre><p>》》</p>\n<pre><code>Response readNetworkResponse() throws IOException {\nhttpStream.finishRequest();\n\nResponse networkResponse = httpStream.readResponseHeaders()\n    .request(networkRequest)\n    .handshake(streamAllocation.connection().handshake())\n    .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))\n    .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))\n    .build();\n\nif (!forWebSocket) {\n  networkResponse = networkResponse.newBuilder()\n      .body(httpStream.openResponseBody(networkResponse))\n      .build();\n}\n\nif (&quot;close&quot;.equalsIgnoreCase(networkResponse.request().header(&quot;Connection&quot;))\n    || &quot;close&quot;.equalsIgnoreCase(networkResponse.header(&quot;Connection&quot;))) {\n  streamAllocation.noNewStreams();\n}\n\nreturn networkResponse;\n</code></pre><p>  }</p>\n<p>解析和返回</p>\n<pre><code> Response response = engine.getResponse();\n\n\n//tobe continue（已经 cache过程 请求重试过程）\n Request followUp = engine.followUpRequest();\n</code></pre><h3 id=\"3-cache管理\"><a href=\"#3-cache管理\" class=\"headerlink\" title=\"3. cache管理\"></a>3. cache管理</h3><p>最后附上 相关的http请求cache的rfc内容<br> <img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg\" alt=\"image\"></p>\n<h3 id=\"每个状态的详细说明如下：\"><a href=\"#每个状态的详细说明如下：\" class=\"headerlink\" title=\"每个状态的详细说明如下：\"></a>每个状态的详细说明如下：</h3><h4 id=\"1-Last-Modified\"><a href=\"#1-Last-Modified\" class=\"headerlink\" title=\"1. Last-Modified\"></a>1. Last-Modified</h4><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：<br>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT<br>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：<br>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT<br>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。<br>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  </p>\n<h4 id=\"2-Etag工作原理\"><a href=\"#2-Etag工作原理\" class=\"headerlink\" title=\"2. Etag工作原理\"></a>2. Etag工作原理</h4><p>HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：<br>Etag:“5d8c72a5edda8d6a:3239″<br>客户端的查询更新格式是这样的：<br>If-None-Match:“5d8c72a5edda8d6a:3239″<br>如果ETag没改变，则返回状态304。<br>即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″<br>标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。<br>If-None-Match:“5d8c72a5edda8d6a:3239“<br>,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  </p>\n<h4 id=\"3-Expires\"><a href=\"#3-Expires\" class=\"headerlink\" title=\"3. Expires\"></a>3. Expires</h4><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT<br>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  </p>\n<h4 id=\"4-Last-Modified和Expires\"><a href=\"#4-Last-Modified和Expires\" class=\"headerlink\" title=\"4. Last-Modified和Expires\"></a>4. Last-Modified和Expires</h4><p>Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  </p>\n<h4 id=\"5-Etag和Expires\"><a href=\"#5-Etag和Expires\" class=\"headerlink\" title=\"5. Etag和Expires\"></a>5. Etag和Expires</h4><p>如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  </p>\n<h4 id=\"6-Last-Modified和Etag\"><a href=\"#6-Last-Modified和Etag\" class=\"headerlink\" title=\"6. Last-Modified和Etag\"></a>6. Last-Modified和Etag</h4><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败<br>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)<br>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存<br>过程如下:  </p>\n<ul>\n<li>客户端请求一个页面（A）。  </li>\n<li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。  </li>\n<li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  </li>\n<li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  </li>\n<li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  </li>\n</ul>\n<p>备注：   </p>\n<ul>\n<li>Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  </li>\n<li>WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  </li>\n<li>客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  </li>\n<li>通过上述值到服务器端检查，判断文件是否继续缓存；  </li>\n</ul>\n<h4 id=\"7-关于-Cache-Control-max-age-秒-和-Expires\"><a href=\"#7-关于-Cache-Control-max-age-秒-和-Expires\" class=\"headerlink\" title=\"7.关于 Cache-Control: max-age=秒 和 Expires\"></a>7.关于 Cache-Control: max-age=秒 和 Expires</h4><p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。<br>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。<br>Expires =max-age +   “每次下载时的当前的request时间”<br>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   </p>\n"},{"title":"AS和Xcode快捷键","date":"2015-11-01T12:10:33.000Z","_content":"\n# Xcode \n\nXCode   不能直接修改文件名，需要找到本文件对应的申明或者实现的名称，右键refactor>rename  修改\n（记得勾选 Rename related files）\n\n\n在 Xcode里面所有的窗口控制显示与否都可以通过右上角的来控制  \n\n\n定位类的位置  shift  commoand  j\n\ncommond  6 \n\n\noption 然后点击方法位置\n\ncommond   T\n\nshift  commoand  O\n\nshift  commoand  F\n\n commoand  F\n\n\nesc  查看方法参数   \n\n\n快捷键位置方法   XCode>preferences>Key Bindings\n\n显示主题颜色设置   XCode>preferences>Font & Colors   从Default  改成   Dusk \n窗口显示和隐藏的button（其中代码下面的debug和log窗口在他们的右下角又有单独的控制显示和隐藏的button）  \n\n![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E8%AE%BE%E7%BD%AE.png?raw=true)\n\n![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg?raw=true)  \n\n\n参考资料：http://www.cocoachina.com/ios/20141224/10752.html\n\n\n\n# AndroidStudio  \n\n快捷键位置方法   AndroidStudio>preferences>Keymap  （把Mac  OS X 复制一份，然后修改）\n\n\n显示主题颜色设置   AndroidStudio>preferences>Editor>Colors & Font   从Default  改成   Darcula  (然后点击 save as  ，再把字体调大一点，不能直接修改) \n","source":"_posts/Xcode 和Android  studio 快捷键及设置对比.md","raw":"title: AS和Xcode快捷键\ndate: 2015-11-01 20:10:33\ncategories:\n- 工具\ntags:\n- 工具\n\n---\n\n# Xcode \n\nXCode   不能直接修改文件名，需要找到本文件对应的申明或者实现的名称，右键refactor>rename  修改\n（记得勾选 Rename related files）\n\n\n在 Xcode里面所有的窗口控制显示与否都可以通过右上角的来控制  \n\n\n定位类的位置  shift  commoand  j\n\ncommond  6 \n\n\noption 然后点击方法位置\n\ncommond   T\n\nshift  commoand  O\n\nshift  commoand  F\n\n commoand  F\n\n\nesc  查看方法参数   \n\n\n快捷键位置方法   XCode>preferences>Key Bindings\n\n显示主题颜色设置   XCode>preferences>Font & Colors   从Default  改成   Dusk \n窗口显示和隐藏的button（其中代码下面的debug和log窗口在他们的右下角又有单独的控制显示和隐藏的button）  \n\n![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E8%AE%BE%E7%BD%AE.png?raw=true)\n\n![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg?raw=true)  \n\n\n参考资料：http://www.cocoachina.com/ios/20141224/10752.html\n\n\n\n# AndroidStudio  \n\n快捷键位置方法   AndroidStudio>preferences>Keymap  （把Mac  OS X 复制一份，然后修改）\n\n\n显示主题颜色设置   AndroidStudio>preferences>Editor>Colors & Font   从Default  改成   Darcula  (然后点击 save as  ，再把字体调大一点，不能直接修改) \n","slug":"Xcode 和Android  studio 快捷键及设置对比","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lc0000psfjfhkgrl5zs","content":"<h1 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h1><p>XCode   不能直接修改文件名，需要找到本文件对应的申明或者实现的名称，右键refactor&gt;rename  修改<br>（记得勾选 Rename related files）</p>\n<p>在 Xcode里面所有的窗口控制显示与否都可以通过右上角的来控制  </p>\n<p>定位类的位置  shift  commoand  j</p>\n<p>commond  6 </p>\n<p>option 然后点击方法位置</p>\n<p>commond   T</p>\n<p>shift  commoand  O</p>\n<p>shift  commoand  F</p>\n<p> commoand  F</p>\n<p>esc  查看方法参数   </p>\n<p>快捷键位置方法   XCode&gt;preferences&gt;Key Bindings</p>\n<p>显示主题颜色设置   XCode&gt;preferences&gt;Font &amp; Colors   从Default  改成   Dusk<br>窗口显示和隐藏的button（其中代码下面的debug和log窗口在他们的右下角又有单独的控制显示和隐藏的button）  </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E8%AE%BE%E7%BD%AE.png?raw=true\" alt=\"image\"></p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg?raw=true\" alt=\"image\">  </p>\n<p>参考资料：<a href=\"http://www.cocoachina.com/ios/20141224/10752.html\" target=\"_blank\" rel=\"external\">http://www.cocoachina.com/ios/20141224/10752.html</a></p>\n<h1 id=\"AndroidStudio\"><a href=\"#AndroidStudio\" class=\"headerlink\" title=\"AndroidStudio\"></a>AndroidStudio</h1><p>快捷键位置方法   AndroidStudio&gt;preferences&gt;Keymap  （把Mac  OS X 复制一份，然后修改）</p>\n<p>显示主题颜色设置   AndroidStudio&gt;preferences&gt;Editor&gt;Colors &amp; Font   从Default  改成   Darcula  (然后点击 save as  ，再把字体调大一点，不能直接修改) </p>\n","excerpt":"","more":"<h1 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h1><p>XCode   不能直接修改文件名，需要找到本文件对应的申明或者实现的名称，右键refactor&gt;rename  修改<br>（记得勾选 Rename related files）</p>\n<p>在 Xcode里面所有的窗口控制显示与否都可以通过右上角的来控制  </p>\n<p>定位类的位置  shift  commoand  j</p>\n<p>commond  6 </p>\n<p>option 然后点击方法位置</p>\n<p>commond   T</p>\n<p>shift  commoand  O</p>\n<p>shift  commoand  F</p>\n<p> commoand  F</p>\n<p>esc  查看方法参数   </p>\n<p>快捷键位置方法   XCode&gt;preferences&gt;Key Bindings</p>\n<p>显示主题颜色设置   XCode&gt;preferences&gt;Font &amp; Colors   从Default  改成   Dusk<br>窗口显示和隐藏的button（其中代码下面的debug和log窗口在他们的右下角又有单独的控制显示和隐藏的button）  </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E8%AE%BE%E7%BD%AE.png?raw=true\" alt=\"image\"></p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg?raw=true\" alt=\"image\">  </p>\n<p>参考资料：<a href=\"http://www.cocoachina.com/ios/20141224/10752.html\">http://www.cocoachina.com/ios/20141224/10752.html</a></p>\n<h1 id=\"AndroidStudio\"><a href=\"#AndroidStudio\" class=\"headerlink\" title=\"AndroidStudio\"></a>AndroidStudio</h1><p>快捷键位置方法   AndroidStudio&gt;preferences&gt;Keymap  （把Mac  OS X 复制一份，然后修改）</p>\n<p>显示主题颜色设置   AndroidStudio&gt;preferences&gt;Editor&gt;Colors &amp; Font   从Default  改成   Darcula  (然后点击 save as  ，再把字体调大一点，不能直接修改) </p>\n"},{"title":"全屏模式底部键盘冲突","date":"2017-09-09T16:00:00.000Z","_content":"\n# 场景：全屏模式下activity的adjustResize 失效,弹键盘时候底部的输入框无法自动调整到键盘区域的上方 \n\n## 1. 方案一：  \n使用 AndroidBug5497Workaround （https://stackoverflow.com/questions/7417123/android-how-to-adjust-layout-in-full-screen-mode-when-softkeyboard-is-visible）  \n\n<img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA_normal.gif?raw=true\" height=\"200px\" width=\"100px\" >  \n\n原理：通过 getViewTreeObserver().addOnGlobalLayoutListener监听当前屏幕显示区域的大小，然后动态调整Activity rootView的height，实现“adjust resize”的效果   \n\n       Rect r = new Rect();\n       mChildOfContent.getWindowVisibleDisplayFrame(r);\n      int usableHeightNow = r.bottom - r.top;\n        if (usableHeightNow != usableHeightPrevious) {\n            int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();\n            int heightDifference = usableHeightSansKeyboard - usableHeightNow;\n            if (heightDifference > (usableHeightSansKeyboard/4)) {\n                // keyboard probably just became visible\n                frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;\n            } else {\n                // keyboard probably just became hidden\n                frameLayoutParams.height = usableHeightSansKeyboard;\n            }\n            mChildOfContent.requestLayout();\n            usableHeightPrevious = usableHeightNow;\n\n但是这个不能完全解决我们问题，会遇到下面的问题：  \n在输入框在屏幕区域上方是没问题，在输入框在底部时候，会有一个特别不好的现象，键盘弹出后会迅速把整个Activity完全顶上去，然后调整回来。  \n\n<img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA.gif?raw=true\" height=\"200px\" width=\"100px\" >\n\n\n问题的原因是是OnGlobalLayoutListener不是实时和键盘弹时屏幕显示区域同步的。所以就会在键盘弹起的瞬间先把整个activity顶上去，然后顶上去后，屏幕内容又会掉下来  \n\n\n补丁方案：  \n输入框在底部时候不要直接弹出键盘，先让顶部的一个1px的输入框获得这个这个焦点，待键盘完全弹出来后再把焦点传递给底部的这个输入框，这样就不会有顶整个界面起来的现象\n\n<img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA_fix.gif?raw=true\" height=\"200px\" width=\"100px\" >\n\n\n补充问题    \n为什么在顶部的时候不会出现顶上去又下来的情况？  \n因为 输入框在最上面，键盘输入法只要弹出时不盖住输入框，就不会顶起这个Activity的内容，而内容区域调整也是延迟于键盘弹起速度的，但是由于键盘盖住了所以视觉感觉不出来    \n\n\n## 2.方案二   \nJkeyboardSwitch （https://github.com/Jacksgong/JKeyboardPanelSwitch）  \n\n原理是在输入框下面加了一个和键盘高度相同的panel，在键盘弹出来的瞬间panel显示出来（invisualble状态），这样键盘的弹出和隐藏与panel的的invisualble和gone的状态同步起来，看起来的效果就是键盘出来时候把输入框顶上去，键盘收起来时候把输入框收回去  \n\n\n这个方案的一个问题是“怎么在第一次弹出时候初始化panel高度和键盘高度一致?”    \n\n<img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planB.gif?raw=true\" height=\"200px\" width=\"100px\" >\n\n补丁方案：  \n第一次弹出瞬间把输入框的区域设置为Invisualbel ，初始panel的高度尽量大，待键盘完全弹出后把输入框区域显示出来，然后调整panel的高度，这样就能在用户无察觉的情况初始化这个panel高度。   \n\n<img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planB_fix.gif?raw=true\" height=\"200px\" width=\"100px\" >\n\n\n\n\n\n\n","source":"_posts/android全屏模键盘冲突.md","raw":"title: 全屏模式底部键盘冲突\ndate: 2017-9-10 \ncategories:\n- Android\ntags:\n- Android\n- 全屏模式\n- 键盘\n\n---\n\n# 场景：全屏模式下activity的adjustResize 失效,弹键盘时候底部的输入框无法自动调整到键盘区域的上方 \n\n## 1. 方案一：  \n使用 AndroidBug5497Workaround （https://stackoverflow.com/questions/7417123/android-how-to-adjust-layout-in-full-screen-mode-when-softkeyboard-is-visible）  \n\n<img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA_normal.gif?raw=true\" height=\"200px\" width=\"100px\" >  \n\n原理：通过 getViewTreeObserver().addOnGlobalLayoutListener监听当前屏幕显示区域的大小，然后动态调整Activity rootView的height，实现“adjust resize”的效果   \n\n       Rect r = new Rect();\n       mChildOfContent.getWindowVisibleDisplayFrame(r);\n      int usableHeightNow = r.bottom - r.top;\n        if (usableHeightNow != usableHeightPrevious) {\n            int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();\n            int heightDifference = usableHeightSansKeyboard - usableHeightNow;\n            if (heightDifference > (usableHeightSansKeyboard/4)) {\n                // keyboard probably just became visible\n                frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;\n            } else {\n                // keyboard probably just became hidden\n                frameLayoutParams.height = usableHeightSansKeyboard;\n            }\n            mChildOfContent.requestLayout();\n            usableHeightPrevious = usableHeightNow;\n\n但是这个不能完全解决我们问题，会遇到下面的问题：  \n在输入框在屏幕区域上方是没问题，在输入框在底部时候，会有一个特别不好的现象，键盘弹出后会迅速把整个Activity完全顶上去，然后调整回来。  \n\n<img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA.gif?raw=true\" height=\"200px\" width=\"100px\" >\n\n\n问题的原因是是OnGlobalLayoutListener不是实时和键盘弹时屏幕显示区域同步的。所以就会在键盘弹起的瞬间先把整个activity顶上去，然后顶上去后，屏幕内容又会掉下来  \n\n\n补丁方案：  \n输入框在底部时候不要直接弹出键盘，先让顶部的一个1px的输入框获得这个这个焦点，待键盘完全弹出来后再把焦点传递给底部的这个输入框，这样就不会有顶整个界面起来的现象\n\n<img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA_fix.gif?raw=true\" height=\"200px\" width=\"100px\" >\n\n\n补充问题    \n为什么在顶部的时候不会出现顶上去又下来的情况？  \n因为 输入框在最上面，键盘输入法只要弹出时不盖住输入框，就不会顶起这个Activity的内容，而内容区域调整也是延迟于键盘弹起速度的，但是由于键盘盖住了所以视觉感觉不出来    \n\n\n## 2.方案二   \nJkeyboardSwitch （https://github.com/Jacksgong/JKeyboardPanelSwitch）  \n\n原理是在输入框下面加了一个和键盘高度相同的panel，在键盘弹出来的瞬间panel显示出来（invisualble状态），这样键盘的弹出和隐藏与panel的的invisualble和gone的状态同步起来，看起来的效果就是键盘出来时候把输入框顶上去，键盘收起来时候把输入框收回去  \n\n\n这个方案的一个问题是“怎么在第一次弹出时候初始化panel高度和键盘高度一致?”    \n\n<img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planB.gif?raw=true\" height=\"200px\" width=\"100px\" >\n\n补丁方案：  \n第一次弹出瞬间把输入框的区域设置为Invisualbel ，初始panel的高度尽量大，待键盘完全弹出后把输入框区域显示出来，然后调整panel的高度，这样就能在用户无察觉的情况初始化这个panel高度。   \n\n<img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planB_fix.gif?raw=true\" height=\"200px\" width=\"100px\" >\n\n\n\n\n\n\n","slug":"android全屏模键盘冲突","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lc4000ssfjfld0ym3i5","content":"<h1 id=\"场景：全屏模式下activity的adjustResize-失效-弹键盘时候底部的输入框无法自动调整到键盘区域的上方\"><a href=\"#场景：全屏模式下activity的adjustResize-失效-弹键盘时候底部的输入框无法自动调整到键盘区域的上方\" class=\"headerlink\" title=\"场景：全屏模式下activity的adjustResize 失效,弹键盘时候底部的输入框无法自动调整到键盘区域的上方\"></a>场景：全屏模式下activity的adjustResize 失效,弹键盘时候底部的输入框无法自动调整到键盘区域的上方</h1><h2 id=\"1-方案一：\"><a href=\"#1-方案一：\" class=\"headerlink\" title=\"1. 方案一：\"></a>1. 方案一：</h2><p>使用 AndroidBug5497Workaround （<a href=\"https://stackoverflow.com/questions/7417123/android-how-to-adjust-layout-in-full-screen-mode-when-softkeyboard-is-visible）\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/7417123/android-how-to-adjust-layout-in-full-screen-mode-when-softkeyboard-is-visible）</a>  </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA_normal.gif?raw=true\" height=\"200px\" width=\"100px\">  </p>\n<p>原理：通过 getViewTreeObserver().addOnGlobalLayoutListener监听当前屏幕显示区域的大小，然后动态调整Activity rootView的height，实现“adjust resize”的效果   </p>\n<pre><code> Rect r = new Rect();\n mChildOfContent.getWindowVisibleDisplayFrame(r);\nint usableHeightNow = r.bottom - r.top;\n  if (usableHeightNow != usableHeightPrevious) {\n      int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();\n      int heightDifference = usableHeightSansKeyboard - usableHeightNow;\n      if (heightDifference &gt; (usableHeightSansKeyboard/4)) {\n          // keyboard probably just became visible\n          frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;\n      } else {\n          // keyboard probably just became hidden\n          frameLayoutParams.height = usableHeightSansKeyboard;\n      }\n      mChildOfContent.requestLayout();\n      usableHeightPrevious = usableHeightNow;\n</code></pre><p>但是这个不能完全解决我们问题，会遇到下面的问题：<br>在输入框在屏幕区域上方是没问题，在输入框在底部时候，会有一个特别不好的现象，键盘弹出后会迅速把整个Activity完全顶上去，然后调整回来。  </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA.gif?raw=true\" height=\"200px\" width=\"100px\"></p>\n<p>问题的原因是是OnGlobalLayoutListener不是实时和键盘弹时屏幕显示区域同步的。所以就会在键盘弹起的瞬间先把整个activity顶上去，然后顶上去后，屏幕内容又会掉下来  </p>\n<p>补丁方案：<br>输入框在底部时候不要直接弹出键盘，先让顶部的一个1px的输入框获得这个这个焦点，待键盘完全弹出来后再把焦点传递给底部的这个输入框，这样就不会有顶整个界面起来的现象</p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA_fix.gif?raw=true\" height=\"200px\" width=\"100px\"></p>\n<p>补充问题<br>为什么在顶部的时候不会出现顶上去又下来的情况？<br>因为 输入框在最上面，键盘输入法只要弹出时不盖住输入框，就不会顶起这个Activity的内容，而内容区域调整也是延迟于键盘弹起速度的，但是由于键盘盖住了所以视觉感觉不出来    </p>\n<h2 id=\"2-方案二\"><a href=\"#2-方案二\" class=\"headerlink\" title=\"2.方案二\"></a>2.方案二</h2><p>JkeyboardSwitch （<a href=\"https://github.com/Jacksgong/JKeyboardPanelSwitch）\" target=\"_blank\" rel=\"external\">https://github.com/Jacksgong/JKeyboardPanelSwitch）</a>  </p>\n<p>原理是在输入框下面加了一个和键盘高度相同的panel，在键盘弹出来的瞬间panel显示出来（invisualble状态），这样键盘的弹出和隐藏与panel的的invisualble和gone的状态同步起来，看起来的效果就是键盘出来时候把输入框顶上去，键盘收起来时候把输入框收回去  </p>\n<p>这个方案的一个问题是“怎么在第一次弹出时候初始化panel高度和键盘高度一致?”    </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planB.gif?raw=true\" height=\"200px\" width=\"100px\"></p>\n<p>补丁方案：<br>第一次弹出瞬间把输入框的区域设置为Invisualbel ，初始panel的高度尽量大，待键盘完全弹出后把输入框区域显示出来，然后调整panel的高度，这样就能在用户无察觉的情况初始化这个panel高度。   </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planB_fix.gif?raw=true\" height=\"200px\" width=\"100px\"></p>\n","excerpt":"","more":"<h1 id=\"场景：全屏模式下activity的adjustResize-失效-弹键盘时候底部的输入框无法自动调整到键盘区域的上方\"><a href=\"#场景：全屏模式下activity的adjustResize-失效-弹键盘时候底部的输入框无法自动调整到键盘区域的上方\" class=\"headerlink\" title=\"场景：全屏模式下activity的adjustResize 失效,弹键盘时候底部的输入框无法自动调整到键盘区域的上方\"></a>场景：全屏模式下activity的adjustResize 失效,弹键盘时候底部的输入框无法自动调整到键盘区域的上方</h1><h2 id=\"1-方案一：\"><a href=\"#1-方案一：\" class=\"headerlink\" title=\"1. 方案一：\"></a>1. 方案一：</h2><p>使用 AndroidBug5497Workaround （<a href=\"https://stackoverflow.com/questions/7417123/android-how-to-adjust-layout-in-full-screen-mode-when-softkeyboard-is-visible）\">https://stackoverflow.com/questions/7417123/android-how-to-adjust-layout-in-full-screen-mode-when-softkeyboard-is-visible）</a>  </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA_normal.gif?raw=true\" height=\"200px\" width=\"100px\" >  </p>\n<p>原理：通过 getViewTreeObserver().addOnGlobalLayoutListener监听当前屏幕显示区域的大小，然后动态调整Activity rootView的height，实现“adjust resize”的效果   </p>\n<pre><code> Rect r = new Rect();\n mChildOfContent.getWindowVisibleDisplayFrame(r);\nint usableHeightNow = r.bottom - r.top;\n  if (usableHeightNow != usableHeightPrevious) {\n      int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();\n      int heightDifference = usableHeightSansKeyboard - usableHeightNow;\n      if (heightDifference &gt; (usableHeightSansKeyboard/4)) {\n          // keyboard probably just became visible\n          frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;\n      } else {\n          // keyboard probably just became hidden\n          frameLayoutParams.height = usableHeightSansKeyboard;\n      }\n      mChildOfContent.requestLayout();\n      usableHeightPrevious = usableHeightNow;\n</code></pre><p>但是这个不能完全解决我们问题，会遇到下面的问题：<br>在输入框在屏幕区域上方是没问题，在输入框在底部时候，会有一个特别不好的现象，键盘弹出后会迅速把整个Activity完全顶上去，然后调整回来。  </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA.gif?raw=true\" height=\"200px\" width=\"100px\" ></p>\n<p>问题的原因是是OnGlobalLayoutListener不是实时和键盘弹时屏幕显示区域同步的。所以就会在键盘弹起的瞬间先把整个activity顶上去，然后顶上去后，屏幕内容又会掉下来  </p>\n<p>补丁方案：<br>输入框在底部时候不要直接弹出键盘，先让顶部的一个1px的输入框获得这个这个焦点，待键盘完全弹出来后再把焦点传递给底部的这个输入框，这样就不会有顶整个界面起来的现象</p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planA_fix.gif?raw=true\" height=\"200px\" width=\"100px\" ></p>\n<p>补充问题<br>为什么在顶部的时候不会出现顶上去又下来的情况？<br>因为 输入框在最上面，键盘输入法只要弹出时不盖住输入框，就不会顶起这个Activity的内容，而内容区域调整也是延迟于键盘弹起速度的，但是由于键盘盖住了所以视觉感觉不出来    </p>\n<h2 id=\"2-方案二\"><a href=\"#2-方案二\" class=\"headerlink\" title=\"2.方案二\"></a>2.方案二</h2><p>JkeyboardSwitch （<a href=\"https://github.com/Jacksgong/JKeyboardPanelSwitch）\">https://github.com/Jacksgong/JKeyboardPanelSwitch）</a>  </p>\n<p>原理是在输入框下面加了一个和键盘高度相同的panel，在键盘弹出来的瞬间panel显示出来（invisualble状态），这样键盘的弹出和隐藏与panel的的invisualble和gone的状态同步起来，看起来的效果就是键盘出来时候把输入框顶上去，键盘收起来时候把输入框收回去  </p>\n<p>这个方案的一个问题是“怎么在第一次弹出时候初始化panel高度和键盘高度一致?”    </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planB.gif?raw=true\" height=\"200px\" width=\"100px\" ></p>\n<p>补丁方案：<br>第一次弹出瞬间把输入框的区域设置为Invisualbel ，初始panel的高度尽量大，待键盘完全弹出后把输入框区域显示出来，然后调整panel的高度，这样就能在用户无察觉的情况初始化这个panel高度。   </p>\n<p><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/planB_fix.gif?raw=true\" height=\"200px\" width=\"100px\" ></p>\n"},{"title":"Deeplink 设计","date":"2015-11-01T12:10:33.000Z","_content":"\n\n## 概念  \n\ndeeplink指的是在第三方客户端/浏览器中，打开一个APP的H5页面时候，如果发现本地安装了这个APP，就会使用本地APP打开。\n需要前端和客户端互相配合来实现本功能。\n\n# 服务器端：\n\n    <html>\n    <head>\n    <meta property=\"al:ios:url\" content=\"applinks://docs\" />\n    <meta property=\"al:ios:app_store_id\" content=\"12345\" />\n    <meta property=\"al:ios:app_name\" content=\"App Links\" />\n    <meta property=\"al:android:url\" content=\"applinks://docs\" />\n    <meta property=\"al:android:app_name\" content=\"App Links\" />\n    <meta property=\"al:android:package\" content=\"org.applinks\" />\n    <meta property=\"al:web:url\"\n    content=\"http://applinks.org/documentation\" />\n    </head>\n    <body>\n    Hello, world!\n    </body>\n    </html>\n\n# 客户端  \n客户端deeplink的实现需要依靠jump系统。ps:jump系统可以通过URI 实现在app中的定向跳转 ，比如我们的app叫“天上人间”（缩写tsrj）。 \n\n1. 需要先在menifest中注册相应的scheme的filter。  \n   ps:一般加载主页上面.\n\n\n        <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n        <category android:name=\"android.intent.category.BROWSABLE\"/>\n        <!-- Accepts URIs that begin with \"tsrj://\" -->\n        <data android:scheme=\"tsrj\"/>\n        </intent-filter>\n        <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n        <category android:name=\"android.intent.category.BROWSABLE\"/>\n        <!-- Accepts URIs that begin with \"http://m.tsrj.com/\" -->\n        <data\n        android:host=\"m.tsrj.com\"\n        android:pathPrefix=\"/\"\n        android:scheme=\"http\"/>\n        <data\n        android:host=\"m.tsrj.com\"\n        android:pathPrefix=\"/\"\n        android:scheme=\"https\"/>\n        </intent-filter>\n    \n2. 在MainActivity新增解析jump信息的方法\n\n\n        private void jump(Intent intent) {\n        /** 根据传过来的参数 进行jump跳转 **/\n        String action_url = intent.getDataString();\n        MLog.i(\"启动Main_action_url:\" + action_url);\n        if (!TextUtils.isEmpty(action_url)) {\n        JumpManager.jump(this, action_url);\n        } \n        }\n        \n        JumpManger就实现解析数据然后根据URI跳转的功能\n        public static boolean jump(Context ctx, String action_url) {\n        \n        if (TextUtils.isEmpty(action_url)) {\n        return false;\n        }\n        \n        MLog.d(\"JumpManager  url:\" + action_url);\n        \n        Uri uri = null;\n        \n        /**如果不是一个标准的uri格式说明传入的数据无效的 可以直接忽视*/\n        \n        try {\n        uri = Uri.parse(action_url);\n        } catch (Exception e) {\n        return false;\n        }\n        \n        if (uri == null) {\n        return false;\n        }\n        \n        /**检测到是一个合法的uri 先判断是否是满足跳转需求的头部 如果是 开始进行跳转检测 如果不是 直接往内置浏览器跳*/\n        \n        if (!action_url.startsWith(JumpUriFactory.JUM_URL_HEAD) && !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_S) && !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_CUSTOM)) {\n        \n        return false;\n        }\n        \n        Intent jumpintent = null;\n        \n        List<String> paths = uri.getPathSegments();\n        \n        /**只有头没有页面参数就返回*/\n        if (paths == null || paths.size() <= 0) {\n        \n        return false;\n        }\n        \n        /**有path 但是path里面为空值 直接打开*/\n        String action = paths.get(0);\n        if (TextUtils.isEmpty(action)) {\n        if (!isFromWebView) {\n        jumpToInteriorPageActivity(ctx, uri);\n        }\n        return false;\n        }\n        \n        /** 使用系统浏览器打开 */\n        if (action.equals(\"web_system\")) {\n        jumpToSystemWebPage(ctx, uri);\n        return true;\n        }\n        \n        \n        /*else if (action.equals(JumpPageSet.detail)) {\n        goWaitress(ctx, action_url);\n        return true;\n        }*/\n        \n        /** city */\n        else if (action.equals(JumpPageSet.city)) {\n        goCity(ctx, action_url);\n        return true;\n        }\n        \n        /** usercenter */\n        else if (action.equals(JumpPageSet.personal_info)) {\n        goUserCenter(ctx, action_url);\n        return true;\n        }\n\n\n3. 处理uri解析出里面的参数,放入intent，并跳往相应的主页\n\n\n        /**\n         * 将url的数据进行解析 得到一个存放所有参数的集合\n         */\n        public static Set<String> getMyQueryParameterNames(Uri uri) {\n            String query = uri.getEncodedQuery();\n            if (query == null) {\n                return Collections.emptySet();\n            }\n            Set<String> names = new LinkedHashSet<String>();\n            int start = 0;\n            do {\n                int next = query.indexOf('&', start);\n                int end = (next == -1) ? query.length() : next;\n                int separator = query.indexOf('=', start);\n                if (separator > end || separator == -1) {\n                    separator = end;\n                }\n                String name = query.substring(start, separator);\n                names.add(Uri.decode(name));\n                // Move start to end of name.\n                start = end + 1;\n            } while (start < query.length());\n            return Collections.unmodifiableSet(names);\n        }\n        private static void goWaitress(final Context ctx, String actionUrl) {\n            MLog.i(\"actionUrl\"+actionUrl);\n            Uri  uri;\n            uri=Uri.parse(actionUrl);\n            Set<String>  parameters=JumpManager.getMyQueryParameterNames(uri);\n            Hashtable<String,String> params=new Hashtable<>();\n            if(parameters!=null&&parameters.size()>0){\n                for(String key:parameters){\n                    String value=uri.getQueryParameter(key);\n                    if(!TextUtils.isEmpty(value)){\n                        params.put(key,value);\n                    }\n                }\n            }\n            Intent it= new Intent(act, WaitressPage.class);\n            Set<String>  keySet=params.keySet();\n            for (String k:keySet){\n                it.putExtra(k,params.get(k));\n            }\n            startActivity(it);\n            }\n\n\n\n# DeepLink的坑： \n\n1. 由于有些页面有权限限制，所以要跳页面时候，要判断在当前账户当前版本是否可以打开\n2. 如果从H5页面带过来的信息带有登录状态，而且当前app的账号信息和H5页面的不一致，可能需要一个账号切换工作\n\n\n#微信里面的deeplink：\n微信里面的主要就是二维码加上linkme，linkme和微信有合作可以直接把分享的内容通过里面的二维码倒回到app，不过这里要注意一个问题\n微信里面的图片对size 是有要求的\n\n图片size越大被压的越厉害，，这个即使通过以下方式绕过微信sdk也无法避免被压缩\n\n        try {\n            Intent intent = new Intent(Intent.ACTION_VIEW);\n            intent.setAction(Intent.ACTION_VIEW);\n            intent.addCategory(Intent.CATEGORY_DEFAULT);\n            ComponentName cmp = new ComponentName(\"com.tencent.mm\", \"com.tencent.mm.ui.tools.ShareScreenImgUI\");\n            intent.setComponent(cmp);\n            String path = localImgPath;\n            if (!TextUtils.isEmpty(path) && !path.startsWith(\"file://\")) {\n                path = \"file://\" + path;\n            }\n            intent.setDataAndType(Uri.parse(path), \"image/jpeg\");\n            act.startActivity(intent);\n        } catch (Exception e) {\n            ELog.e(\"wechat share failed\");\n        }\n        \n 所以只有自己先压缩图片到一定的size，  再在这张压缩过的图片上绘制真正的二维码才行，（如果遇到好心的UI把二维码设计的很大就，可以跳过这个坑）\n \n\n\n\n","source":"_posts/deep_link设计方案.md","raw":"title: Deeplink 设计\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n---\n\n\n## 概念  \n\ndeeplink指的是在第三方客户端/浏览器中，打开一个APP的H5页面时候，如果发现本地安装了这个APP，就会使用本地APP打开。\n需要前端和客户端互相配合来实现本功能。\n\n# 服务器端：\n\n    <html>\n    <head>\n    <meta property=\"al:ios:url\" content=\"applinks://docs\" />\n    <meta property=\"al:ios:app_store_id\" content=\"12345\" />\n    <meta property=\"al:ios:app_name\" content=\"App Links\" />\n    <meta property=\"al:android:url\" content=\"applinks://docs\" />\n    <meta property=\"al:android:app_name\" content=\"App Links\" />\n    <meta property=\"al:android:package\" content=\"org.applinks\" />\n    <meta property=\"al:web:url\"\n    content=\"http://applinks.org/documentation\" />\n    </head>\n    <body>\n    Hello, world!\n    </body>\n    </html>\n\n# 客户端  \n客户端deeplink的实现需要依靠jump系统。ps:jump系统可以通过URI 实现在app中的定向跳转 ，比如我们的app叫“天上人间”（缩写tsrj）。 \n\n1. 需要先在menifest中注册相应的scheme的filter。  \n   ps:一般加载主页上面.\n\n\n        <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n        <category android:name=\"android.intent.category.BROWSABLE\"/>\n        <!-- Accepts URIs that begin with \"tsrj://\" -->\n        <data android:scheme=\"tsrj\"/>\n        </intent-filter>\n        <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"/>\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n        <category android:name=\"android.intent.category.BROWSABLE\"/>\n        <!-- Accepts URIs that begin with \"http://m.tsrj.com/\" -->\n        <data\n        android:host=\"m.tsrj.com\"\n        android:pathPrefix=\"/\"\n        android:scheme=\"http\"/>\n        <data\n        android:host=\"m.tsrj.com\"\n        android:pathPrefix=\"/\"\n        android:scheme=\"https\"/>\n        </intent-filter>\n    \n2. 在MainActivity新增解析jump信息的方法\n\n\n        private void jump(Intent intent) {\n        /** 根据传过来的参数 进行jump跳转 **/\n        String action_url = intent.getDataString();\n        MLog.i(\"启动Main_action_url:\" + action_url);\n        if (!TextUtils.isEmpty(action_url)) {\n        JumpManager.jump(this, action_url);\n        } \n        }\n        \n        JumpManger就实现解析数据然后根据URI跳转的功能\n        public static boolean jump(Context ctx, String action_url) {\n        \n        if (TextUtils.isEmpty(action_url)) {\n        return false;\n        }\n        \n        MLog.d(\"JumpManager  url:\" + action_url);\n        \n        Uri uri = null;\n        \n        /**如果不是一个标准的uri格式说明传入的数据无效的 可以直接忽视*/\n        \n        try {\n        uri = Uri.parse(action_url);\n        } catch (Exception e) {\n        return false;\n        }\n        \n        if (uri == null) {\n        return false;\n        }\n        \n        /**检测到是一个合法的uri 先判断是否是满足跳转需求的头部 如果是 开始进行跳转检测 如果不是 直接往内置浏览器跳*/\n        \n        if (!action_url.startsWith(JumpUriFactory.JUM_URL_HEAD) && !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_S) && !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_CUSTOM)) {\n        \n        return false;\n        }\n        \n        Intent jumpintent = null;\n        \n        List<String> paths = uri.getPathSegments();\n        \n        /**只有头没有页面参数就返回*/\n        if (paths == null || paths.size() <= 0) {\n        \n        return false;\n        }\n        \n        /**有path 但是path里面为空值 直接打开*/\n        String action = paths.get(0);\n        if (TextUtils.isEmpty(action)) {\n        if (!isFromWebView) {\n        jumpToInteriorPageActivity(ctx, uri);\n        }\n        return false;\n        }\n        \n        /** 使用系统浏览器打开 */\n        if (action.equals(\"web_system\")) {\n        jumpToSystemWebPage(ctx, uri);\n        return true;\n        }\n        \n        \n        /*else if (action.equals(JumpPageSet.detail)) {\n        goWaitress(ctx, action_url);\n        return true;\n        }*/\n        \n        /** city */\n        else if (action.equals(JumpPageSet.city)) {\n        goCity(ctx, action_url);\n        return true;\n        }\n        \n        /** usercenter */\n        else if (action.equals(JumpPageSet.personal_info)) {\n        goUserCenter(ctx, action_url);\n        return true;\n        }\n\n\n3. 处理uri解析出里面的参数,放入intent，并跳往相应的主页\n\n\n        /**\n         * 将url的数据进行解析 得到一个存放所有参数的集合\n         */\n        public static Set<String> getMyQueryParameterNames(Uri uri) {\n            String query = uri.getEncodedQuery();\n            if (query == null) {\n                return Collections.emptySet();\n            }\n            Set<String> names = new LinkedHashSet<String>();\n            int start = 0;\n            do {\n                int next = query.indexOf('&', start);\n                int end = (next == -1) ? query.length() : next;\n                int separator = query.indexOf('=', start);\n                if (separator > end || separator == -1) {\n                    separator = end;\n                }\n                String name = query.substring(start, separator);\n                names.add(Uri.decode(name));\n                // Move start to end of name.\n                start = end + 1;\n            } while (start < query.length());\n            return Collections.unmodifiableSet(names);\n        }\n        private static void goWaitress(final Context ctx, String actionUrl) {\n            MLog.i(\"actionUrl\"+actionUrl);\n            Uri  uri;\n            uri=Uri.parse(actionUrl);\n            Set<String>  parameters=JumpManager.getMyQueryParameterNames(uri);\n            Hashtable<String,String> params=new Hashtable<>();\n            if(parameters!=null&&parameters.size()>0){\n                for(String key:parameters){\n                    String value=uri.getQueryParameter(key);\n                    if(!TextUtils.isEmpty(value)){\n                        params.put(key,value);\n                    }\n                }\n            }\n            Intent it= new Intent(act, WaitressPage.class);\n            Set<String>  keySet=params.keySet();\n            for (String k:keySet){\n                it.putExtra(k,params.get(k));\n            }\n            startActivity(it);\n            }\n\n\n\n# DeepLink的坑： \n\n1. 由于有些页面有权限限制，所以要跳页面时候，要判断在当前账户当前版本是否可以打开\n2. 如果从H5页面带过来的信息带有登录状态，而且当前app的账号信息和H5页面的不一致，可能需要一个账号切换工作\n\n\n#微信里面的deeplink：\n微信里面的主要就是二维码加上linkme，linkme和微信有合作可以直接把分享的内容通过里面的二维码倒回到app，不过这里要注意一个问题\n微信里面的图片对size 是有要求的\n\n图片size越大被压的越厉害，，这个即使通过以下方式绕过微信sdk也无法避免被压缩\n\n        try {\n            Intent intent = new Intent(Intent.ACTION_VIEW);\n            intent.setAction(Intent.ACTION_VIEW);\n            intent.addCategory(Intent.CATEGORY_DEFAULT);\n            ComponentName cmp = new ComponentName(\"com.tencent.mm\", \"com.tencent.mm.ui.tools.ShareScreenImgUI\");\n            intent.setComponent(cmp);\n            String path = localImgPath;\n            if (!TextUtils.isEmpty(path) && !path.startsWith(\"file://\")) {\n                path = \"file://\" + path;\n            }\n            intent.setDataAndType(Uri.parse(path), \"image/jpeg\");\n            act.startActivity(intent);\n        } catch (Exception e) {\n            ELog.e(\"wechat share failed\");\n        }\n        \n 所以只有自己先压缩图片到一定的size，  再在这张压缩过的图片上绘制真正的二维码才行，（如果遇到好心的UI把二维码设计的很大就，可以跳过这个坑）\n \n\n\n\n","slug":"deep_link设计方案","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lc7000wsfjfaabhb1ck","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>deeplink指的是在第三方客户端/浏览器中，打开一个APP的H5页面时候，如果发现本地安装了这个APP，就会使用本地APP打开。<br>需要前端和客户端互相配合来实现本功能。</p>\n<h1 id=\"服务器端：\"><a href=\"#服务器端：\" class=\"headerlink\" title=\"服务器端：\"></a>服务器端：</h1><pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta property=&quot;al:ios:url&quot; content=&quot;applinks://docs&quot; /&gt;\n&lt;meta property=&quot;al:ios:app_store_id&quot; content=&quot;12345&quot; /&gt;\n&lt;meta property=&quot;al:ios:app_name&quot; content=&quot;App Links&quot; /&gt;\n&lt;meta property=&quot;al:android:url&quot; content=&quot;applinks://docs&quot; /&gt;\n&lt;meta property=&quot;al:android:app_name&quot; content=&quot;App Links&quot; /&gt;\n&lt;meta property=&quot;al:android:package&quot; content=&quot;org.applinks&quot; /&gt;\n&lt;meta property=&quot;al:web:url&quot;\ncontent=&quot;http://applinks.org/documentation&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\nHello, world!\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h1 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h1><p>客户端deeplink的实现需要依靠jump系统。ps:jump系统可以通过URI 实现在app中的定向跳转 ，比如我们的app叫“天上人间”（缩写tsrj）。 </p>\n<ol>\n<li>需要先在menifest中注册相应的scheme的filter。<br>ps:一般加载主页上面.</li>\n</ol>\n<pre><code>&lt;intent-filter&gt;\n&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n&lt;!-- Accepts URIs that begin with &quot;tsrj://&quot; --&gt;\n&lt;data android:scheme=&quot;tsrj&quot;/&gt;\n&lt;/intent-filter&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n&lt;!-- Accepts URIs that begin with &quot;http://m.tsrj.com/&quot; --&gt;\n&lt;data\nandroid:host=&quot;m.tsrj.com&quot;\nandroid:pathPrefix=&quot;/&quot;\nandroid:scheme=&quot;http&quot;/&gt;\n&lt;data\nandroid:host=&quot;m.tsrj.com&quot;\nandroid:pathPrefix=&quot;/&quot;\nandroid:scheme=&quot;https&quot;/&gt;\n&lt;/intent-filter&gt;\n</code></pre><ol>\n<li>在MainActivity新增解析jump信息的方法</li>\n</ol>\n<pre><code>private void jump(Intent intent) {\n/** 根据传过来的参数 进行jump跳转 **/\nString action_url = intent.getDataString();\nMLog.i(&quot;启动Main_action_url:&quot; + action_url);\nif (!TextUtils.isEmpty(action_url)) {\nJumpManager.jump(this, action_url);\n} \n}\n\nJumpManger就实现解析数据然后根据URI跳转的功能\npublic static boolean jump(Context ctx, String action_url) {\n\nif (TextUtils.isEmpty(action_url)) {\nreturn false;\n}\n\nMLog.d(&quot;JumpManager  url:&quot; + action_url);\n\nUri uri = null;\n\n/**如果不是一个标准的uri格式说明传入的数据无效的 可以直接忽视*/\n\ntry {\nuri = Uri.parse(action_url);\n} catch (Exception e) {\nreturn false;\n}\n\nif (uri == null) {\nreturn false;\n}\n\n/**检测到是一个合法的uri 先判断是否是满足跳转需求的头部 如果是 开始进行跳转检测 如果不是 直接往内置浏览器跳*/\n\nif (!action_url.startsWith(JumpUriFactory.JUM_URL_HEAD) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_S) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_CUSTOM)) {\n\nreturn false;\n}\n\nIntent jumpintent = null;\n\nList&lt;String&gt; paths = uri.getPathSegments();\n\n/**只有头没有页面参数就返回*/\nif (paths == null || paths.size() &lt;= 0) {\n\nreturn false;\n}\n\n/**有path 但是path里面为空值 直接打开*/\nString action = paths.get(0);\nif (TextUtils.isEmpty(action)) {\nif (!isFromWebView) {\njumpToInteriorPageActivity(ctx, uri);\n}\nreturn false;\n}\n\n/** 使用系统浏览器打开 */\nif (action.equals(&quot;web_system&quot;)) {\njumpToSystemWebPage(ctx, uri);\nreturn true;\n}\n\n\n/*else if (action.equals(JumpPageSet.detail)) {\ngoWaitress(ctx, action_url);\nreturn true;\n}*/\n\n/** city */\nelse if (action.equals(JumpPageSet.city)) {\ngoCity(ctx, action_url);\nreturn true;\n}\n\n/** usercenter */\nelse if (action.equals(JumpPageSet.personal_info)) {\ngoUserCenter(ctx, action_url);\nreturn true;\n}\n</code></pre><ol>\n<li>处理uri解析出里面的参数,放入intent，并跳往相应的主页</li>\n</ol>\n<pre><code>/**\n * 将url的数据进行解析 得到一个存放所有参数的集合\n */\npublic static Set&lt;String&gt; getMyQueryParameterNames(Uri uri) {\n    String query = uri.getEncodedQuery();\n    if (query == null) {\n        return Collections.emptySet();\n    }\n    Set&lt;String&gt; names = new LinkedHashSet&lt;String&gt;();\n    int start = 0;\n    do {\n        int next = query.indexOf(&apos;&amp;&apos;, start);\n        int end = (next == -1) ? query.length() : next;\n        int separator = query.indexOf(&apos;=&apos;, start);\n        if (separator &gt; end || separator == -1) {\n            separator = end;\n        }\n        String name = query.substring(start, separator);\n        names.add(Uri.decode(name));\n        // Move start to end of name.\n        start = end + 1;\n    } while (start &lt; query.length());\n    return Collections.unmodifiableSet(names);\n}\nprivate static void goWaitress(final Context ctx, String actionUrl) {\n    MLog.i(&quot;actionUrl&quot;+actionUrl);\n    Uri  uri;\n    uri=Uri.parse(actionUrl);\n    Set&lt;String&gt;  parameters=JumpManager.getMyQueryParameterNames(uri);\n    Hashtable&lt;String,String&gt; params=new Hashtable&lt;&gt;();\n    if(parameters!=null&amp;&amp;parameters.size()&gt;0){\n        for(String key:parameters){\n            String value=uri.getQueryParameter(key);\n            if(!TextUtils.isEmpty(value)){\n                params.put(key,value);\n            }\n        }\n    }\n    Intent it= new Intent(act, WaitressPage.class);\n    Set&lt;String&gt;  keySet=params.keySet();\n    for (String k:keySet){\n        it.putExtra(k,params.get(k));\n    }\n    startActivity(it);\n    }\n</code></pre><h1 id=\"DeepLink的坑：\"><a href=\"#DeepLink的坑：\" class=\"headerlink\" title=\"DeepLink的坑：\"></a>DeepLink的坑：</h1><ol>\n<li>由于有些页面有权限限制，所以要跳页面时候，要判断在当前账户当前版本是否可以打开</li>\n<li>如果从H5页面带过来的信息带有登录状态，而且当前app的账号信息和H5页面的不一致，可能需要一个账号切换工作</li>\n</ol>\n<p>#微信里面的deeplink：<br>微信里面的主要就是二维码加上linkme，linkme和微信有合作可以直接把分享的内容通过里面的二维码倒回到app，不过这里要注意一个问题<br>微信里面的图片对size 是有要求的</p>\n<p>图片size越大被压的越厉害，，这个即使通过以下方式绕过微信sdk也无法避免被压缩</p>\n<pre><code>try {\n    Intent intent = new Intent(Intent.ACTION_VIEW);\n    intent.setAction(Intent.ACTION_VIEW);\n    intent.addCategory(Intent.CATEGORY_DEFAULT);\n    ComponentName cmp = new ComponentName(&quot;com.tencent.mm&quot;, &quot;com.tencent.mm.ui.tools.ShareScreenImgUI&quot;);\n    intent.setComponent(cmp);\n    String path = localImgPath;\n    if (!TextUtils.isEmpty(path) &amp;&amp; !path.startsWith(&quot;file://&quot;)) {\n        path = &quot;file://&quot; + path;\n    }\n    intent.setDataAndType(Uri.parse(path), &quot;image/jpeg&quot;);\n    act.startActivity(intent);\n} catch (Exception e) {\n    ELog.e(&quot;wechat share failed&quot;);\n}\n</code></pre><p> 所以只有自己先压缩图片到一定的size，  再在这张压缩过的图片上绘制真正的二维码才行，（如果遇到好心的UI把二维码设计的很大就，可以跳过这个坑）</p>\n","excerpt":"","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>deeplink指的是在第三方客户端/浏览器中，打开一个APP的H5页面时候，如果发现本地安装了这个APP，就会使用本地APP打开。<br>需要前端和客户端互相配合来实现本功能。</p>\n<h1 id=\"服务器端：\"><a href=\"#服务器端：\" class=\"headerlink\" title=\"服务器端：\"></a>服务器端：</h1><pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta property=&quot;al:ios:url&quot; content=&quot;applinks://docs&quot; /&gt;\n&lt;meta property=&quot;al:ios:app_store_id&quot; content=&quot;12345&quot; /&gt;\n&lt;meta property=&quot;al:ios:app_name&quot; content=&quot;App Links&quot; /&gt;\n&lt;meta property=&quot;al:android:url&quot; content=&quot;applinks://docs&quot; /&gt;\n&lt;meta property=&quot;al:android:app_name&quot; content=&quot;App Links&quot; /&gt;\n&lt;meta property=&quot;al:android:package&quot; content=&quot;org.applinks&quot; /&gt;\n&lt;meta property=&quot;al:web:url&quot;\ncontent=&quot;http://applinks.org/documentation&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\nHello, world!\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h1 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h1><p>客户端deeplink的实现需要依靠jump系统。ps:jump系统可以通过URI 实现在app中的定向跳转 ，比如我们的app叫“天上人间”（缩写tsrj）。 </p>\n<ol>\n<li>需要先在menifest中注册相应的scheme的filter。<br>ps:一般加载主页上面.</li>\n</ol>\n<pre><code>&lt;intent-filter&gt;\n&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n&lt;!-- Accepts URIs that begin with &quot;tsrj://&quot; --&gt;\n&lt;data android:scheme=&quot;tsrj&quot;/&gt;\n&lt;/intent-filter&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n&lt;!-- Accepts URIs that begin with &quot;http://m.tsrj.com/&quot; --&gt;\n&lt;data\nandroid:host=&quot;m.tsrj.com&quot;\nandroid:pathPrefix=&quot;/&quot;\nandroid:scheme=&quot;http&quot;/&gt;\n&lt;data\nandroid:host=&quot;m.tsrj.com&quot;\nandroid:pathPrefix=&quot;/&quot;\nandroid:scheme=&quot;https&quot;/&gt;\n&lt;/intent-filter&gt;\n</code></pre><ol>\n<li>在MainActivity新增解析jump信息的方法</li>\n</ol>\n<pre><code>private void jump(Intent intent) {\n/** 根据传过来的参数 进行jump跳转 **/\nString action_url = intent.getDataString();\nMLog.i(&quot;启动Main_action_url:&quot; + action_url);\nif (!TextUtils.isEmpty(action_url)) {\nJumpManager.jump(this, action_url);\n} \n}\n\nJumpManger就实现解析数据然后根据URI跳转的功能\npublic static boolean jump(Context ctx, String action_url) {\n\nif (TextUtils.isEmpty(action_url)) {\nreturn false;\n}\n\nMLog.d(&quot;JumpManager  url:&quot; + action_url);\n\nUri uri = null;\n\n/**如果不是一个标准的uri格式说明传入的数据无效的 可以直接忽视*/\n\ntry {\nuri = Uri.parse(action_url);\n} catch (Exception e) {\nreturn false;\n}\n\nif (uri == null) {\nreturn false;\n}\n\n/**检测到是一个合法的uri 先判断是否是满足跳转需求的头部 如果是 开始进行跳转检测 如果不是 直接往内置浏览器跳*/\n\nif (!action_url.startsWith(JumpUriFactory.JUM_URL_HEAD) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_S) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_CUSTOM)) {\n\nreturn false;\n}\n\nIntent jumpintent = null;\n\nList&lt;String&gt; paths = uri.getPathSegments();\n\n/**只有头没有页面参数就返回*/\nif (paths == null || paths.size() &lt;= 0) {\n\nreturn false;\n}\n\n/**有path 但是path里面为空值 直接打开*/\nString action = paths.get(0);\nif (TextUtils.isEmpty(action)) {\nif (!isFromWebView) {\njumpToInteriorPageActivity(ctx, uri);\n}\nreturn false;\n}\n\n/** 使用系统浏览器打开 */\nif (action.equals(&quot;web_system&quot;)) {\njumpToSystemWebPage(ctx, uri);\nreturn true;\n}\n\n\n/*else if (action.equals(JumpPageSet.detail)) {\ngoWaitress(ctx, action_url);\nreturn true;\n}*/\n\n/** city */\nelse if (action.equals(JumpPageSet.city)) {\ngoCity(ctx, action_url);\nreturn true;\n}\n\n/** usercenter */\nelse if (action.equals(JumpPageSet.personal_info)) {\ngoUserCenter(ctx, action_url);\nreturn true;\n}\n</code></pre><ol>\n<li>处理uri解析出里面的参数,放入intent，并跳往相应的主页</li>\n</ol>\n<pre><code>/**\n * 将url的数据进行解析 得到一个存放所有参数的集合\n */\npublic static Set&lt;String&gt; getMyQueryParameterNames(Uri uri) {\n    String query = uri.getEncodedQuery();\n    if (query == null) {\n        return Collections.emptySet();\n    }\n    Set&lt;String&gt; names = new LinkedHashSet&lt;String&gt;();\n    int start = 0;\n    do {\n        int next = query.indexOf(&apos;&amp;&apos;, start);\n        int end = (next == -1) ? query.length() : next;\n        int separator = query.indexOf(&apos;=&apos;, start);\n        if (separator &gt; end || separator == -1) {\n            separator = end;\n        }\n        String name = query.substring(start, separator);\n        names.add(Uri.decode(name));\n        // Move start to end of name.\n        start = end + 1;\n    } while (start &lt; query.length());\n    return Collections.unmodifiableSet(names);\n}\nprivate static void goWaitress(final Context ctx, String actionUrl) {\n    MLog.i(&quot;actionUrl&quot;+actionUrl);\n    Uri  uri;\n    uri=Uri.parse(actionUrl);\n    Set&lt;String&gt;  parameters=JumpManager.getMyQueryParameterNames(uri);\n    Hashtable&lt;String,String&gt; params=new Hashtable&lt;&gt;();\n    if(parameters!=null&amp;&amp;parameters.size()&gt;0){\n        for(String key:parameters){\n            String value=uri.getQueryParameter(key);\n            if(!TextUtils.isEmpty(value)){\n                params.put(key,value);\n            }\n        }\n    }\n    Intent it= new Intent(act, WaitressPage.class);\n    Set&lt;String&gt;  keySet=params.keySet();\n    for (String k:keySet){\n        it.putExtra(k,params.get(k));\n    }\n    startActivity(it);\n    }\n</code></pre><h1 id=\"DeepLink的坑：\"><a href=\"#DeepLink的坑：\" class=\"headerlink\" title=\"DeepLink的坑：\"></a>DeepLink的坑：</h1><ol>\n<li>由于有些页面有权限限制，所以要跳页面时候，要判断在当前账户当前版本是否可以打开</li>\n<li>如果从H5页面带过来的信息带有登录状态，而且当前app的账号信息和H5页面的不一致，可能需要一个账号切换工作</li>\n</ol>\n<p>#微信里面的deeplink：<br>微信里面的主要就是二维码加上linkme，linkme和微信有合作可以直接把分享的内容通过里面的二维码倒回到app，不过这里要注意一个问题<br>微信里面的图片对size 是有要求的</p>\n<p>图片size越大被压的越厉害，，这个即使通过以下方式绕过微信sdk也无法避免被压缩</p>\n<pre><code>try {\n    Intent intent = new Intent(Intent.ACTION_VIEW);\n    intent.setAction(Intent.ACTION_VIEW);\n    intent.addCategory(Intent.CATEGORY_DEFAULT);\n    ComponentName cmp = new ComponentName(&quot;com.tencent.mm&quot;, &quot;com.tencent.mm.ui.tools.ShareScreenImgUI&quot;);\n    intent.setComponent(cmp);\n    String path = localImgPath;\n    if (!TextUtils.isEmpty(path) &amp;&amp; !path.startsWith(&quot;file://&quot;)) {\n        path = &quot;file://&quot; + path;\n    }\n    intent.setDataAndType(Uri.parse(path), &quot;image/jpeg&quot;);\n    act.startActivity(intent);\n} catch (Exception e) {\n    ELog.e(&quot;wechat share failed&quot;);\n}\n</code></pre><p> 所以只有自己先压缩图片到一定的size，  再在这张压缩过的图片上绘制真正的二维码才行，（如果遇到好心的UI把二维码设计的很大就，可以跳过这个坑）</p>\n"},{"title":"Github 教程","date":"2015-11-01T12:10:33.000Z","_content":"\n\n## 本地工程上传github\n1. 首先在github上创建一个resp\n2. 在本地工程里面引入 .gitignore\n  * 在androidstudio 安装一个ignore 插件，可以生成部分ignore\n  * 对于gradle目录的工程，每一个存在build.gradle目录都需要放一个.gitignore\n  * .gitignore 内容 （对于android的gradle目录结构最完整的ignore文件）[原文件](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore) \n        \n        \n        .gradle\n        /local.properties\n        /gradle.properties\n        /.idea/workspace.xml\n        /.idea/libraries\n        .DS_Store\n        /build\n        /captures\n        bin\n        gen\n        .settings\n        .idea\n        target\n        *.iml\n        *.key\n\n\n\n4. touch README.md  》》生成 reamdme文件\n    \n5. git init当前工程 》》生成 git信息\n\n6. git add -A 》》把当前工程除了ingore的添加到git里面\n\n7. git commit 》》生成第一次的commit信息\n\n8. git remote add origin git@github.com:liuyicheng3/NewRepo.git   》》设置当前git工程的远程分支\n\n9. git push -u origin master 》》push 到github上去\n\n10. Attention:一般android studio的默认ssh是 androidstudio自己的，所以这时候用android studio会提交不上去\n  需要在settiings>vertion control> git里面吧 SSH excutable 由built-in 改成 native\n\n\n##维护git文档方法\n * 可以网页里面直接弄，就不要通本地修改再提交，太麻烦。\n * 涉及到外部链接的图片文件，git库里面建对应的文件夹统一维护。\n * 对于图片贴的地址一定要是raw的，不要那个github上显示的地址\n```markdown\n[原文件](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore) \n```\n\n## 一般的git工作流程\n\n### 版本管理 \n### 按featrue 开发\n### codereview及合并\n\n## Markdown 快捷键\n   1. 空两行，让后代码区域两个TAB\n   2. shift tab  收回一个tab\n\n\n##  Git 必须踩的坑\n###  1、不小心提交错了分支，把修改直接提交到master里面了\n\tgit push --force\n\n###  2、git  reset   git revert\nhttp://www.cnblogs.com/wanqieddy/archive/2013/05/14/3077689.html\n\n\n\n\n\n\n","source":"_posts/github_guide.md","raw":"title: Github 教程\ndate: 2015-11-01 20:10:33\ncategories:\n- 工具\ntags:\n- github\n- 工具\n\n---\n\n\n## 本地工程上传github\n1. 首先在github上创建一个resp\n2. 在本地工程里面引入 .gitignore\n  * 在androidstudio 安装一个ignore 插件，可以生成部分ignore\n  * 对于gradle目录的工程，每一个存在build.gradle目录都需要放一个.gitignore\n  * .gitignore 内容 （对于android的gradle目录结构最完整的ignore文件）[原文件](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore) \n        \n        \n        .gradle\n        /local.properties\n        /gradle.properties\n        /.idea/workspace.xml\n        /.idea/libraries\n        .DS_Store\n        /build\n        /captures\n        bin\n        gen\n        .settings\n        .idea\n        target\n        *.iml\n        *.key\n\n\n\n4. touch README.md  》》生成 reamdme文件\n    \n5. git init当前工程 》》生成 git信息\n\n6. git add -A 》》把当前工程除了ingore的添加到git里面\n\n7. git commit 》》生成第一次的commit信息\n\n8. git remote add origin git@github.com:liuyicheng3/NewRepo.git   》》设置当前git工程的远程分支\n\n9. git push -u origin master 》》push 到github上去\n\n10. Attention:一般android studio的默认ssh是 androidstudio自己的，所以这时候用android studio会提交不上去\n  需要在settiings>vertion control> git里面吧 SSH excutable 由built-in 改成 native\n\n\n##维护git文档方法\n * 可以网页里面直接弄，就不要通本地修改再提交，太麻烦。\n * 涉及到外部链接的图片文件，git库里面建对应的文件夹统一维护。\n * 对于图片贴的地址一定要是raw的，不要那个github上显示的地址\n```markdown\n[原文件](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore) \n```\n\n## 一般的git工作流程\n\n### 版本管理 \n### 按featrue 开发\n### codereview及合并\n\n## Markdown 快捷键\n   1. 空两行，让后代码区域两个TAB\n   2. shift tab  收回一个tab\n\n\n##  Git 必须踩的坑\n###  1、不小心提交错了分支，把修改直接提交到master里面了\n\tgit push --force\n\n###  2、git  reset   git revert\nhttp://www.cnblogs.com/wanqieddy/archive/2013/05/14/3077689.html\n\n\n\n\n\n\n","slug":"github_guide","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lca0010sfjfhtssbd9c","content":"<h2 id=\"本地工程上传github\"><a href=\"#本地工程上传github\" class=\"headerlink\" title=\"本地工程上传github\"></a>本地工程上传github</h2><ol>\n<li>首先在github上创建一个resp</li>\n<li>在本地工程里面引入 .gitignore<ul>\n<li>在androidstudio 安装一个ignore 插件，可以生成部分ignore</li>\n<li>对于gradle目录的工程，每一个存在build.gradle目录都需要放一个.gitignore</li>\n<li>.gitignore 内容 （对于android的gradle目录结构最完整的ignore文件）<a href=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore\" target=\"_blank\" rel=\"external\">原文件</a> </li>\n</ul>\n</li>\n</ol>\n<pre><code>.gradle\n/local.properties\n/gradle.properties\n/.idea/workspace.xml\n/.idea/libraries\n.DS_Store\n/build\n/captures\nbin\ngen\n.settings\n.idea\ntarget\n*.iml\n*.key\n</code></pre><ol>\n<li><p>touch README.md  》》生成 reamdme文件</p>\n</li>\n<li><p>git init当前工程 》》生成 git信息</p>\n</li>\n<li><p>git add -A 》》把当前工程除了ingore的添加到git里面</p>\n</li>\n<li><p>git commit 》》生成第一次的commit信息</p>\n</li>\n<li><p>git remote add origin git@github.com:liuyicheng3/NewRepo.git   》》设置当前git工程的远程分支</p>\n</li>\n<li><p>git push -u origin master 》》push 到github上去</p>\n</li>\n<li><p>Attention:一般android studio的默认ssh是 androidstudio自己的，所以这时候用android studio会提交不上去<br>需要在settiings&gt;vertion control&gt; git里面吧 SSH excutable 由built-in 改成 native</p>\n</li>\n</ol>\n<p>##维护git文档方法</p>\n<ul>\n<li>可以网页里面直接弄，就不要通本地修改再提交，太麻烦。</li>\n<li>涉及到外部链接的图片文件，git库里面建对应的文件夹统一维护。</li>\n<li>对于图片贴的地址一定要是raw的，不要那个github上显示的地址<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">原文件</span>](<span class=\"link\">https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"一般的git工作流程\"><a href=\"#一般的git工作流程\" class=\"headerlink\" title=\"一般的git工作流程\"></a>一般的git工作流程</h2><h3 id=\"版本管理\"><a href=\"#版本管理\" class=\"headerlink\" title=\"版本管理\"></a>版本管理</h3><h3 id=\"按featrue-开发\"><a href=\"#按featrue-开发\" class=\"headerlink\" title=\"按featrue 开发\"></a>按featrue 开发</h3><h3 id=\"codereview及合并\"><a href=\"#codereview及合并\" class=\"headerlink\" title=\"codereview及合并\"></a>codereview及合并</h3><h2 id=\"Markdown-快捷键\"><a href=\"#Markdown-快捷键\" class=\"headerlink\" title=\"Markdown 快捷键\"></a>Markdown 快捷键</h2><ol>\n<li>空两行，让后代码区域两个TAB</li>\n<li>shift tab  收回一个tab</li>\n</ol>\n<h2 id=\"Git-必须踩的坑\"><a href=\"#Git-必须踩的坑\" class=\"headerlink\" title=\"Git 必须踩的坑\"></a>Git 必须踩的坑</h2><h3 id=\"1、不小心提交错了分支，把修改直接提交到master里面了\"><a href=\"#1、不小心提交错了分支，把修改直接提交到master里面了\" class=\"headerlink\" title=\"1、不小心提交错了分支，把修改直接提交到master里面了\"></a>1、不小心提交错了分支，把修改直接提交到master里面了</h3><pre><code>git push --force\n</code></pre><h3 id=\"2、git-reset-git-revert\"><a href=\"#2、git-reset-git-revert\" class=\"headerlink\" title=\"2、git  reset   git revert\"></a>2、git  reset   git revert</h3><p><a href=\"http://www.cnblogs.com/wanqieddy/archive/2013/05/14/3077689.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/wanqieddy/archive/2013/05/14/3077689.html</a></p>\n","excerpt":"","more":"<h2 id=\"本地工程上传github\"><a href=\"#本地工程上传github\" class=\"headerlink\" title=\"本地工程上传github\"></a>本地工程上传github</h2><ol>\n<li>首先在github上创建一个resp</li>\n<li>在本地工程里面引入 .gitignore<ul>\n<li>在androidstudio 安装一个ignore 插件，可以生成部分ignore</li>\n<li>对于gradle目录的工程，每一个存在build.gradle目录都需要放一个.gitignore</li>\n<li>.gitignore 内容 （对于android的gradle目录结构最完整的ignore文件）<a href=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore\">原文件</a> </li>\n</ul>\n</li>\n</ol>\n<pre><code>.gradle\n/local.properties\n/gradle.properties\n/.idea/workspace.xml\n/.idea/libraries\n.DS_Store\n/build\n/captures\nbin\ngen\n.settings\n.idea\ntarget\n*.iml\n*.key\n</code></pre><ol>\n<li><p>touch README.md  》》生成 reamdme文件</p>\n</li>\n<li><p>git init当前工程 》》生成 git信息</p>\n</li>\n<li><p>git add -A 》》把当前工程除了ingore的添加到git里面</p>\n</li>\n<li><p>git commit 》》生成第一次的commit信息</p>\n</li>\n<li><p>git remote add origin git@github.com:liuyicheng3/NewRepo.git   》》设置当前git工程的远程分支</p>\n</li>\n<li><p>git push -u origin master 》》push 到github上去</p>\n</li>\n<li><p>Attention:一般android studio的默认ssh是 androidstudio自己的，所以这时候用android studio会提交不上去<br>需要在settiings&gt;vertion control&gt; git里面吧 SSH excutable 由built-in 改成 native</p>\n</li>\n</ol>\n<p>##维护git文档方法</p>\n<ul>\n<li>可以网页里面直接弄，就不要通本地修改再提交，太麻烦。</li>\n<li>涉及到外部链接的图片文件，git库里面建对应的文件夹统一维护。</li>\n<li>对于图片贴的地址一定要是raw的，不要那个github上显示的地址<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">原文件</span>](<span class=\"link\">https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/files/.gitignore</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"一般的git工作流程\"><a href=\"#一般的git工作流程\" class=\"headerlink\" title=\"一般的git工作流程\"></a>一般的git工作流程</h2><h3 id=\"版本管理\"><a href=\"#版本管理\" class=\"headerlink\" title=\"版本管理\"></a>版本管理</h3><h3 id=\"按featrue-开发\"><a href=\"#按featrue-开发\" class=\"headerlink\" title=\"按featrue 开发\"></a>按featrue 开发</h3><h3 id=\"codereview及合并\"><a href=\"#codereview及合并\" class=\"headerlink\" title=\"codereview及合并\"></a>codereview及合并</h3><h2 id=\"Markdown-快捷键\"><a href=\"#Markdown-快捷键\" class=\"headerlink\" title=\"Markdown 快捷键\"></a>Markdown 快捷键</h2><ol>\n<li>空两行，让后代码区域两个TAB</li>\n<li>shift tab  收回一个tab</li>\n</ol>\n<h2 id=\"Git-必须踩的坑\"><a href=\"#Git-必须踩的坑\" class=\"headerlink\" title=\"Git 必须踩的坑\"></a>Git 必须踩的坑</h2><h3 id=\"1、不小心提交错了分支，把修改直接提交到master里面了\"><a href=\"#1、不小心提交错了分支，把修改直接提交到master里面了\" class=\"headerlink\" title=\"1、不小心提交错了分支，把修改直接提交到master里面了\"></a>1、不小心提交错了分支，把修改直接提交到master里面了</h3><pre><code>git push --force\n</code></pre><h3 id=\"2、git-reset-git-revert\"><a href=\"#2、git-reset-git-revert\" class=\"headerlink\" title=\"2、git  reset   git revert\"></a>2、git  reset   git revert</h3><p><a href=\"http://www.cnblogs.com/wanqieddy/archive/2013/05/14/3077689.html\">http://www.cnblogs.com/wanqieddy/archive/2013/05/14/3077689.html</a></p>\n"},{"title":"AS 踩坑日记","date":"2015-11-01T12:10:33.000Z","_content":"\n\n\n升级instant run时候的报错\nError:Access to the dex task is now impossible, starting with 1.4.0\n1.4.0 introduces a new Transform API allowing manipulation of the .class files.\nSee more information: http://tools.android.com/tech-docs/new-build-system/transform-api\n\n解决方案：\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.0.0'\n\n    }\n}\n\n改成1.3.0\n\n\n项目根目录的gradle的\ngrade.property\n\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-2.2-all.zip\n","source":"_posts/gradle坑.md","raw":"title: AS 踩坑日记\ndate: 2015-11-01 20:10:33\ncategories:\n- 工具\ntags:\n- 工具\n\n---\n\n\n\n升级instant run时候的报错\nError:Access to the dex task is now impossible, starting with 1.4.0\n1.4.0 introduces a new Transform API allowing manipulation of the .class files.\nSee more information: http://tools.android.com/tech-docs/new-build-system/transform-api\n\n解决方案：\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.0.0'\n\n    }\n}\n\n改成1.3.0\n\n\n项目根目录的gradle的\ngrade.property\n\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-2.2-all.zip\n","slug":"gradle坑","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lcd0014sfjfavjthtfy","content":"<p>升级instant run时候的报错<br>Error:Access to the dex task is now impossible, starting with 1.4.0<br>1.4.0 introduces a new Transform API allowing manipulation of the .class files.<br>See more information: <a href=\"http://tools.android.com/tech-docs/new-build-system/transform-api\" target=\"_blank\" rel=\"external\">http://tools.android.com/tech-docs/new-build-system/transform-api</a></p>\n<p>解决方案：</p>\n<p>buildscript {<br>    repositories {<br>        jcenter()<br>    }<br>    dependencies {<br>        classpath ‘com.android.tools.build:gradle:2.0.0’</p>\n<pre><code>}\n</code></pre><p>}</p>\n<p>改成1.3.0</p>\n<p>项目根目录的gradle的<br>grade.property</p>\n<p>distributionUrl=https\\://services.gradle.org/distributions/gradle-2.2-all.zip</p>\n","excerpt":"","more":"<p>升级instant run时候的报错<br>Error:Access to the dex task is now impossible, starting with 1.4.0<br>1.4.0 introduces a new Transform API allowing manipulation of the .class files.<br>See more information: <a href=\"http://tools.android.com/tech-docs/new-build-system/transform-api\">http://tools.android.com/tech-docs/new-build-system/transform-api</a></p>\n<p>解决方案：</p>\n<p>buildscript {<br>    repositories {<br>        jcenter()<br>    }<br>    dependencies {<br>        classpath ‘com.android.tools.build:gradle:2.0.0’</p>\n<pre><code>}\n</code></pre><p>}</p>\n<p>改成1.3.0</p>\n<p>项目根目录的gradle的<br>grade.property</p>\n<p>distributionUrl=https\\://services.gradle.org/distributions/gradle-2.2-all.zip</p>\n"},{"title":"iOS入门","date":"2015-11-01T12:10:33.000Z","_content":"\n# 第一课：熟悉OC语法\n\n# 第二课：storyboard和 手写View\n\nstoryboard;\n\n直接往上面拖放控件，然后按住ctr  把控件拖动到   @implementation，就相当于自动findview了，可以直接使用是这个控件了  \n\n   @property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;\n\n\n还有一种就是直接关联上点击事件\n把控件直接拖动到这个申明方法上就可以了\n\n\n    - (IBAction)showAlert:(id)sender;\n\n这个的原理可以看看storyboard的文件内容就可以明白了，大致和android的类似\n\n\n\n图片资源文件两种放法\n1. 在Supporting  Files 同级添加一个Resources的包，里面直接放图片进去（可以只放三倍图）   \n\n         UIImageView *imageView = [[UIImageView alloc] init];\n            imageView.image = [UIImage imageNamed:@\"home_banner.png\"];\t// 正常显示的图片\n            \n2. 在Assets.xcaseset里面右键新建New image set，然后手动把图片拖动到右边的一倍两倍三倍的框框中去 \n\n\n\n\nstoryboard  改成手写UI类型  \n\n1. 第一步： \n- 删除storyboard文件  \n- 编辑Supporting Files目录下的 .plist文件,\n删除Main storyboard  file name这一项\n2. 第二步：\n    编辑AppDelegate\n\n    \n    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n        self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n        [self.window makeKeyAndVisible];\n        \n        ViewController *__rootController = [[ViewController alloc] init];\n        UINavigationController *__navCtrler = [[UINavigationController alloc] initWithRootViewController:__rootController];\n        __navCtrler.navigationBarHidden = YES;\n        self.window.rootViewController = __navCtrler;\n      // Override point for customization after application launch.\n        return YES;\n    }\n\n\n这个相当于Application的oncreate,在这里加载Entry activity\n\n\n在ViewController里面手动往根View里面添加控件\n\n    - (void)viewDidLoad {\n        [super viewDidLoad];\n        \n        UILabel *firstLable=[[UILabel alloc]init];\n        firstLable.frame=CGRectMake(0, 0, 100, 100);\n        firstLable.backgroundColor = [UIColor whiteColor]; //设置lable背景颜色为黑色\n    \n        firstLable.text=@\"第一级\";\n        firstLable.userInteractionEnabled = YES;\n    \n        [firstLable setTextColor:[UIColor greenColor]]; //设置文本字体颜色为白色\n    \n        [self.view addSubview:firstLable];\n        UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapLable:)];\n        [firstLable addGestureRecognizer:singleTap];\n        \n        // Do any additional setup after loading the view, typically from a nib.\n    }\n\n\nviewDidLoad 相当于Activity的oncreate，这里我们就是手写View，然后加到根View里面去 self.view\n    [self.view addSubview:firstLable];\n\n\n\n# 第三课：Viewcontroller  之间的跳转\n\n在ViewController从一个Viewcontroller跳到另外一个SecondViewController\n\n    -(void) tapLable:(UILabel *)sender{\n        NSLog(@\"进入第二级Controller\");\n        \n        SecondViewController *controller = [[SecondViewController alloc] init];\n        [self.navigationController pushViewController:controller animated:YES];\n    }\n\n\n在SecondViewController也是一样的写法\n\n 返回第一个VIewCOntroller的方法\n\n    [self.navigationController popViewControllerAnimated:YES];\n","source":"_posts/iOS学习笔记.md","raw":"title: iOS入门\ndate: 2015-11-01 20:10:33\ncategories:\n- iOS\ntags:\n- ios入门\n\n---\n\n# 第一课：熟悉OC语法\n\n# 第二课：storyboard和 手写View\n\nstoryboard;\n\n直接往上面拖放控件，然后按住ctr  把控件拖动到   @implementation，就相当于自动findview了，可以直接使用是这个控件了  \n\n   @property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;\n\n\n还有一种就是直接关联上点击事件\n把控件直接拖动到这个申明方法上就可以了\n\n\n    - (IBAction)showAlert:(id)sender;\n\n这个的原理可以看看storyboard的文件内容就可以明白了，大致和android的类似\n\n\n\n图片资源文件两种放法\n1. 在Supporting  Files 同级添加一个Resources的包，里面直接放图片进去（可以只放三倍图）   \n\n         UIImageView *imageView = [[UIImageView alloc] init];\n            imageView.image = [UIImage imageNamed:@\"home_banner.png\"];\t// 正常显示的图片\n            \n2. 在Assets.xcaseset里面右键新建New image set，然后手动把图片拖动到右边的一倍两倍三倍的框框中去 \n\n\n\n\nstoryboard  改成手写UI类型  \n\n1. 第一步： \n- 删除storyboard文件  \n- 编辑Supporting Files目录下的 .plist文件,\n删除Main storyboard  file name这一项\n2. 第二步：\n    编辑AppDelegate\n\n    \n    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n        self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n        [self.window makeKeyAndVisible];\n        \n        ViewController *__rootController = [[ViewController alloc] init];\n        UINavigationController *__navCtrler = [[UINavigationController alloc] initWithRootViewController:__rootController];\n        __navCtrler.navigationBarHidden = YES;\n        self.window.rootViewController = __navCtrler;\n      // Override point for customization after application launch.\n        return YES;\n    }\n\n\n这个相当于Application的oncreate,在这里加载Entry activity\n\n\n在ViewController里面手动往根View里面添加控件\n\n    - (void)viewDidLoad {\n        [super viewDidLoad];\n        \n        UILabel *firstLable=[[UILabel alloc]init];\n        firstLable.frame=CGRectMake(0, 0, 100, 100);\n        firstLable.backgroundColor = [UIColor whiteColor]; //设置lable背景颜色为黑色\n    \n        firstLable.text=@\"第一级\";\n        firstLable.userInteractionEnabled = YES;\n    \n        [firstLable setTextColor:[UIColor greenColor]]; //设置文本字体颜色为白色\n    \n        [self.view addSubview:firstLable];\n        UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapLable:)];\n        [firstLable addGestureRecognizer:singleTap];\n        \n        // Do any additional setup after loading the view, typically from a nib.\n    }\n\n\nviewDidLoad 相当于Activity的oncreate，这里我们就是手写View，然后加到根View里面去 self.view\n    [self.view addSubview:firstLable];\n\n\n\n# 第三课：Viewcontroller  之间的跳转\n\n在ViewController从一个Viewcontroller跳到另外一个SecondViewController\n\n    -(void) tapLable:(UILabel *)sender{\n        NSLog(@\"进入第二级Controller\");\n        \n        SecondViewController *controller = [[SecondViewController alloc] init];\n        [self.navigationController pushViewController:controller animated:YES];\n    }\n\n\n在SecondViewController也是一样的写法\n\n 返回第一个VIewCOntroller的方法\n\n    [self.navigationController popViewControllerAnimated:YES];\n","slug":"iOS学习笔记","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lcf0018sfjfmu04hl4x","content":"<h1 id=\"第一课：熟悉OC语法\"><a href=\"#第一课：熟悉OC语法\" class=\"headerlink\" title=\"第一课：熟悉OC语法\"></a>第一课：熟悉OC语法</h1><h1 id=\"第二课：storyboard和-手写View\"><a href=\"#第二课：storyboard和-手写View\" class=\"headerlink\" title=\"第二课：storyboard和 手写View\"></a>第二课：storyboard和 手写View</h1><p>storyboard;</p>\n<p>直接往上面拖放控件，然后按住ctr  把控件拖动到   @implementation，就相当于自动findview了，可以直接使用是这个控件了  </p>\n<p>   @property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;</p>\n<p>还有一种就是直接关联上点击事件<br>把控件直接拖动到这个申明方法上就可以了</p>\n<pre><code>- (IBAction)showAlert:(id)sender;\n</code></pre><p>这个的原理可以看看storyboard的文件内容就可以明白了，大致和android的类似</p>\n<p>图片资源文件两种放法</p>\n<ol>\n<li><p>在Supporting  Files 同级添加一个Resources的包，里面直接放图片进去（可以只放三倍图）   </p>\n<pre><code>UIImageView *imageView = [[UIImageView alloc] init];\n   imageView.image = [UIImage imageNamed:@&quot;home_banner.png&quot;];    // 正常显示的图片\n</code></pre></li>\n<li><p>在Assets.xcaseset里面右键新建New image set，然后手动把图片拖动到右边的一倍两倍三倍的框框中去 </p>\n</li>\n</ol>\n<p>storyboard  改成手写UI类型  </p>\n<ol>\n<li>第一步： </li>\n</ol>\n<ul>\n<li>删除storyboard文件  </li>\n<li>编辑Supporting Files目录下的 .plist文件,<br>删除Main storyboard  file name这一项</li>\n</ul>\n<ol>\n<li>第二步：<br> 编辑AppDelegate</li>\n</ol>\n<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n    [self.window makeKeyAndVisible];\n\n    ViewController *__rootController = [[ViewController alloc] init];\n    UINavigationController *__navCtrler = [[UINavigationController alloc] initWithRootViewController:__rootController];\n    __navCtrler.navigationBarHidden = YES;\n    self.window.rootViewController = __navCtrler;\n  // Override point for customization after application launch.\n    return YES;\n}\n</code></pre><p>这个相当于Application的oncreate,在这里加载Entry activity</p>\n<p>在ViewController里面手动往根View里面添加控件</p>\n<pre><code>- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UILabel *firstLable=[[UILabel alloc]init];\n    firstLable.frame=CGRectMake(0, 0, 100, 100);\n    firstLable.backgroundColor = [UIColor whiteColor]; //设置lable背景颜色为黑色\n\n    firstLable.text=@&quot;第一级&quot;;\n    firstLable.userInteractionEnabled = YES;\n\n    [firstLable setTextColor:[UIColor greenColor]]; //设置文本字体颜色为白色\n\n    [self.view addSubview:firstLable];\n    UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapLable:)];\n    [firstLable addGestureRecognizer:singleTap];\n\n    // Do any additional setup after loading the view, typically from a nib.\n}\n</code></pre><p>viewDidLoad 相当于Activity的oncreate，这里我们就是手写View，然后加到根View里面去 self.view<br>    [self.view addSubview:firstLable];</p>\n<h1 id=\"第三课：Viewcontroller-之间的跳转\"><a href=\"#第三课：Viewcontroller-之间的跳转\" class=\"headerlink\" title=\"第三课：Viewcontroller  之间的跳转\"></a>第三课：Viewcontroller  之间的跳转</h1><p>在ViewController从一个Viewcontroller跳到另外一个SecondViewController</p>\n<pre><code>-(void) tapLable:(UILabel *)sender{\n    NSLog(@&quot;进入第二级Controller&quot;);\n\n    SecondViewController *controller = [[SecondViewController alloc] init];\n    [self.navigationController pushViewController:controller animated:YES];\n}\n</code></pre><p>在SecondViewController也是一样的写法</p>\n<p> 返回第一个VIewCOntroller的方法</p>\n<pre><code>[self.navigationController popViewControllerAnimated:YES];\n</code></pre>","excerpt":"","more":"<h1 id=\"第一课：熟悉OC语法\"><a href=\"#第一课：熟悉OC语法\" class=\"headerlink\" title=\"第一课：熟悉OC语法\"></a>第一课：熟悉OC语法</h1><h1 id=\"第二课：storyboard和-手写View\"><a href=\"#第二课：storyboard和-手写View\" class=\"headerlink\" title=\"第二课：storyboard和 手写View\"></a>第二课：storyboard和 手写View</h1><p>storyboard;</p>\n<p>直接往上面拖放控件，然后按住ctr  把控件拖动到   @implementation，就相当于自动findview了，可以直接使用是这个控件了  </p>\n<p>   @property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;</p>\n<p>还有一种就是直接关联上点击事件<br>把控件直接拖动到这个申明方法上就可以了</p>\n<pre><code>- (IBAction)showAlert:(id)sender;\n</code></pre><p>这个的原理可以看看storyboard的文件内容就可以明白了，大致和android的类似</p>\n<p>图片资源文件两种放法</p>\n<ol>\n<li><p>在Supporting  Files 同级添加一个Resources的包，里面直接放图片进去（可以只放三倍图）   </p>\n<pre><code>UIImageView *imageView = [[UIImageView alloc] init];\n   imageView.image = [UIImage imageNamed:@&quot;home_banner.png&quot;];    // 正常显示的图片\n</code></pre></li>\n<li><p>在Assets.xcaseset里面右键新建New image set，然后手动把图片拖动到右边的一倍两倍三倍的框框中去 </p>\n</li>\n</ol>\n<p>storyboard  改成手写UI类型  </p>\n<ol>\n<li>第一步： </li>\n</ol>\n<ul>\n<li>删除storyboard文件  </li>\n<li>编辑Supporting Files目录下的 .plist文件,<br>删除Main storyboard  file name这一项</li>\n</ul>\n<ol>\n<li>第二步：<br> 编辑AppDelegate</li>\n</ol>\n<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n    [self.window makeKeyAndVisible];\n\n    ViewController *__rootController = [[ViewController alloc] init];\n    UINavigationController *__navCtrler = [[UINavigationController alloc] initWithRootViewController:__rootController];\n    __navCtrler.navigationBarHidden = YES;\n    self.window.rootViewController = __navCtrler;\n  // Override point for customization after application launch.\n    return YES;\n}\n</code></pre><p>这个相当于Application的oncreate,在这里加载Entry activity</p>\n<p>在ViewController里面手动往根View里面添加控件</p>\n<pre><code>- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UILabel *firstLable=[[UILabel alloc]init];\n    firstLable.frame=CGRectMake(0, 0, 100, 100);\n    firstLable.backgroundColor = [UIColor whiteColor]; //设置lable背景颜色为黑色\n\n    firstLable.text=@&quot;第一级&quot;;\n    firstLable.userInteractionEnabled = YES;\n\n    [firstLable setTextColor:[UIColor greenColor]]; //设置文本字体颜色为白色\n\n    [self.view addSubview:firstLable];\n    UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapLable:)];\n    [firstLable addGestureRecognizer:singleTap];\n\n    // Do any additional setup after loading the view, typically from a nib.\n}\n</code></pre><p>viewDidLoad 相当于Activity的oncreate，这里我们就是手写View，然后加到根View里面去 self.view<br>    [self.view addSubview:firstLable];</p>\n<h1 id=\"第三课：Viewcontroller-之间的跳转\"><a href=\"#第三课：Viewcontroller-之间的跳转\" class=\"headerlink\" title=\"第三课：Viewcontroller  之间的跳转\"></a>第三课：Viewcontroller  之间的跳转</h1><p>在ViewController从一个Viewcontroller跳到另外一个SecondViewController</p>\n<pre><code>-(void) tapLable:(UILabel *)sender{\n    NSLog(@&quot;进入第二级Controller&quot;);\n\n    SecondViewController *controller = [[SecondViewController alloc] init];\n    [self.navigationController pushViewController:controller animated:YES];\n}\n</code></pre><p>在SecondViewController也是一样的写法</p>\n<p> 返回第一个VIewCOntroller的方法</p>\n<pre><code>[self.navigationController popViewControllerAnimated:YES];\n</code></pre>"},{"title":"生成分享图片","date":"2018-01-02T16:00:00.000Z","_content":"\n# 常用模块 \nbs4  xml.dom.minidom  xml.etree   re\n\n# 1. bs4用法    \n详细使用文档 https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html    \nhttp://www.cnblogs.com/twinsclover/archive/2012/04/26/2471704.html  \n\n    from bs4 import BeautifulSoup\n\n    soup = BeautifulSoup(content, 'xml')  \n    itemList= soup.select('html > body > div[class=\"area\"] > ul.plist2.cf.ulList > li > a')  \n    itemList2= soup.select('div[id=\"newsList\"] > ul[id=\"v2\"] > li[class=\"item\"] > a ')   \n\n判断书是否有属性的方法 tem.contents[0].attrs.has_key\n\n    for item in itemList:\n       if item.contents[0].attrs.has_key('src'):\n           avatar = item.contents[0]['src']\n       elif item.contents[0].attrs.has_key('lz_src'):\n           avatar = item.contents[0]['lz_src']\n       else:\n           avatar='unset'\n           print item\n       star = StarItem(item.text,avatar)\n       currentPageStars.append(star)  \n\n判断是否有子元素的方法 newsItemDiv.p   \n获取元素标签里面值的方法newsItemDiv.p.string\n\n    for index,newsItemDiv in enumerate(itemList):\n       tranItem = NewsItem(newsItemDiv.p.string if newsItemDiv.p else \"\",newsItemDiv.img['data-src'] if newsItemDiv.img else \"\",proto+\"/\"+domain+newsItemDiv['href'])\n       newsItems.append(str(tranItem)+\",\\n\")\n\n\nps:ul.plist2.cf.ulList 达标这个ul 使用了多种样式 plist2  cf  ulList     \n\n# 2. minidom\n\n## 使用minidom解析器打开 XML 文档\n\n    DOMTree = xml.dom.minidom.parse(xmlPath)\n    collection = DOMTree.documentElement\n\n## 在集合中获取所有colors\n\n    colors = collection.getElementsByTagName(\"color\")\n\n    namelist = []\n    valuelist = []\n\n# 打印每部电影的详细信息\n    for color in colors:\n        if color.hasAttribute(\"name\"):\n            colorname=color.getAttribute(\"name\")\n            colorvalue = color.childNodes[0].data\n            if not (colorname in namelist):\n                namelist.append(colorname)\n                currentIndex = namelist.index(colorname) \n\n\n\n# 3. etree   \n\n    import xml.etree.ElementTree\n    tree = ElementTree.parse(lastYearPath )\n    allItems = tree.findall('data/item')\n    for pos,treeItem in enumerate(allItems):\n        holidayYear = int(treeItem.attrib['year'])\n        holidayMonth = int(treeItem.attrib['month'])\n        holidayDate = int(treeItem.attrib['date'])\n\n\n# 4. 正则  \n 对于xml里面的注释很难读取出来建议使用\n\n    import re  \n    names = re.findall(r\"<!\\[CDATA\\[(.*?)\\]\\]\",data)\n\n\n\n\n\n\n\n\n\n\n \n\n","source":"_posts/xml处理.md","raw":"title: 生成分享图片\ndate: 2018-1-3 \ncategories:\n- Python\ntags:\n- Python\n- xml\n\n---\n\n# 常用模块 \nbs4  xml.dom.minidom  xml.etree   re\n\n# 1. bs4用法    \n详细使用文档 https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html    \nhttp://www.cnblogs.com/twinsclover/archive/2012/04/26/2471704.html  \n\n    from bs4 import BeautifulSoup\n\n    soup = BeautifulSoup(content, 'xml')  \n    itemList= soup.select('html > body > div[class=\"area\"] > ul.plist2.cf.ulList > li > a')  \n    itemList2= soup.select('div[id=\"newsList\"] > ul[id=\"v2\"] > li[class=\"item\"] > a ')   \n\n判断书是否有属性的方法 tem.contents[0].attrs.has_key\n\n    for item in itemList:\n       if item.contents[0].attrs.has_key('src'):\n           avatar = item.contents[0]['src']\n       elif item.contents[0].attrs.has_key('lz_src'):\n           avatar = item.contents[0]['lz_src']\n       else:\n           avatar='unset'\n           print item\n       star = StarItem(item.text,avatar)\n       currentPageStars.append(star)  \n\n判断是否有子元素的方法 newsItemDiv.p   \n获取元素标签里面值的方法newsItemDiv.p.string\n\n    for index,newsItemDiv in enumerate(itemList):\n       tranItem = NewsItem(newsItemDiv.p.string if newsItemDiv.p else \"\",newsItemDiv.img['data-src'] if newsItemDiv.img else \"\",proto+\"/\"+domain+newsItemDiv['href'])\n       newsItems.append(str(tranItem)+\",\\n\")\n\n\nps:ul.plist2.cf.ulList 达标这个ul 使用了多种样式 plist2  cf  ulList     \n\n# 2. minidom\n\n## 使用minidom解析器打开 XML 文档\n\n    DOMTree = xml.dom.minidom.parse(xmlPath)\n    collection = DOMTree.documentElement\n\n## 在集合中获取所有colors\n\n    colors = collection.getElementsByTagName(\"color\")\n\n    namelist = []\n    valuelist = []\n\n# 打印每部电影的详细信息\n    for color in colors:\n        if color.hasAttribute(\"name\"):\n            colorname=color.getAttribute(\"name\")\n            colorvalue = color.childNodes[0].data\n            if not (colorname in namelist):\n                namelist.append(colorname)\n                currentIndex = namelist.index(colorname) \n\n\n\n# 3. etree   \n\n    import xml.etree.ElementTree\n    tree = ElementTree.parse(lastYearPath )\n    allItems = tree.findall('data/item')\n    for pos,treeItem in enumerate(allItems):\n        holidayYear = int(treeItem.attrib['year'])\n        holidayMonth = int(treeItem.attrib['month'])\n        holidayDate = int(treeItem.attrib['date'])\n\n\n# 4. 正则  \n 对于xml里面的注释很难读取出来建议使用\n\n    import re  \n    names = re.findall(r\"<!\\[CDATA\\[(.*?)\\]\\]\",data)\n\n\n\n\n\n\n\n\n\n\n \n\n","slug":"xml处理","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lci001csfjfkdvllyz6","content":"<h1 id=\"常用模块\"><a href=\"#常用模块\" class=\"headerlink\" title=\"常用模块\"></a>常用模块</h1><p>bs4  xml.dom.minidom  xml.etree   re</p>\n<h1 id=\"1-bs4用法\"><a href=\"#1-bs4用法\" class=\"headerlink\" title=\"1. bs4用法\"></a>1. bs4用法</h1><p>详细使用文档 <a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\" target=\"_blank\" rel=\"external\">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a><br><a href=\"http://www.cnblogs.com/twinsclover/archive/2012/04/26/2471704.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/twinsclover/archive/2012/04/26/2471704.html</a>  </p>\n<pre><code>from bs4 import BeautifulSoup\n\nsoup = BeautifulSoup(content, &apos;xml&apos;)  \nitemList= soup.select(&apos;html &gt; body &gt; div[class=&quot;area&quot;] &gt; ul.plist2.cf.ulList &gt; li &gt; a&apos;)  \nitemList2= soup.select(&apos;div[id=&quot;newsList&quot;] &gt; ul[id=&quot;v2&quot;] &gt; li[class=&quot;item&quot;] &gt; a &apos;)   \n</code></pre><p>判断书是否有属性的方法 tem.contents[0].attrs.has_key</p>\n<pre><code>for item in itemList:\n   if item.contents[0].attrs.has_key(&apos;src&apos;):\n       avatar = item.contents[0][&apos;src&apos;]\n   elif item.contents[0].attrs.has_key(&apos;lz_src&apos;):\n       avatar = item.contents[0][&apos;lz_src&apos;]\n   else:\n       avatar=&apos;unset&apos;\n       print item\n   star = StarItem(item.text,avatar)\n   currentPageStars.append(star)  \n</code></pre><p>判断是否有子元素的方法 newsItemDiv.p<br>获取元素标签里面值的方法newsItemDiv.p.string</p>\n<pre><code>for index,newsItemDiv in enumerate(itemList):\n   tranItem = NewsItem(newsItemDiv.p.string if newsItemDiv.p else &quot;&quot;,newsItemDiv.img[&apos;data-src&apos;] if newsItemDiv.img else &quot;&quot;,proto+&quot;/&quot;+domain+newsItemDiv[&apos;href&apos;])\n   newsItems.append(str(tranItem)+&quot;,\\n&quot;)\n</code></pre><p>ps:ul.plist2.cf.ulList 达标这个ul 使用了多种样式 plist2  cf  ulList     </p>\n<h1 id=\"2-minidom\"><a href=\"#2-minidom\" class=\"headerlink\" title=\"2. minidom\"></a>2. minidom</h1><h2 id=\"使用minidom解析器打开-XML-文档\"><a href=\"#使用minidom解析器打开-XML-文档\" class=\"headerlink\" title=\"使用minidom解析器打开 XML 文档\"></a>使用minidom解析器打开 XML 文档</h2><pre><code>DOMTree = xml.dom.minidom.parse(xmlPath)\ncollection = DOMTree.documentElement\n</code></pre><h2 id=\"在集合中获取所有colors\"><a href=\"#在集合中获取所有colors\" class=\"headerlink\" title=\"在集合中获取所有colors\"></a>在集合中获取所有colors</h2><pre><code>colors = collection.getElementsByTagName(&quot;color&quot;)\n\nnamelist = []\nvaluelist = []\n</code></pre><h1 id=\"打印每部电影的详细信息\"><a href=\"#打印每部电影的详细信息\" class=\"headerlink\" title=\"打印每部电影的详细信息\"></a>打印每部电影的详细信息</h1><pre><code>for color in colors:\n    if color.hasAttribute(&quot;name&quot;):\n        colorname=color.getAttribute(&quot;name&quot;)\n        colorvalue = color.childNodes[0].data\n        if not (colorname in namelist):\n            namelist.append(colorname)\n            currentIndex = namelist.index(colorname) \n</code></pre><h1 id=\"3-etree\"><a href=\"#3-etree\" class=\"headerlink\" title=\"3. etree\"></a>3. etree</h1><pre><code>import xml.etree.ElementTree\ntree = ElementTree.parse(lastYearPath )\nallItems = tree.findall(&apos;data/item&apos;)\nfor pos,treeItem in enumerate(allItems):\n    holidayYear = int(treeItem.attrib[&apos;year&apos;])\n    holidayMonth = int(treeItem.attrib[&apos;month&apos;])\n    holidayDate = int(treeItem.attrib[&apos;date&apos;])\n</code></pre><h1 id=\"4-正则\"><a href=\"#4-正则\" class=\"headerlink\" title=\"4. 正则\"></a>4. 正则</h1><p> 对于xml里面的注释很难读取出来建议使用</p>\n<pre><code>import re  \nnames = re.findall(r&quot;&lt;!\\[CDATA\\[(.*?)\\]\\]&quot;,data)\n</code></pre>","excerpt":"","more":"<h1 id=\"常用模块\"><a href=\"#常用模块\" class=\"headerlink\" title=\"常用模块\"></a>常用模块</h1><p>bs4  xml.dom.minidom  xml.etree   re</p>\n<h1 id=\"1-bs4用法\"><a href=\"#1-bs4用法\" class=\"headerlink\" title=\"1. bs4用法\"></a>1. bs4用法</h1><p>详细使用文档 <a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a><br><a href=\"http://www.cnblogs.com/twinsclover/archive/2012/04/26/2471704.html\">http://www.cnblogs.com/twinsclover/archive/2012/04/26/2471704.html</a>  </p>\n<pre><code>from bs4 import BeautifulSoup\n\nsoup = BeautifulSoup(content, &apos;xml&apos;)  \nitemList= soup.select(&apos;html &gt; body &gt; div[class=&quot;area&quot;] &gt; ul.plist2.cf.ulList &gt; li &gt; a&apos;)  \nitemList2= soup.select(&apos;div[id=&quot;newsList&quot;] &gt; ul[id=&quot;v2&quot;] &gt; li[class=&quot;item&quot;] &gt; a &apos;)   \n</code></pre><p>判断书是否有属性的方法 tem.contents[0].attrs.has_key</p>\n<pre><code>for item in itemList:\n   if item.contents[0].attrs.has_key(&apos;src&apos;):\n       avatar = item.contents[0][&apos;src&apos;]\n   elif item.contents[0].attrs.has_key(&apos;lz_src&apos;):\n       avatar = item.contents[0][&apos;lz_src&apos;]\n   else:\n       avatar=&apos;unset&apos;\n       print item\n   star = StarItem(item.text,avatar)\n   currentPageStars.append(star)  \n</code></pre><p>判断是否有子元素的方法 newsItemDiv.p<br>获取元素标签里面值的方法newsItemDiv.p.string</p>\n<pre><code>for index,newsItemDiv in enumerate(itemList):\n   tranItem = NewsItem(newsItemDiv.p.string if newsItemDiv.p else &quot;&quot;,newsItemDiv.img[&apos;data-src&apos;] if newsItemDiv.img else &quot;&quot;,proto+&quot;/&quot;+domain+newsItemDiv[&apos;href&apos;])\n   newsItems.append(str(tranItem)+&quot;,\\n&quot;)\n</code></pre><p>ps:ul.plist2.cf.ulList 达标这个ul 使用了多种样式 plist2  cf  ulList     </p>\n<h1 id=\"2-minidom\"><a href=\"#2-minidom\" class=\"headerlink\" title=\"2. minidom\"></a>2. minidom</h1><h2 id=\"使用minidom解析器打开-XML-文档\"><a href=\"#使用minidom解析器打开-XML-文档\" class=\"headerlink\" title=\"使用minidom解析器打开 XML 文档\"></a>使用minidom解析器打开 XML 文档</h2><pre><code>DOMTree = xml.dom.minidom.parse(xmlPath)\ncollection = DOMTree.documentElement\n</code></pre><h2 id=\"在集合中获取所有colors\"><a href=\"#在集合中获取所有colors\" class=\"headerlink\" title=\"在集合中获取所有colors\"></a>在集合中获取所有colors</h2><pre><code>colors = collection.getElementsByTagName(&quot;color&quot;)\n\nnamelist = []\nvaluelist = []\n</code></pre><h1 id=\"打印每部电影的详细信息\"><a href=\"#打印每部电影的详细信息\" class=\"headerlink\" title=\"打印每部电影的详细信息\"></a>打印每部电影的详细信息</h1><pre><code>for color in colors:\n    if color.hasAttribute(&quot;name&quot;):\n        colorname=color.getAttribute(&quot;name&quot;)\n        colorvalue = color.childNodes[0].data\n        if not (colorname in namelist):\n            namelist.append(colorname)\n            currentIndex = namelist.index(colorname) \n</code></pre><h1 id=\"3-etree\"><a href=\"#3-etree\" class=\"headerlink\" title=\"3. etree\"></a>3. etree</h1><pre><code>import xml.etree.ElementTree\ntree = ElementTree.parse(lastYearPath )\nallItems = tree.findall(&apos;data/item&apos;)\nfor pos,treeItem in enumerate(allItems):\n    holidayYear = int(treeItem.attrib[&apos;year&apos;])\n    holidayMonth = int(treeItem.attrib[&apos;month&apos;])\n    holidayDate = int(treeItem.attrib[&apos;date&apos;])\n</code></pre><h1 id=\"4-正则\"><a href=\"#4-正则\" class=\"headerlink\" title=\"4. 正则\"></a>4. 正则</h1><p> 对于xml里面的注释很难读取出来建议使用</p>\n<pre><code>import re  \nnames = re.findall(r&quot;&lt;!\\[CDATA\\[(.*?)\\]\\]&quot;,data)\n</code></pre>"},{"title":"全屏模式AdjustResize实现","date":"2017-09-14T16:00:00.000Z","_content":"\n## 方案1 \n使用stackoverflo 上的 AndroidBug5497Workaround\n\n\n但是这个AndroidBug5497Workaround有个问题就是  \nA如果是最开始输入框在下面，就会出现输入法先把界面顶上去 ，然后又调整下来的过程   \nB如果在最上面就不会出现这个过程  \n\n\n\n这个我们先考虑没有使用AndroidBug5497Workaround时候的情况  \nA如果是最开始输入框在下面，就会出现输入法会把整个界面顶上去   \nB如果在最上面，整个界面会看着基本不动，但是root view没有adjustResize的过程，因此导致原来alignparentBottom的元素看不到  \n\n\n\nAndroidBug5497Workaround的原理是监听rootView 可视区域的变化，但是这个onGlobalLayout回调的速度明显慢于键盘弹出的速度，\n所以在A情况下就会出现顶上去又弹回去的情况   \n（如果在这里纠结使监听可视区域变化速度 和 键盘弹出速度  完全 一直的话 ，那是不可能的）\n而在B情况下，由于没加AndroidBug5497Workaround这个时候本身就不会有顶去来的过程，所以主体界面本身就不会有抖动情况（注意 我们监听时候改变了主体界面的高度，但是这个根本不会影响到主体界面，因为即使改变高度， android 绘制的坐标系也是从左上角开始的，所以不存在任何问题）\n而这时候我们改变root view的size  只是会导致底部的aliparentBottom的控件上移动，上移动的速度实际上比键盘弹出的速度慢，但是最终能调整到键盘的位置，所以这里根本不会导致主题界面抖动\n\n\n    mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n              public void onGlobalLayout() {\n                  possiblyResizeChildOfContent();\n              }\n          });\n\n    private void possiblyResizeChildOfContent() {\n          int usableHeightNow = computeUsableHeight();\n          if (usableHeightNow != usableHeightPrevious) {\n              int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();\n              int heightDifference = usableHeightSansKeyboard - usableHeightNow;\n              if (heightDifference > (usableHeightSansKeyboard/4)) {\n                  // keyboard probably just became visible\n                  frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;\n              } else {\n                  // keyboard probably just became hidden\n                  frameLayoutParams.height = usableHeightSansKeyboard;\n              }\n              mChildOfContent.requestLayout();\n              usableHeightPrevious = usableHeightNow;\n          }\n      }\n\n    private int computeUsableHeight() {\n        Rect r = new Rect();\n        mChildOfContent.getWindowVisibleDisplayFrame(r);\n        return (r.bottom - r.top);\n    }\n\n\n\n#### 虚拟按键\n注意android的虚拟按键有两种：  \n一种是N5 N6一类的固定在底部的虚拟按键  \n\n一种是华为 小米mix 一类的的  可以通过手势动态控制底部虚拟按键显示还隐藏   \n这种就需要动态计算高度  \n\n为了解决A问题，需要在顶部放置一个fake EditText ，点击目标EditText时候先让顶部的fakeEditText获得焦点，待键盘完全弹出来后再把焦点转移给目标EditText   \n具体方案：目标EditText监控ontouch事件，在TouchUp时候消耗掉这个事件，这样就不会触发键盘直接弹出来了，这时候，顶部的 fake EditText先获取焦点，延迟一段时间 待键盘完全弹出后再让目标EditText获取焦点\n\n\n## 方案2：\nhttps://github.com/Jacksgong/JKeyboardPanelSwitch    \n原理：  \n在目标EditText下面加一个KPSwitchPanelLinearLayout  通过动态设置这个KPSwitchPanelLinearLayout的Visual状态和高度动态调整高度    \n其包括两个步骤  \n1、测量和调整高度  \n2、editText获取焦点事件的拦截（也是通过ontouch实现的）  \n      \n      cn.dreamtobe.kpswitch.util.KeyboardUtil#attach(android.app.Activity, cn.dreamtobe.kpswitch.IPanelHeightTarget,    cn.dreamtobe.kpswitch.util.KeyboardUtil.OnKeyboardShowingListener)  \n      \n这里实际上是加了个  \n\n    contentView.getViewTreeObserver().\n                    addOnGlobalLayoutListener(\n                            new KeyboardStatusListener(isFullScreen, isTranslucentStatus,\n                                    isFitSystemWindows,\n                                    contentView, target, listener));  \n                                    \n在onGlobalLayout里面计算出合适的高度设置给pannelView\n\n    userRootView.getWindowVisibleDisplayFrame(r);\n                displayHeight = (r.bottom - r.top);\n    ......              \n    calculateKeyboardHeight(displayHeight);\n    calculateKeyboardShowing(displayHeight);\n\n    中 calculateKeyboardHeight\n\n    panelHeightTarget.refreshHeight\n\n\n\n\n  \n这里涉及到一个问题就是初始时候不止到键盘高度怎么办(或者手动调整过键盘高度怎么办)  \n初始高度：会设置一个默认的最小高度给panel，然后待键盘完全弹出后在修复这个高度  \n\n    panelLayoutHandler.resetToRecommendPanelHeight(panelHeight)\n    >>\n    ViewUtil.refreshHeight(panelLayout, recommendPanelHeight);\n    ......\n    final int validPanelHeight = KeyboardUtil.getValidPanelHeight(view.getContext());\n    ViewGroup.LayoutParams layoutParams = view.getLayoutParams();\n    if (layoutParams == null) {\n        layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n                validPanelHeight);\n        view.setLayoutParams(layoutParams);\n    } else {\n        layoutParams.height = validPanelHeight;\n        view.requestLayout();\n    }\n\n\n\n\n\n\n","source":"_posts/全屏模式adjustadjustResize.md","raw":"title: 全屏模式AdjustResize实现\ndate: 2017-9-15\ncategories:\n- Android\ntags:\n- Android\n- 全屏模式\n- AdjustResize\n\n---\n\n## 方案1 \n使用stackoverflo 上的 AndroidBug5497Workaround\n\n\n但是这个AndroidBug5497Workaround有个问题就是  \nA如果是最开始输入框在下面，就会出现输入法先把界面顶上去 ，然后又调整下来的过程   \nB如果在最上面就不会出现这个过程  \n\n\n\n这个我们先考虑没有使用AndroidBug5497Workaround时候的情况  \nA如果是最开始输入框在下面，就会出现输入法会把整个界面顶上去   \nB如果在最上面，整个界面会看着基本不动，但是root view没有adjustResize的过程，因此导致原来alignparentBottom的元素看不到  \n\n\n\nAndroidBug5497Workaround的原理是监听rootView 可视区域的变化，但是这个onGlobalLayout回调的速度明显慢于键盘弹出的速度，\n所以在A情况下就会出现顶上去又弹回去的情况   \n（如果在这里纠结使监听可视区域变化速度 和 键盘弹出速度  完全 一直的话 ，那是不可能的）\n而在B情况下，由于没加AndroidBug5497Workaround这个时候本身就不会有顶去来的过程，所以主体界面本身就不会有抖动情况（注意 我们监听时候改变了主体界面的高度，但是这个根本不会影响到主体界面，因为即使改变高度， android 绘制的坐标系也是从左上角开始的，所以不存在任何问题）\n而这时候我们改变root view的size  只是会导致底部的aliparentBottom的控件上移动，上移动的速度实际上比键盘弹出的速度慢，但是最终能调整到键盘的位置，所以这里根本不会导致主题界面抖动\n\n\n    mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n              public void onGlobalLayout() {\n                  possiblyResizeChildOfContent();\n              }\n          });\n\n    private void possiblyResizeChildOfContent() {\n          int usableHeightNow = computeUsableHeight();\n          if (usableHeightNow != usableHeightPrevious) {\n              int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();\n              int heightDifference = usableHeightSansKeyboard - usableHeightNow;\n              if (heightDifference > (usableHeightSansKeyboard/4)) {\n                  // keyboard probably just became visible\n                  frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;\n              } else {\n                  // keyboard probably just became hidden\n                  frameLayoutParams.height = usableHeightSansKeyboard;\n              }\n              mChildOfContent.requestLayout();\n              usableHeightPrevious = usableHeightNow;\n          }\n      }\n\n    private int computeUsableHeight() {\n        Rect r = new Rect();\n        mChildOfContent.getWindowVisibleDisplayFrame(r);\n        return (r.bottom - r.top);\n    }\n\n\n\n#### 虚拟按键\n注意android的虚拟按键有两种：  \n一种是N5 N6一类的固定在底部的虚拟按键  \n\n一种是华为 小米mix 一类的的  可以通过手势动态控制底部虚拟按键显示还隐藏   \n这种就需要动态计算高度  \n\n为了解决A问题，需要在顶部放置一个fake EditText ，点击目标EditText时候先让顶部的fakeEditText获得焦点，待键盘完全弹出来后再把焦点转移给目标EditText   \n具体方案：目标EditText监控ontouch事件，在TouchUp时候消耗掉这个事件，这样就不会触发键盘直接弹出来了，这时候，顶部的 fake EditText先获取焦点，延迟一段时间 待键盘完全弹出后再让目标EditText获取焦点\n\n\n## 方案2：\nhttps://github.com/Jacksgong/JKeyboardPanelSwitch    \n原理：  \n在目标EditText下面加一个KPSwitchPanelLinearLayout  通过动态设置这个KPSwitchPanelLinearLayout的Visual状态和高度动态调整高度    \n其包括两个步骤  \n1、测量和调整高度  \n2、editText获取焦点事件的拦截（也是通过ontouch实现的）  \n      \n      cn.dreamtobe.kpswitch.util.KeyboardUtil#attach(android.app.Activity, cn.dreamtobe.kpswitch.IPanelHeightTarget,    cn.dreamtobe.kpswitch.util.KeyboardUtil.OnKeyboardShowingListener)  \n      \n这里实际上是加了个  \n\n    contentView.getViewTreeObserver().\n                    addOnGlobalLayoutListener(\n                            new KeyboardStatusListener(isFullScreen, isTranslucentStatus,\n                                    isFitSystemWindows,\n                                    contentView, target, listener));  \n                                    \n在onGlobalLayout里面计算出合适的高度设置给pannelView\n\n    userRootView.getWindowVisibleDisplayFrame(r);\n                displayHeight = (r.bottom - r.top);\n    ......              \n    calculateKeyboardHeight(displayHeight);\n    calculateKeyboardShowing(displayHeight);\n\n    中 calculateKeyboardHeight\n\n    panelHeightTarget.refreshHeight\n\n\n\n\n  \n这里涉及到一个问题就是初始时候不止到键盘高度怎么办(或者手动调整过键盘高度怎么办)  \n初始高度：会设置一个默认的最小高度给panel，然后待键盘完全弹出后在修复这个高度  \n\n    panelLayoutHandler.resetToRecommendPanelHeight(panelHeight)\n    >>\n    ViewUtil.refreshHeight(panelLayout, recommendPanelHeight);\n    ......\n    final int validPanelHeight = KeyboardUtil.getValidPanelHeight(view.getContext());\n    ViewGroup.LayoutParams layoutParams = view.getLayoutParams();\n    if (layoutParams == null) {\n        layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n                validPanelHeight);\n        view.setLayoutParams(layoutParams);\n    } else {\n        layoutParams.height = validPanelHeight;\n        view.requestLayout();\n    }\n\n\n\n\n\n\n","slug":"全屏模式adjustadjustResize","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lcl001gsfjfb12kcw6i","content":"<h2 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h2><p>使用stackoverflo 上的 AndroidBug5497Workaround</p>\n<p>但是这个AndroidBug5497Workaround有个问题就是<br>A如果是最开始输入框在下面，就会出现输入法先把界面顶上去 ，然后又调整下来的过程<br>B如果在最上面就不会出现这个过程  </p>\n<p>这个我们先考虑没有使用AndroidBug5497Workaround时候的情况<br>A如果是最开始输入框在下面，就会出现输入法会把整个界面顶上去<br>B如果在最上面，整个界面会看着基本不动，但是root view没有adjustResize的过程，因此导致原来alignparentBottom的元素看不到  </p>\n<p>AndroidBug5497Workaround的原理是监听rootView 可视区域的变化，但是这个onGlobalLayout回调的速度明显慢于键盘弹出的速度，<br>所以在A情况下就会出现顶上去又弹回去的情况<br>（如果在这里纠结使监听可视区域变化速度 和 键盘弹出速度  完全 一直的话 ，那是不可能的）<br>而在B情况下，由于没加AndroidBug5497Workaround这个时候本身就不会有顶去来的过程，所以主体界面本身就不会有抖动情况（注意 我们监听时候改变了主体界面的高度，但是这个根本不会影响到主体界面，因为即使改变高度， android 绘制的坐标系也是从左上角开始的，所以不存在任何问题）<br>而这时候我们改变root view的size  只是会导致底部的aliparentBottom的控件上移动，上移动的速度实际上比键盘弹出的速度慢，但是最终能调整到键盘的位置，所以这里根本不会导致主题界面抖动</p>\n<pre><code>mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n          public void onGlobalLayout() {\n              possiblyResizeChildOfContent();\n          }\n      });\n\nprivate void possiblyResizeChildOfContent() {\n      int usableHeightNow = computeUsableHeight();\n      if (usableHeightNow != usableHeightPrevious) {\n          int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();\n          int heightDifference = usableHeightSansKeyboard - usableHeightNow;\n          if (heightDifference &gt; (usableHeightSansKeyboard/4)) {\n              // keyboard probably just became visible\n              frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;\n          } else {\n              // keyboard probably just became hidden\n              frameLayoutParams.height = usableHeightSansKeyboard;\n          }\n          mChildOfContent.requestLayout();\n          usableHeightPrevious = usableHeightNow;\n      }\n  }\n\nprivate int computeUsableHeight() {\n    Rect r = new Rect();\n    mChildOfContent.getWindowVisibleDisplayFrame(r);\n    return (r.bottom - r.top);\n}\n</code></pre><h4 id=\"虚拟按键\"><a href=\"#虚拟按键\" class=\"headerlink\" title=\"虚拟按键\"></a>虚拟按键</h4><p>注意android的虚拟按键有两种：<br>一种是N5 N6一类的固定在底部的虚拟按键  </p>\n<p>一种是华为 小米mix 一类的的  可以通过手势动态控制底部虚拟按键显示还隐藏<br>这种就需要动态计算高度  </p>\n<p>为了解决A问题，需要在顶部放置一个fake EditText ，点击目标EditText时候先让顶部的fakeEditText获得焦点，待键盘完全弹出来后再把焦点转移给目标EditText<br>具体方案：目标EditText监控ontouch事件，在TouchUp时候消耗掉这个事件，这样就不会触发键盘直接弹出来了，这时候，顶部的 fake EditText先获取焦点，延迟一段时间 待键盘完全弹出后再让目标EditText获取焦点</p>\n<h2 id=\"方案2：\"><a href=\"#方案2：\" class=\"headerlink\" title=\"方案2：\"></a>方案2：</h2><p><a href=\"https://github.com/Jacksgong/JKeyboardPanelSwitch\" target=\"_blank\" rel=\"external\">https://github.com/Jacksgong/JKeyboardPanelSwitch</a><br>原理：<br>在目标EditText下面加一个KPSwitchPanelLinearLayout  通过动态设置这个KPSwitchPanelLinearLayout的Visual状态和高度动态调整高度<br>其包括两个步骤<br>1、测量和调整高度<br>2、editText获取焦点事件的拦截（也是通过ontouch实现的）  </p>\n<pre><code>cn.dreamtobe.kpswitch.util.KeyboardUtil#attach(android.app.Activity, cn.dreamtobe.kpswitch.IPanelHeightTarget,    cn.dreamtobe.kpswitch.util.KeyboardUtil.OnKeyboardShowingListener)  \n</code></pre><p>这里实际上是加了个  </p>\n<pre><code>contentView.getViewTreeObserver().\n                addOnGlobalLayoutListener(\n                        new KeyboardStatusListener(isFullScreen, isTranslucentStatus,\n                                isFitSystemWindows,\n                                contentView, target, listener));  \n</code></pre><p>在onGlobalLayout里面计算出合适的高度设置给pannelView</p>\n<pre><code>userRootView.getWindowVisibleDisplayFrame(r);\n            displayHeight = (r.bottom - r.top);\n......              \ncalculateKeyboardHeight(displayHeight);\ncalculateKeyboardShowing(displayHeight);\n\n中 calculateKeyboardHeight\n\npanelHeightTarget.refreshHeight\n</code></pre><p>这里涉及到一个问题就是初始时候不止到键盘高度怎么办(或者手动调整过键盘高度怎么办)<br>初始高度：会设置一个默认的最小高度给panel，然后待键盘完全弹出后在修复这个高度  </p>\n<pre><code>panelLayoutHandler.resetToRecommendPanelHeight(panelHeight)\n&gt;&gt;\nViewUtil.refreshHeight(panelLayout, recommendPanelHeight);\n......\nfinal int validPanelHeight = KeyboardUtil.getValidPanelHeight(view.getContext());\nViewGroup.LayoutParams layoutParams = view.getLayoutParams();\nif (layoutParams == null) {\n    layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n            validPanelHeight);\n    view.setLayoutParams(layoutParams);\n} else {\n    layoutParams.height = validPanelHeight;\n    view.requestLayout();\n}\n</code></pre>","excerpt":"","more":"<h2 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h2><p>使用stackoverflo 上的 AndroidBug5497Workaround</p>\n<p>但是这个AndroidBug5497Workaround有个问题就是<br>A如果是最开始输入框在下面，就会出现输入法先把界面顶上去 ，然后又调整下来的过程<br>B如果在最上面就不会出现这个过程  </p>\n<p>这个我们先考虑没有使用AndroidBug5497Workaround时候的情况<br>A如果是最开始输入框在下面，就会出现输入法会把整个界面顶上去<br>B如果在最上面，整个界面会看着基本不动，但是root view没有adjustResize的过程，因此导致原来alignparentBottom的元素看不到  </p>\n<p>AndroidBug5497Workaround的原理是监听rootView 可视区域的变化，但是这个onGlobalLayout回调的速度明显慢于键盘弹出的速度，<br>所以在A情况下就会出现顶上去又弹回去的情况<br>（如果在这里纠结使监听可视区域变化速度 和 键盘弹出速度  完全 一直的话 ，那是不可能的）<br>而在B情况下，由于没加AndroidBug5497Workaround这个时候本身就不会有顶去来的过程，所以主体界面本身就不会有抖动情况（注意 我们监听时候改变了主体界面的高度，但是这个根本不会影响到主体界面，因为即使改变高度， android 绘制的坐标系也是从左上角开始的，所以不存在任何问题）<br>而这时候我们改变root view的size  只是会导致底部的aliparentBottom的控件上移动，上移动的速度实际上比键盘弹出的速度慢，但是最终能调整到键盘的位置，所以这里根本不会导致主题界面抖动</p>\n<pre><code>mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n          public void onGlobalLayout() {\n              possiblyResizeChildOfContent();\n          }\n      });\n\nprivate void possiblyResizeChildOfContent() {\n      int usableHeightNow = computeUsableHeight();\n      if (usableHeightNow != usableHeightPrevious) {\n          int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();\n          int heightDifference = usableHeightSansKeyboard - usableHeightNow;\n          if (heightDifference &gt; (usableHeightSansKeyboard/4)) {\n              // keyboard probably just became visible\n              frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;\n          } else {\n              // keyboard probably just became hidden\n              frameLayoutParams.height = usableHeightSansKeyboard;\n          }\n          mChildOfContent.requestLayout();\n          usableHeightPrevious = usableHeightNow;\n      }\n  }\n\nprivate int computeUsableHeight() {\n    Rect r = new Rect();\n    mChildOfContent.getWindowVisibleDisplayFrame(r);\n    return (r.bottom - r.top);\n}\n</code></pre><h4 id=\"虚拟按键\"><a href=\"#虚拟按键\" class=\"headerlink\" title=\"虚拟按键\"></a>虚拟按键</h4><p>注意android的虚拟按键有两种：<br>一种是N5 N6一类的固定在底部的虚拟按键  </p>\n<p>一种是华为 小米mix 一类的的  可以通过手势动态控制底部虚拟按键显示还隐藏<br>这种就需要动态计算高度  </p>\n<p>为了解决A问题，需要在顶部放置一个fake EditText ，点击目标EditText时候先让顶部的fakeEditText获得焦点，待键盘完全弹出来后再把焦点转移给目标EditText<br>具体方案：目标EditText监控ontouch事件，在TouchUp时候消耗掉这个事件，这样就不会触发键盘直接弹出来了，这时候，顶部的 fake EditText先获取焦点，延迟一段时间 待键盘完全弹出后再让目标EditText获取焦点</p>\n<h2 id=\"方案2：\"><a href=\"#方案2：\" class=\"headerlink\" title=\"方案2：\"></a>方案2：</h2><p><a href=\"https://github.com/Jacksgong/JKeyboardPanelSwitch\">https://github.com/Jacksgong/JKeyboardPanelSwitch</a><br>原理：<br>在目标EditText下面加一个KPSwitchPanelLinearLayout  通过动态设置这个KPSwitchPanelLinearLayout的Visual状态和高度动态调整高度<br>其包括两个步骤<br>1、测量和调整高度<br>2、editText获取焦点事件的拦截（也是通过ontouch实现的）  </p>\n<pre><code>cn.dreamtobe.kpswitch.util.KeyboardUtil#attach(android.app.Activity, cn.dreamtobe.kpswitch.IPanelHeightTarget,    cn.dreamtobe.kpswitch.util.KeyboardUtil.OnKeyboardShowingListener)  \n</code></pre><p>这里实际上是加了个  </p>\n<pre><code>contentView.getViewTreeObserver().\n                addOnGlobalLayoutListener(\n                        new KeyboardStatusListener(isFullScreen, isTranslucentStatus,\n                                isFitSystemWindows,\n                                contentView, target, listener));  \n</code></pre><p>在onGlobalLayout里面计算出合适的高度设置给pannelView</p>\n<pre><code>userRootView.getWindowVisibleDisplayFrame(r);\n            displayHeight = (r.bottom - r.top);\n......              \ncalculateKeyboardHeight(displayHeight);\ncalculateKeyboardShowing(displayHeight);\n\n中 calculateKeyboardHeight\n\npanelHeightTarget.refreshHeight\n</code></pre><p>这里涉及到一个问题就是初始时候不止到键盘高度怎么办(或者手动调整过键盘高度怎么办)<br>初始高度：会设置一个默认的最小高度给panel，然后待键盘完全弹出后在修复这个高度  </p>\n<pre><code>panelLayoutHandler.resetToRecommendPanelHeight(panelHeight)\n&gt;&gt;\nViewUtil.refreshHeight(panelLayout, recommendPanelHeight);\n......\nfinal int validPanelHeight = KeyboardUtil.getValidPanelHeight(view.getContext());\nViewGroup.LayoutParams layoutParams = view.getLayoutParams();\nif (layoutParams == null) {\n    layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n            validPanelHeight);\n    view.setLayoutParams(layoutParams);\n} else {\n    layoutParams.height = validPanelHeight;\n    view.requestLayout();\n}\n</code></pre>"},{"title":"公众号爬取","date":"2018-02-25T16:00:00.000Z","_content":"\n# 目标\n获取文章的h5链接,文章的title,文章的,文章的封面   \n## Attention：  \n不要直接存储文章的内容，这样版权风险很大,\n存文章的链接的话，我们可以直接显示文章的链接出处来声明来源\n\n\n# 方案一 \n\n一个是通过 按键精灵加上proxy代理 拦截网络请求\n也可以通过charles的auto save 功能（tools/Auto save）自动保存拦截到的数据，然后通过python的watchdog 监控目录下的数据变化（可以获得一个事件），解析每次网络请求的返回值了  \n参考资料:    \nhttps://github.com/lijinma/wechat_spider  \nhttps://github.com/251321639/wechat_brain\n\n# 方案二 ：第三方的微信接口\n  \n1. 搜狗微信搜索\n2. newsrank\n3. 微小宝\n\n## 2.1 搜狗搜索  \n问题： \n1. 文章的链接是有时效性的   \nhttps://mp.weixin.qq.com/s?src=11&timestamp=1519960349&ver=729&signature=rR4FhNbqgqOhLeFrdvvRWr5cRF79uzrOuKGimM5FRK5xPMxF*28MHYaN*q9fawJIcGbdbK9qxiiOPfv7AY-dy4J6DYOg3Ub505vGoNC3uzt644CvvDiHTh7i*1Bgd0cU&new=1   \n过了12h后就打不开了  \n2. 无法确定获取的量，直接爬取分类的话量不足\n\n## 2.2 新榜  \n公众号(可遍历)的量级：22*50  \n每个公众号可返回最新发布的10条  \n而每个公众号一天更新的量一般是5条，所以总量大约是2200，满足不了要求\n\n\n## 2.3 微小宝\n其中韦小宝在公众号列表里面的22个分类，一共大约有1w个公众号，每个公众号的日更大约有5篇  \n所以一共大约有5w条记录\n\n微小宝爬虫需要注意的细节：  \n1. 要登录  \n2. 直接爬接口(接口请求时间间隔越短越容易被发现)，过一段时间就会告知是robot，这时候请求一下首页输入一下验证码\n\n3. 请求公众号的详情时候 注意加一下 refer字段，这样避免被屏蔽\n\n4. 验证码是和session 绑定的，所以请求验证码也需要添加session 和 refer，然后直接调用unlock接口。由于第一次无法获取验证码的图片，建议点击一下验证码，重新获取一下验证码（开发者模式查看具体url规则）\n\n\n# 温馨提示:  \n法律上的规定是，抓取公共展示的信息不违法，允许抓取网站内容，对公众展示内容必须提供来源及源站地址，若有版权纠纷，必须配合版权方进行内容下架，否则可以到工信部投诉举报侵权网站，投诉多了有取消域名备案的风险。   \n涉及版权的经济损失，可以提起诉讼申请经济赔偿。\n\n# 其他\n这个地方如果仅仅是爬到链接位置，有的链接不确定是否还可以访问，可以用 requests.head(url),请求一下判断resp.status_code 是不是200\n","source":"_posts/公众号爬取.md","raw":"title: 公众号爬取\ndate: 2018-2-26 \ncategories:\n- Python\ntags:\n- Python\n- 公众号爬取\n\n---\n\n# 目标\n获取文章的h5链接,文章的title,文章的,文章的封面   \n## Attention：  \n不要直接存储文章的内容，这样版权风险很大,\n存文章的链接的话，我们可以直接显示文章的链接出处来声明来源\n\n\n# 方案一 \n\n一个是通过 按键精灵加上proxy代理 拦截网络请求\n也可以通过charles的auto save 功能（tools/Auto save）自动保存拦截到的数据，然后通过python的watchdog 监控目录下的数据变化（可以获得一个事件），解析每次网络请求的返回值了  \n参考资料:    \nhttps://github.com/lijinma/wechat_spider  \nhttps://github.com/251321639/wechat_brain\n\n# 方案二 ：第三方的微信接口\n  \n1. 搜狗微信搜索\n2. newsrank\n3. 微小宝\n\n## 2.1 搜狗搜索  \n问题： \n1. 文章的链接是有时效性的   \nhttps://mp.weixin.qq.com/s?src=11&timestamp=1519960349&ver=729&signature=rR4FhNbqgqOhLeFrdvvRWr5cRF79uzrOuKGimM5FRK5xPMxF*28MHYaN*q9fawJIcGbdbK9qxiiOPfv7AY-dy4J6DYOg3Ub505vGoNC3uzt644CvvDiHTh7i*1Bgd0cU&new=1   \n过了12h后就打不开了  \n2. 无法确定获取的量，直接爬取分类的话量不足\n\n## 2.2 新榜  \n公众号(可遍历)的量级：22*50  \n每个公众号可返回最新发布的10条  \n而每个公众号一天更新的量一般是5条，所以总量大约是2200，满足不了要求\n\n\n## 2.3 微小宝\n其中韦小宝在公众号列表里面的22个分类，一共大约有1w个公众号，每个公众号的日更大约有5篇  \n所以一共大约有5w条记录\n\n微小宝爬虫需要注意的细节：  \n1. 要登录  \n2. 直接爬接口(接口请求时间间隔越短越容易被发现)，过一段时间就会告知是robot，这时候请求一下首页输入一下验证码\n\n3. 请求公众号的详情时候 注意加一下 refer字段，这样避免被屏蔽\n\n4. 验证码是和session 绑定的，所以请求验证码也需要添加session 和 refer，然后直接调用unlock接口。由于第一次无法获取验证码的图片，建议点击一下验证码，重新获取一下验证码（开发者模式查看具体url规则）\n\n\n# 温馨提示:  \n法律上的规定是，抓取公共展示的信息不违法，允许抓取网站内容，对公众展示内容必须提供来源及源站地址，若有版权纠纷，必须配合版权方进行内容下架，否则可以到工信部投诉举报侵权网站，投诉多了有取消域名备案的风险。   \n涉及版权的经济损失，可以提起诉讼申请经济赔偿。\n\n# 其他\n这个地方如果仅仅是爬到链接位置，有的链接不确定是否还可以访问，可以用 requests.head(url),请求一下判断resp.status_code 是不是200\n","slug":"公众号爬取","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lco001ksfjf8rh4eg9c","content":"<h1 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h1><p>获取文章的h5链接,文章的title,文章的,文章的封面   </p>\n<h2 id=\"Attention：\"><a href=\"#Attention：\" class=\"headerlink\" title=\"Attention：\"></a>Attention：</h2><p>不要直接存储文章的内容，这样版权风险很大,<br>存文章的链接的话，我们可以直接显示文章的链接出处来声明来源</p>\n<h1 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h1><p>一个是通过 按键精灵加上proxy代理 拦截网络请求<br>也可以通过charles的auto save 功能（tools/Auto save）自动保存拦截到的数据，然后通过python的watchdog 监控目录下的数据变化（可以获得一个事件），解析每次网络请求的返回值了<br>参考资料:<br><a href=\"https://github.com/lijinma/wechat_spider\" target=\"_blank\" rel=\"external\">https://github.com/lijinma/wechat_spider</a><br><a href=\"https://github.com/251321639/wechat_brain\" target=\"_blank\" rel=\"external\">https://github.com/251321639/wechat_brain</a></p>\n<h1 id=\"方案二-：第三方的微信接口\"><a href=\"#方案二-：第三方的微信接口\" class=\"headerlink\" title=\"方案二 ：第三方的微信接口\"></a>方案二 ：第三方的微信接口</h1><ol>\n<li>搜狗微信搜索</li>\n<li>newsrank</li>\n<li>微小宝</li>\n</ol>\n<h2 id=\"2-1-搜狗搜索\"><a href=\"#2-1-搜狗搜索\" class=\"headerlink\" title=\"2.1 搜狗搜索\"></a>2.1 搜狗搜索</h2><p>问题： </p>\n<ol>\n<li>文章的链接是有时效性的<br><a href=\"https://mp.weixin.qq.com/s?src=11&amp;timestamp=1519960349&amp;ver=729&amp;signature=rR4FhNbqgqOhLeFrdvvRWr5cRF79uzrOuKGimM5FRK5xPMxF*28MHYaN*q9fawJIcGbdbK9qxiiOPfv7AY-dy4J6DYOg3Ub505vGoNC3uzt644CvvDiHTh7i*1Bgd0cU&amp;new=1\" target=\"_blank\" rel=\"external\">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1519960349&amp;ver=729&amp;signature=rR4FhNbqgqOhLeFrdvvRWr5cRF79uzrOuKGimM5FRK5xPMxF*28MHYaN*q9fawJIcGbdbK9qxiiOPfv7AY-dy4J6DYOg3Ub505vGoNC3uzt644CvvDiHTh7i*1Bgd0cU&amp;new=1</a><br>过了12h后就打不开了  </li>\n<li>无法确定获取的量，直接爬取分类的话量不足</li>\n</ol>\n<h2 id=\"2-2-新榜\"><a href=\"#2-2-新榜\" class=\"headerlink\" title=\"2.2 新榜\"></a>2.2 新榜</h2><p>公众号(可遍历)的量级：22*50<br>每个公众号可返回最新发布的10条<br>而每个公众号一天更新的量一般是5条，所以总量大约是2200，满足不了要求</p>\n<h2 id=\"2-3-微小宝\"><a href=\"#2-3-微小宝\" class=\"headerlink\" title=\"2.3 微小宝\"></a>2.3 微小宝</h2><p>其中韦小宝在公众号列表里面的22个分类，一共大约有1w个公众号，每个公众号的日更大约有5篇<br>所以一共大约有5w条记录</p>\n<p>微小宝爬虫需要注意的细节：  </p>\n<ol>\n<li>要登录  </li>\n<li><p>直接爬接口(接口请求时间间隔越短越容易被发现)，过一段时间就会告知是robot，这时候请求一下首页输入一下验证码</p>\n</li>\n<li><p>请求公众号的详情时候 注意加一下 refer字段，这样避免被屏蔽</p>\n</li>\n<li><p>验证码是和session 绑定的，所以请求验证码也需要添加session 和 refer，然后直接调用unlock接口。由于第一次无法获取验证码的图片，建议点击一下验证码，重新获取一下验证码（开发者模式查看具体url规则）</p>\n</li>\n</ol>\n<h1 id=\"温馨提示\"><a href=\"#温馨提示\" class=\"headerlink\" title=\"温馨提示:\"></a>温馨提示:</h1><p>法律上的规定是，抓取公共展示的信息不违法，允许抓取网站内容，对公众展示内容必须提供来源及源站地址，若有版权纠纷，必须配合版权方进行内容下架，否则可以到工信部投诉举报侵权网站，投诉多了有取消域名备案的风险。<br>涉及版权的经济损失，可以提起诉讼申请经济赔偿。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>这个地方如果仅仅是爬到链接位置，有的链接不确定是否还可以访问，可以用 requests.head(url),请求一下判断resp.status_code 是不是200</p>\n","excerpt":"","more":"<h1 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h1><p>获取文章的h5链接,文章的title,文章的,文章的封面   </p>\n<h2 id=\"Attention：\"><a href=\"#Attention：\" class=\"headerlink\" title=\"Attention：\"></a>Attention：</h2><p>不要直接存储文章的内容，这样版权风险很大,<br>存文章的链接的话，我们可以直接显示文章的链接出处来声明来源</p>\n<h1 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h1><p>一个是通过 按键精灵加上proxy代理 拦截网络请求<br>也可以通过charles的auto save 功能（tools/Auto save）自动保存拦截到的数据，然后通过python的watchdog 监控目录下的数据变化（可以获得一个事件），解析每次网络请求的返回值了<br>参考资料:<br><a href=\"https://github.com/lijinma/wechat_spider\">https://github.com/lijinma/wechat_spider</a><br><a href=\"https://github.com/251321639/wechat_brain\">https://github.com/251321639/wechat_brain</a></p>\n<h1 id=\"方案二-：第三方的微信接口\"><a href=\"#方案二-：第三方的微信接口\" class=\"headerlink\" title=\"方案二 ：第三方的微信接口\"></a>方案二 ：第三方的微信接口</h1><ol>\n<li>搜狗微信搜索</li>\n<li>newsrank</li>\n<li>微小宝</li>\n</ol>\n<h2 id=\"2-1-搜狗搜索\"><a href=\"#2-1-搜狗搜索\" class=\"headerlink\" title=\"2.1 搜狗搜索\"></a>2.1 搜狗搜索</h2><p>问题： </p>\n<ol>\n<li>文章的链接是有时效性的<br><a href=\"https://mp.weixin.qq.com/s?src=11&amp;timestamp=1519960349&amp;ver=729&amp;signature=rR4FhNbqgqOhLeFrdvvRWr5cRF79uzrOuKGimM5FRK5xPMxF*28MHYaN*q9fawJIcGbdbK9qxiiOPfv7AY-dy4J6DYOg3Ub505vGoNC3uzt644CvvDiHTh7i*1Bgd0cU&amp;new=1\">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1519960349&amp;ver=729&amp;signature=rR4FhNbqgqOhLeFrdvvRWr5cRF79uzrOuKGimM5FRK5xPMxF*28MHYaN*q9fawJIcGbdbK9qxiiOPfv7AY-dy4J6DYOg3Ub505vGoNC3uzt644CvvDiHTh7i*1Bgd0cU&amp;new=1</a><br>过了12h后就打不开了  </li>\n<li>无法确定获取的量，直接爬取分类的话量不足</li>\n</ol>\n<h2 id=\"2-2-新榜\"><a href=\"#2-2-新榜\" class=\"headerlink\" title=\"2.2 新榜\"></a>2.2 新榜</h2><p>公众号(可遍历)的量级：22*50<br>每个公众号可返回最新发布的10条<br>而每个公众号一天更新的量一般是5条，所以总量大约是2200，满足不了要求</p>\n<h2 id=\"2-3-微小宝\"><a href=\"#2-3-微小宝\" class=\"headerlink\" title=\"2.3 微小宝\"></a>2.3 微小宝</h2><p>其中韦小宝在公众号列表里面的22个分类，一共大约有1w个公众号，每个公众号的日更大约有5篇<br>所以一共大约有5w条记录</p>\n<p>微小宝爬虫需要注意的细节：  </p>\n<ol>\n<li>要登录  </li>\n<li><p>直接爬接口(接口请求时间间隔越短越容易被发现)，过一段时间就会告知是robot，这时候请求一下首页输入一下验证码</p>\n</li>\n<li><p>请求公众号的详情时候 注意加一下 refer字段，这样避免被屏蔽</p>\n</li>\n<li><p>验证码是和session 绑定的，所以请求验证码也需要添加session 和 refer，然后直接调用unlock接口。由于第一次无法获取验证码的图片，建议点击一下验证码，重新获取一下验证码（开发者模式查看具体url规则）</p>\n</li>\n</ol>\n<h1 id=\"温馨提示\"><a href=\"#温馨提示\" class=\"headerlink\" title=\"温馨提示:\"></a>温馨提示:</h1><p>法律上的规定是，抓取公共展示的信息不违法，允许抓取网站内容，对公众展示内容必须提供来源及源站地址，若有版权纠纷，必须配合版权方进行内容下架，否则可以到工信部投诉举报侵权网站，投诉多了有取消域名备案的风险。<br>涉及版权的经济损失，可以提起诉讼申请经济赔偿。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>这个地方如果仅仅是爬到链接位置，有的链接不确定是否还可以访问，可以用 requests.head(url),请求一下判断resp.status_code 是不是200</p>\n"},{"title":"Android 性能检测","date":"2015-11-01T12:10:33.000Z","_content":"\n# 手机端：\n\n## 开发者选项\n1. 绘图》 显示布局边界\n\n2. 硬件加速渲染 》调试GPU过渡绘制  要打开\n\n\n3. 监控》启用严格模式\n\t \n4. GPU呈现模式分析  可以对照颜色表找出耗时出在那一部分\n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/GPU%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F.jpg?raw=true)\n \n# 电脑端：\n1. 查看MemoryMonitor  ，查看页面内存波动（对于listview ）\n\n2. tools》android》android  device  monistor\n（其实它就是把android sdk中tools下面的很多功能聚合起来；  如ddms，uiautomatorviewer，monitor等功能聚合起来，但是好像没有集成hierarchyviewer的功能）\n\n3. 查看录制页面变化时候的cpu耗时   \n  开始录制》选中进程，点击红色方框左边的按钮，然后点击红色方框里右侧的按钮录制正式开始，需要结束时，再点击右侧按钮结束，就会有结果自动生成  \n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6.png?raw=true)\n  \n  分析结果》录制实际上是一个采样的过程，可以看图中红色方框里面最耗时的几个方法，基本上可以定位到程序的问题   \n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6_2.png?raw=true)\n4. 查看布局层次，以及每一层的绘制时间，目的是减小层次  \n入口是在：tools 下面 hierarchyviewer  查看每个层次的绘制时间（这个好像必须在模拟器上看）\n\n\n# 分析卡的原因\n\n\n# 参考资料 \nhttp://www.cnblogs.com/krislight1105/p/5352500.html  \nhttp://blog.csdn.net/wangbaochu/article/details/50396512\n","source":"_posts/分析UI流畅度.md","raw":"title: Android 性能检测\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n- 性能分析\n---\n\n# 手机端：\n\n## 开发者选项\n1. 绘图》 显示布局边界\n\n2. 硬件加速渲染 》调试GPU过渡绘制  要打开\n\n\n3. 监控》启用严格模式\n\t \n4. GPU呈现模式分析  可以对照颜色表找出耗时出在那一部分\n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/GPU%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F.jpg?raw=true)\n \n# 电脑端：\n1. 查看MemoryMonitor  ，查看页面内存波动（对于listview ）\n\n2. tools》android》android  device  monistor\n（其实它就是把android sdk中tools下面的很多功能聚合起来；  如ddms，uiautomatorviewer，monitor等功能聚合起来，但是好像没有集成hierarchyviewer的功能）\n\n3. 查看录制页面变化时候的cpu耗时   \n  开始录制》选中进程，点击红色方框左边的按钮，然后点击红色方框里右侧的按钮录制正式开始，需要结束时，再点击右侧按钮结束，就会有结果自动生成  \n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6.png?raw=true)\n  \n  分析结果》录制实际上是一个采样的过程，可以看图中红色方框里面最耗时的几个方法，基本上可以定位到程序的问题   \n ![image](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6_2.png?raw=true)\n4. 查看布局层次，以及每一层的绘制时间，目的是减小层次  \n入口是在：tools 下面 hierarchyviewer  查看每个层次的绘制时间（这个好像必须在模拟器上看）\n\n\n# 分析卡的原因\n\n\n# 参考资料 \nhttp://www.cnblogs.com/krislight1105/p/5352500.html  \nhttp://blog.csdn.net/wangbaochu/article/details/50396512\n","slug":"分析UI流畅度","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lcw001nsfjfueo2pb81","content":"<h1 id=\"手机端：\"><a href=\"#手机端：\" class=\"headerlink\" title=\"手机端：\"></a>手机端：</h1><h2 id=\"开发者选项\"><a href=\"#开发者选项\" class=\"headerlink\" title=\"开发者选项\"></a>开发者选项</h2><ol>\n<li><p>绘图》 显示布局边界</p>\n</li>\n<li><p>硬件加速渲染 》调试GPU过渡绘制  要打开</p>\n</li>\n</ol>\n<ol>\n<li><p>监控》启用严格模式</p>\n</li>\n<li><p>GPU呈现模式分析  可以对照颜色表找出耗时出在那一部分<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/GPU%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F.jpg?raw=true\" alt=\"image\"></p>\n</li>\n</ol>\n<h1 id=\"电脑端：\"><a href=\"#电脑端：\" class=\"headerlink\" title=\"电脑端：\"></a>电脑端：</h1><ol>\n<li><p>查看MemoryMonitor  ，查看页面内存波动（对于listview ）</p>\n</li>\n<li><p>tools》android》android  device  monistor<br>（其实它就是把android sdk中tools下面的很多功能聚合起来；  如ddms，uiautomatorviewer，monitor等功能聚合起来，但是好像没有集成hierarchyviewer的功能）</p>\n</li>\n<li><p>查看录制页面变化时候的cpu耗时<br>开始录制》选中进程，点击红色方框左边的按钮，然后点击红色方框里右侧的按钮录制正式开始，需要结束时，再点击右侧按钮结束，就会有结果自动生成<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6.png?raw=true\" alt=\"image\"></p>\n<p>分析结果》录制实际上是一个采样的过程，可以看图中红色方框里面最耗时的几个方法，基本上可以定位到程序的问题<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6_2.png?raw=true\" alt=\"image\"></p>\n</li>\n<li>查看布局层次，以及每一层的绘制时间，目的是减小层次<br>入口是在：tools 下面 hierarchyviewer  查看每个层次的绘制时间（这个好像必须在模拟器上看）</li>\n</ol>\n<h1 id=\"分析卡的原因\"><a href=\"#分析卡的原因\" class=\"headerlink\" title=\"分析卡的原因\"></a>分析卡的原因</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://www.cnblogs.com/krislight1105/p/5352500.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/krislight1105/p/5352500.html</a><br><a href=\"http://blog.csdn.net/wangbaochu/article/details/50396512\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/wangbaochu/article/details/50396512</a></p>\n","excerpt":"","more":"<h1 id=\"手机端：\"><a href=\"#手机端：\" class=\"headerlink\" title=\"手机端：\"></a>手机端：</h1><h2 id=\"开发者选项\"><a href=\"#开发者选项\" class=\"headerlink\" title=\"开发者选项\"></a>开发者选项</h2><ol>\n<li><p>绘图》 显示布局边界</p>\n</li>\n<li><p>硬件加速渲染 》调试GPU过渡绘制  要打开</p>\n</li>\n</ol>\n<ol>\n<li><p>监控》启用严格模式</p>\n</li>\n<li><p>GPU呈现模式分析  可以对照颜色表找出耗时出在那一部分<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/GPU%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F.jpg?raw=true\" alt=\"image\"></p>\n</li>\n</ol>\n<h1 id=\"电脑端：\"><a href=\"#电脑端：\" class=\"headerlink\" title=\"电脑端：\"></a>电脑端：</h1><ol>\n<li><p>查看MemoryMonitor  ，查看页面内存波动（对于listview ）</p>\n</li>\n<li><p>tools》android》android  device  monistor<br>（其实它就是把android sdk中tools下面的很多功能聚合起来；  如ddms，uiautomatorviewer，monitor等功能聚合起来，但是好像没有集成hierarchyviewer的功能）</p>\n</li>\n<li><p>查看录制页面变化时候的cpu耗时<br>开始录制》选中进程，点击红色方框左边的按钮，然后点击红色方框里右侧的按钮录制正式开始，需要结束时，再点击右侧按钮结束，就会有结果自动生成<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6.png?raw=true\" alt=\"image\"></p>\n<p>分析结果》录制实际上是一个采样的过程，可以看图中红色方框里面最耗时的几个方法，基本上可以定位到程序的问题<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6_2.png?raw=true\" alt=\"image\"></p>\n</li>\n<li>查看布局层次，以及每一层的绘制时间，目的是减小层次<br>入口是在：tools 下面 hierarchyviewer  查看每个层次的绘制时间（这个好像必须在模拟器上看）</li>\n</ol>\n<h1 id=\"分析卡的原因\"><a href=\"#分析卡的原因\" class=\"headerlink\" title=\"分析卡的原因\"></a>分析卡的原因</h1><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://www.cnblogs.com/krislight1105/p/5352500.html\">http://www.cnblogs.com/krislight1105/p/5352500.html</a><br><a href=\"http://blog.csdn.net/wangbaochu/article/details/50396512\">http://blog.csdn.net/wangbaochu/article/details/50396512</a></p>\n"},{"title":"快速打包方案","date":"2015-11-01T12:10:33.000Z","_content":"\n\n# 往apk文件里面动态添加信息的两种方法。 \n（都需要保留安装时候的apk文件）\n\n1. 方案一：往meta_info里面添加文件,写入参数信息\n2. 方案二：在apk这个文件的comment信息里面添加需要传入的信息  \n\n\n\n## 方案一：  \n参考：http://tech.meituan.com/mt-apk-packaging.html   \n主要代表：美团  \n原理：meta_info（里面存的就是签名信息）里面的文件不参与签名，修改后，apk不需要签名 \n\n## 方案二：  \n参考：http://blog.csdn.net/kongpinde/article/details/51518466  \n主要代表：天猫、豌豆荚   \n原理：apk就是一个zip压缩包。而zip包有个comment区域，可以往里面写入信息，而不对apk的安装产生影响   \nzip 文件的末尾有一个 Central Directory Record 区域，其末尾包含一个 File comment 区域，可以存放一些数据，所以 File comment 是 zip 文件一部分，如果可以正确的修改这个部分，就可以在不破坏压缩包、不用重新打包的的前提下快速的给 Apk 文件写入自己想要的数据。\n\ncomment 是在 Central Directory Record 末尾储存的，可以将数据直接写在这里，下表是 header 末尾的结构。\n ![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment.png)\n从表中可以看到定义 comment 长度的字段位于 comment 之前。\n\n这里我们需要自定义 comment，在自定义 comment 内容的后面添加一个区域储存 comment 的长度，结构如下图。\n![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment_structure.png)\n\n### Server动态生成apk \n这一部分可以在本地或服务端进行，需要定义一个长度为 2 的 byte[] 来储存 comment 的长度，直接使用 Java 的 api 就可以把 comment 和 comment 的长度写到 Apk 的末尾，代码如下：\n\n    \tpublic static void writeApk(File file, String comment) {\n    \t\tZipFile zipFile = null;\n    \t\tByteArrayOutputStream outputStream = null;\n    \t\tRandomAccessFile accessFile = null;\n    \t\ttry {\n    \t\t\tzipFile = new ZipFile(file);\n    \t\t\tString zipComment = zipFile.getComment();\n    \t\t\t// 判断comment区域是否已经有数据了\n    \t\t\tif (zipComment != null)\n    \t\t\t\treturn;\n    \t\t\tbyte[] byteComment = comment.getBytes();\n    \t\t\toutputStream = new ByteArrayOutputStream();\n    \t\t\t// 将数据写入输出流\n    \t\t\toutputStream.write(byteComment);\n    \t\t\t// 紧接着写入数据大小\n    \t\t\toutputStream.write(short2Stream((short) byteComment.length));\n        \t\t\tbyte[] data = outputStream.toByteArray();\n    \t\t\taccessFile = new RandomAccessFile(file, \"rw\");\n    \t\t\t// 跳到comment区域\n    \t\t\taccessFile.seek(file.length() - 2);\n    \t\t\t// 先写入数据大小\n    \t\t\taccessFile.write(short2Stream((short) data.length));\n    \t\t\t// 写入数据\n    \t\t\taccessFile.write(data);\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t} finally {\n    \t\t\ttry {\n    \t\t\t\tif (zipFile != null)\n    \t\t\t\t\tzipFile.close();\n    \t\t\t\tif (outputStream != null)\n    \t\t\t\t\toutputStream.close();\n    \t\t\t\tif (accessFile != null)\n    \t\t\t\t\taccessFile.close();\n    \t\t\t} catch (Exception e) {\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t}\n    \tprivate static byte[] short2Stream(short data) {\n    \t\tByteBuffer buffer = ByteBuffer.allocate(2);\n    \t\tbuffer.order(ByteOrder.LITTLE_ENDIAN);\n    \t\tbuffer.putShort(data);\n    \t\tbuffer.flip();\n    \t\treturn buffer.array();\n    \t}\n\n\n\n### 客户端解析apk数据：\n\n\n        private static String readApk(Context context) {\n    \t\t// 获取文件路径\n    \t\tFile file = new File(context.getPackageCodePath());\n    \t\tbyte[] bytes = null;\n    \t\tRandomAccessFile accessFile = null;\n    \t\ttry {\n    \t\t\taccessFile = new RandomAccessFile(file, \"r\");\n    \t\t\tlong index = accessFile.length();\n    \t\t\tbytes = new byte[2];\n    \t\t\t// 获取comment文件的位置\n    \t\t\tindex = index - bytes.length;\n    \t\t\taccessFile.seek(index);\n    \t\t\t// 获取comment中写入数据的大小byte类型\n    \t\t\taccessFile.readFully(bytes);\n    \t\t\t// 将byte转换成大小\n    \t\t\tint contentLength = stream2Short(bytes, 0);\n    \t\t\t// 创建byte[]数据大小来存储写入的数据\n    \t\t\tbytes = new byte[contentLength];\n    \t\t\tindex = index - bytes.length;\n    \t\t\taccessFile.seek(index);\n    \t\t\t// 读取数据\n    \t\t\taccessFile.readFully(bytes);\n    \t\t\treturn new String(bytes, \"utf-8\");\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t} finally {\n    \t\t\tif (accessFile != null) {\n    \t\t\t\ttry {\n    \t\t\t\t\taccessFile.close();\n    \t\t\t\t} catch (IOException e) {\n    \t\t\t\t\te.printStackTrace();\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn null;\n    \t}\n    \n\n    \tprivate static short stream2Short(byte[] stream, int offset) {\n    \t\tByteBuffer buffer = ByteBuffer.allocate(2);\n    \t\tbuffer.order(ByteOrder.LITTLE_ENDIAN);\n    \t\tbuffer.put(stream[offset]);\n    \t\tbuffer.put(stream[offset + 1]);\n    \t\treturn buffer.getShort(0);\n    \t}\n\n# apk的安装过程\n1. 复制APK安装包到data/app目录下（所以安装完成后，即使把sd卡中的apk删除也没关系）;\n2. 解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录;\n3. 并data/data目录下创建对应的应用数据目录。\n\n\n## 应用安装涉及到如下几个目录：        \n\nsystem/app ---------------系统自带的应用程序，获得adb root权限才能删除\n\ndata/app  ---------------用户程序安装的目录。安装时把                                                                                                      apk文件复制到此目录\ndata/data ---------------存放应用程序的数据\ndata/dalvik-cache--------将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)\n\n\n\n## app卸载\n\n删除安装过程中在上述三个目录下创建的文件及目录。\n\n\n\n","source":"_posts/动态往apk写入信息.md","raw":"title: 快速打包方案\ndate: 2015-11-01 20:10:33\ncategories:\n- Android快速打包\ntags:\n- 打包\n- Android\n---\n\n\n# 往apk文件里面动态添加信息的两种方法。 \n（都需要保留安装时候的apk文件）\n\n1. 方案一：往meta_info里面添加文件,写入参数信息\n2. 方案二：在apk这个文件的comment信息里面添加需要传入的信息  \n\n\n\n## 方案一：  \n参考：http://tech.meituan.com/mt-apk-packaging.html   \n主要代表：美团  \n原理：meta_info（里面存的就是签名信息）里面的文件不参与签名，修改后，apk不需要签名 \n\n## 方案二：  \n参考：http://blog.csdn.net/kongpinde/article/details/51518466  \n主要代表：天猫、豌豆荚   \n原理：apk就是一个zip压缩包。而zip包有个comment区域，可以往里面写入信息，而不对apk的安装产生影响   \nzip 文件的末尾有一个 Central Directory Record 区域，其末尾包含一个 File comment 区域，可以存放一些数据，所以 File comment 是 zip 文件一部分，如果可以正确的修改这个部分，就可以在不破坏压缩包、不用重新打包的的前提下快速的给 Apk 文件写入自己想要的数据。\n\ncomment 是在 Central Directory Record 末尾储存的，可以将数据直接写在这里，下表是 header 末尾的结构。\n ![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment.png)\n从表中可以看到定义 comment 长度的字段位于 comment 之前。\n\n这里我们需要自定义 comment，在自定义 comment 内容的后面添加一个区域储存 comment 的长度，结构如下图。\n![image](https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment_structure.png)\n\n### Server动态生成apk \n这一部分可以在本地或服务端进行，需要定义一个长度为 2 的 byte[] 来储存 comment 的长度，直接使用 Java 的 api 就可以把 comment 和 comment 的长度写到 Apk 的末尾，代码如下：\n\n    \tpublic static void writeApk(File file, String comment) {\n    \t\tZipFile zipFile = null;\n    \t\tByteArrayOutputStream outputStream = null;\n    \t\tRandomAccessFile accessFile = null;\n    \t\ttry {\n    \t\t\tzipFile = new ZipFile(file);\n    \t\t\tString zipComment = zipFile.getComment();\n    \t\t\t// 判断comment区域是否已经有数据了\n    \t\t\tif (zipComment != null)\n    \t\t\t\treturn;\n    \t\t\tbyte[] byteComment = comment.getBytes();\n    \t\t\toutputStream = new ByteArrayOutputStream();\n    \t\t\t// 将数据写入输出流\n    \t\t\toutputStream.write(byteComment);\n    \t\t\t// 紧接着写入数据大小\n    \t\t\toutputStream.write(short2Stream((short) byteComment.length));\n        \t\t\tbyte[] data = outputStream.toByteArray();\n    \t\t\taccessFile = new RandomAccessFile(file, \"rw\");\n    \t\t\t// 跳到comment区域\n    \t\t\taccessFile.seek(file.length() - 2);\n    \t\t\t// 先写入数据大小\n    \t\t\taccessFile.write(short2Stream((short) data.length));\n    \t\t\t// 写入数据\n    \t\t\taccessFile.write(data);\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t} finally {\n    \t\t\ttry {\n    \t\t\t\tif (zipFile != null)\n    \t\t\t\t\tzipFile.close();\n    \t\t\t\tif (outputStream != null)\n    \t\t\t\t\toutputStream.close();\n    \t\t\t\tif (accessFile != null)\n    \t\t\t\t\taccessFile.close();\n    \t\t\t} catch (Exception e) {\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t}\n    \tprivate static byte[] short2Stream(short data) {\n    \t\tByteBuffer buffer = ByteBuffer.allocate(2);\n    \t\tbuffer.order(ByteOrder.LITTLE_ENDIAN);\n    \t\tbuffer.putShort(data);\n    \t\tbuffer.flip();\n    \t\treturn buffer.array();\n    \t}\n\n\n\n### 客户端解析apk数据：\n\n\n        private static String readApk(Context context) {\n    \t\t// 获取文件路径\n    \t\tFile file = new File(context.getPackageCodePath());\n    \t\tbyte[] bytes = null;\n    \t\tRandomAccessFile accessFile = null;\n    \t\ttry {\n    \t\t\taccessFile = new RandomAccessFile(file, \"r\");\n    \t\t\tlong index = accessFile.length();\n    \t\t\tbytes = new byte[2];\n    \t\t\t// 获取comment文件的位置\n    \t\t\tindex = index - bytes.length;\n    \t\t\taccessFile.seek(index);\n    \t\t\t// 获取comment中写入数据的大小byte类型\n    \t\t\taccessFile.readFully(bytes);\n    \t\t\t// 将byte转换成大小\n    \t\t\tint contentLength = stream2Short(bytes, 0);\n    \t\t\t// 创建byte[]数据大小来存储写入的数据\n    \t\t\tbytes = new byte[contentLength];\n    \t\t\tindex = index - bytes.length;\n    \t\t\taccessFile.seek(index);\n    \t\t\t// 读取数据\n    \t\t\taccessFile.readFully(bytes);\n    \t\t\treturn new String(bytes, \"utf-8\");\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t} finally {\n    \t\t\tif (accessFile != null) {\n    \t\t\t\ttry {\n    \t\t\t\t\taccessFile.close();\n    \t\t\t\t} catch (IOException e) {\n    \t\t\t\t\te.printStackTrace();\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\treturn null;\n    \t}\n    \n\n    \tprivate static short stream2Short(byte[] stream, int offset) {\n    \t\tByteBuffer buffer = ByteBuffer.allocate(2);\n    \t\tbuffer.order(ByteOrder.LITTLE_ENDIAN);\n    \t\tbuffer.put(stream[offset]);\n    \t\tbuffer.put(stream[offset + 1]);\n    \t\treturn buffer.getShort(0);\n    \t}\n\n# apk的安装过程\n1. 复制APK安装包到data/app目录下（所以安装完成后，即使把sd卡中的apk删除也没关系）;\n2. 解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录;\n3. 并data/data目录下创建对应的应用数据目录。\n\n\n## 应用安装涉及到如下几个目录：        \n\nsystem/app ---------------系统自带的应用程序，获得adb root权限才能删除\n\ndata/app  ---------------用户程序安装的目录。安装时把                                                                                                      apk文件复制到此目录\ndata/data ---------------存放应用程序的数据\ndata/dalvik-cache--------将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)\n\n\n\n## app卸载\n\n删除安装过程中在上述三个目录下创建的文件及目录。\n\n\n\n","slug":"动态往apk写入信息","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06ld2001rsfjfixdjcdfc","content":"<h1 id=\"往apk文件里面动态添加信息的两种方法。\"><a href=\"#往apk文件里面动态添加信息的两种方法。\" class=\"headerlink\" title=\"往apk文件里面动态添加信息的两种方法。\"></a>往apk文件里面动态添加信息的两种方法。</h1><p>（都需要保留安装时候的apk文件）</p>\n<ol>\n<li>方案一：往meta_info里面添加文件,写入参数信息</li>\n<li>方案二：在apk这个文件的comment信息里面添加需要传入的信息  </li>\n</ol>\n<h2 id=\"方案一：\"><a href=\"#方案一：\" class=\"headerlink\" title=\"方案一：\"></a>方案一：</h2><p>参考：<a href=\"http://tech.meituan.com/mt-apk-packaging.html\" target=\"_blank\" rel=\"external\">http://tech.meituan.com/mt-apk-packaging.html</a><br>主要代表：美团<br>原理：meta_info（里面存的就是签名信息）里面的文件不参与签名，修改后，apk不需要签名 </p>\n<h2 id=\"方案二：\"><a href=\"#方案二：\" class=\"headerlink\" title=\"方案二：\"></a>方案二：</h2><p>参考：<a href=\"http://blog.csdn.net/kongpinde/article/details/51518466\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/kongpinde/article/details/51518466</a><br>主要代表：天猫、豌豆荚<br>原理：apk就是一个zip压缩包。而zip包有个comment区域，可以往里面写入信息，而不对apk的安装产生影响<br>zip 文件的末尾有一个 Central Directory Record 区域，其末尾包含一个 File comment 区域，可以存放一些数据，所以 File comment 是 zip 文件一部分，如果可以正确的修改这个部分，就可以在不破坏压缩包、不用重新打包的的前提下快速的给 Apk 文件写入自己想要的数据。</p>\n<p>comment 是在 Central Directory Record 末尾储存的，可以将数据直接写在这里，下表是 header 末尾的结构。<br> <img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment.png\" alt=\"image\"><br>从表中可以看到定义 comment 长度的字段位于 comment 之前。</p>\n<p>这里我们需要自定义 comment，在自定义 comment 内容的后面添加一个区域储存 comment 的长度，结构如下图。<br><img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment_structure.png\" alt=\"image\"></p>\n<h3 id=\"Server动态生成apk\"><a href=\"#Server动态生成apk\" class=\"headerlink\" title=\"Server动态生成apk\"></a>Server动态生成apk</h3><p>这一部分可以在本地或服务端进行，需要定义一个长度为 2 的 byte[] 来储存 comment 的长度，直接使用 Java 的 api 就可以把 comment 和 comment 的长度写到 Apk 的末尾，代码如下：</p>\n<pre><code>public static void writeApk(File file, String comment) {\n    ZipFile zipFile = null;\n    ByteArrayOutputStream outputStream = null;\n    RandomAccessFile accessFile = null;\n    try {\n        zipFile = new ZipFile(file);\n        String zipComment = zipFile.getComment();\n        // 判断comment区域是否已经有数据了\n        if (zipComment != null)\n            return;\n        byte[] byteComment = comment.getBytes();\n        outputStream = new ByteArrayOutputStream();\n        // 将数据写入输出流\n        outputStream.write(byteComment);\n        // 紧接着写入数据大小\n        outputStream.write(short2Stream((short) byteComment.length));\n            byte[] data = outputStream.toByteArray();\n        accessFile = new RandomAccessFile(file, &quot;rw&quot;);\n        // 跳到comment区域\n        accessFile.seek(file.length() - 2);\n        // 先写入数据大小\n        accessFile.write(short2Stream((short) data.length));\n        // 写入数据\n        accessFile.write(data);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if (zipFile != null)\n                zipFile.close();\n            if (outputStream != null)\n                outputStream.close();\n            if (accessFile != null)\n                accessFile.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\nprivate static byte[] short2Stream(short data) {\n    ByteBuffer buffer = ByteBuffer.allocate(2);\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n    buffer.putShort(data);\n    buffer.flip();\n    return buffer.array();\n}\n</code></pre><h3 id=\"客户端解析apk数据：\"><a href=\"#客户端解析apk数据：\" class=\"headerlink\" title=\"客户端解析apk数据：\"></a>客户端解析apk数据：</h3><pre><code>private static String readApk(Context context) {\n    // 获取文件路径\n    File file = new File(context.getPackageCodePath());\n    byte[] bytes = null;\n    RandomAccessFile accessFile = null;\n    try {\n        accessFile = new RandomAccessFile(file, &quot;r&quot;);\n        long index = accessFile.length();\n        bytes = new byte[2];\n        // 获取comment文件的位置\n        index = index - bytes.length;\n        accessFile.seek(index);\n        // 获取comment中写入数据的大小byte类型\n        accessFile.readFully(bytes);\n        // 将byte转换成大小\n        int contentLength = stream2Short(bytes, 0);\n        // 创建byte[]数据大小来存储写入的数据\n        bytes = new byte[contentLength];\n        index = index - bytes.length;\n        accessFile.seek(index);\n        // 读取数据\n        accessFile.readFully(bytes);\n        return new String(bytes, &quot;utf-8&quot;);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (accessFile != null) {\n            try {\n                accessFile.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}\n\n\nprivate static short stream2Short(byte[] stream, int offset) {\n    ByteBuffer buffer = ByteBuffer.allocate(2);\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n    buffer.put(stream[offset]);\n    buffer.put(stream[offset + 1]);\n    return buffer.getShort(0);\n}\n</code></pre><h1 id=\"apk的安装过程\"><a href=\"#apk的安装过程\" class=\"headerlink\" title=\"apk的安装过程\"></a>apk的安装过程</h1><ol>\n<li>复制APK安装包到data/app目录下（所以安装完成后，即使把sd卡中的apk删除也没关系）;</li>\n<li>解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录;</li>\n<li>并data/data目录下创建对应的应用数据目录。</li>\n</ol>\n<h2 id=\"应用安装涉及到如下几个目录：\"><a href=\"#应用安装涉及到如下几个目录：\" class=\"headerlink\" title=\"应用安装涉及到如下几个目录：\"></a>应用安装涉及到如下几个目录：</h2><p>system/app —————系统自带的应用程序，获得adb root权限才能删除</p>\n<p>data/app  —————用户程序安装的目录。安装时把                                                                                                      apk文件复制到此目录<br>data/data —————存放应用程序的数据<br>data/dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)</p>\n<h2 id=\"app卸载\"><a href=\"#app卸载\" class=\"headerlink\" title=\"app卸载\"></a>app卸载</h2><p>删除安装过程中在上述三个目录下创建的文件及目录。</p>\n","excerpt":"","more":"<h1 id=\"往apk文件里面动态添加信息的两种方法。\"><a href=\"#往apk文件里面动态添加信息的两种方法。\" class=\"headerlink\" title=\"往apk文件里面动态添加信息的两种方法。\"></a>往apk文件里面动态添加信息的两种方法。</h1><p>（都需要保留安装时候的apk文件）</p>\n<ol>\n<li>方案一：往meta_info里面添加文件,写入参数信息</li>\n<li>方案二：在apk这个文件的comment信息里面添加需要传入的信息  </li>\n</ol>\n<h2 id=\"方案一：\"><a href=\"#方案一：\" class=\"headerlink\" title=\"方案一：\"></a>方案一：</h2><p>参考：<a href=\"http://tech.meituan.com/mt-apk-packaging.html\">http://tech.meituan.com/mt-apk-packaging.html</a><br>主要代表：美团<br>原理：meta_info（里面存的就是签名信息）里面的文件不参与签名，修改后，apk不需要签名 </p>\n<h2 id=\"方案二：\"><a href=\"#方案二：\" class=\"headerlink\" title=\"方案二：\"></a>方案二：</h2><p>参考：<a href=\"http://blog.csdn.net/kongpinde/article/details/51518466\">http://blog.csdn.net/kongpinde/article/details/51518466</a><br>主要代表：天猫、豌豆荚<br>原理：apk就是一个zip压缩包。而zip包有个comment区域，可以往里面写入信息，而不对apk的安装产生影响<br>zip 文件的末尾有一个 Central Directory Record 区域，其末尾包含一个 File comment 区域，可以存放一些数据，所以 File comment 是 zip 文件一部分，如果可以正确的修改这个部分，就可以在不破坏压缩包、不用重新打包的的前提下快速的给 Apk 文件写入自己想要的数据。</p>\n<p>comment 是在 Central Directory Record 末尾储存的，可以将数据直接写在这里，下表是 header 末尾的结构。<br> <img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment.png\" alt=\"image\"><br>从表中可以看到定义 comment 长度的字段位于 comment 之前。</p>\n<p>这里我们需要自定义 comment，在自定义 comment 内容的后面添加一个区域储存 comment 的长度，结构如下图。<br><img src=\"https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment_structure.png\" alt=\"image\"></p>\n<h3 id=\"Server动态生成apk\"><a href=\"#Server动态生成apk\" class=\"headerlink\" title=\"Server动态生成apk\"></a>Server动态生成apk</h3><p>这一部分可以在本地或服务端进行，需要定义一个长度为 2 的 byte[] 来储存 comment 的长度，直接使用 Java 的 api 就可以把 comment 和 comment 的长度写到 Apk 的末尾，代码如下：</p>\n<pre><code>public static void writeApk(File file, String comment) {\n    ZipFile zipFile = null;\n    ByteArrayOutputStream outputStream = null;\n    RandomAccessFile accessFile = null;\n    try {\n        zipFile = new ZipFile(file);\n        String zipComment = zipFile.getComment();\n        // 判断comment区域是否已经有数据了\n        if (zipComment != null)\n            return;\n        byte[] byteComment = comment.getBytes();\n        outputStream = new ByteArrayOutputStream();\n        // 将数据写入输出流\n        outputStream.write(byteComment);\n        // 紧接着写入数据大小\n        outputStream.write(short2Stream((short) byteComment.length));\n            byte[] data = outputStream.toByteArray();\n        accessFile = new RandomAccessFile(file, &quot;rw&quot;);\n        // 跳到comment区域\n        accessFile.seek(file.length() - 2);\n        // 先写入数据大小\n        accessFile.write(short2Stream((short) data.length));\n        // 写入数据\n        accessFile.write(data);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if (zipFile != null)\n                zipFile.close();\n            if (outputStream != null)\n                outputStream.close();\n            if (accessFile != null)\n                accessFile.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\nprivate static byte[] short2Stream(short data) {\n    ByteBuffer buffer = ByteBuffer.allocate(2);\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n    buffer.putShort(data);\n    buffer.flip();\n    return buffer.array();\n}\n</code></pre><h3 id=\"客户端解析apk数据：\"><a href=\"#客户端解析apk数据：\" class=\"headerlink\" title=\"客户端解析apk数据：\"></a>客户端解析apk数据：</h3><pre><code>private static String readApk(Context context) {\n    // 获取文件路径\n    File file = new File(context.getPackageCodePath());\n    byte[] bytes = null;\n    RandomAccessFile accessFile = null;\n    try {\n        accessFile = new RandomAccessFile(file, &quot;r&quot;);\n        long index = accessFile.length();\n        bytes = new byte[2];\n        // 获取comment文件的位置\n        index = index - bytes.length;\n        accessFile.seek(index);\n        // 获取comment中写入数据的大小byte类型\n        accessFile.readFully(bytes);\n        // 将byte转换成大小\n        int contentLength = stream2Short(bytes, 0);\n        // 创建byte[]数据大小来存储写入的数据\n        bytes = new byte[contentLength];\n        index = index - bytes.length;\n        accessFile.seek(index);\n        // 读取数据\n        accessFile.readFully(bytes);\n        return new String(bytes, &quot;utf-8&quot;);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (accessFile != null) {\n            try {\n                accessFile.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}\n\n\nprivate static short stream2Short(byte[] stream, int offset) {\n    ByteBuffer buffer = ByteBuffer.allocate(2);\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n    buffer.put(stream[offset]);\n    buffer.put(stream[offset + 1]);\n    return buffer.getShort(0);\n}\n</code></pre><h1 id=\"apk的安装过程\"><a href=\"#apk的安装过程\" class=\"headerlink\" title=\"apk的安装过程\"></a>apk的安装过程</h1><ol>\n<li>复制APK安装包到data/app目录下（所以安装完成后，即使把sd卡中的apk删除也没关系）;</li>\n<li>解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录;</li>\n<li>并data/data目录下创建对应的应用数据目录。</li>\n</ol>\n<h2 id=\"应用安装涉及到如下几个目录：\"><a href=\"#应用安装涉及到如下几个目录：\" class=\"headerlink\" title=\"应用安装涉及到如下几个目录：\"></a>应用安装涉及到如下几个目录：</h2><p>system/app —————系统自带的应用程序，获得adb root权限才能删除</p>\n<p>data/app  —————用户程序安装的目录。安装时把                                                                                                      apk文件复制到此目录<br>data/data —————存放应用程序的数据<br>data/dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)</p>\n<h2 id=\"app卸载\"><a href=\"#app卸载\" class=\"headerlink\" title=\"app卸载\"></a>app卸载</h2><p>删除安装过程中在上述三个目录下创建的文件及目录。</p>\n"},{"title":"图片跟随主题色变化","date":"2018-02-15T16:00:00.000Z","_content":"\n# Icon图标\n1. 部分是网络图标\n2. 通过已有的图片处理成变色图片，方案就是作图的时候控制显示内容的透明度，   \n\n第一步：\n\n      Bitmap mColorBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n      Canvas mCanvas = new Canvas(mColorBitmap);\n      Paint mPaint = new Paint();\n      mPaint.setColor(mColor);  \n      \n第二步：\n    \n     //从原位图中提取只包含alpha的位图\n     Bitmap alphaBitmap = mBitmap.extractAlpha();\n     //在画布上通过透明度的部分控制显示颜色\n     mCanvas.drawBitmap(alphaBitmap, 0, 0, mPaint);\n    \n3. 使用把图片做成字体  \n其实这和第二种的原理是相同的,只不过是UI和Android系统帮我们做了 \n\n\n# 背景\n\n# 字体颜色\n\n\n关于图片所占内存的大小  http://dev.qq.com/topic/591d61f56793d26660901b4e\n\n\n#ImageBitmap 和倍率的关系\n\n如果不设置Density  直接把一个bitmap 设置到ImageVIew上去 就是默认density。\n但是可能图片都是三倍图，这时候如果设置到2倍分辩率的手机上就会出现缩小的情况，这时候就要设置图片的density。\nbitmap.setDensity(480);\n然后再设置到imageView上去\n\n关于图片的缩放系数：http://jayfeng.com/2016/03/22/Android-Bitmap%E9%9D%A2%E9%9D%A2%E8%A7%82/\n\n\n","source":"_posts/图标跟随主题色方案.md","raw":"title: 图片跟随主题色变化\ndate: 2018-2-16\ncategories:\n- Android\ntags:\n- Android\n- 主题色\n\n---\n\n# Icon图标\n1. 部分是网络图标\n2. 通过已有的图片处理成变色图片，方案就是作图的时候控制显示内容的透明度，   \n\n第一步：\n\n      Bitmap mColorBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n      Canvas mCanvas = new Canvas(mColorBitmap);\n      Paint mPaint = new Paint();\n      mPaint.setColor(mColor);  \n      \n第二步：\n    \n     //从原位图中提取只包含alpha的位图\n     Bitmap alphaBitmap = mBitmap.extractAlpha();\n     //在画布上通过透明度的部分控制显示颜色\n     mCanvas.drawBitmap(alphaBitmap, 0, 0, mPaint);\n    \n3. 使用把图片做成字体  \n其实这和第二种的原理是相同的,只不过是UI和Android系统帮我们做了 \n\n\n# 背景\n\n# 字体颜色\n\n\n关于图片所占内存的大小  http://dev.qq.com/topic/591d61f56793d26660901b4e\n\n\n#ImageBitmap 和倍率的关系\n\n如果不设置Density  直接把一个bitmap 设置到ImageVIew上去 就是默认density。\n但是可能图片都是三倍图，这时候如果设置到2倍分辩率的手机上就会出现缩小的情况，这时候就要设置图片的density。\nbitmap.setDensity(480);\n然后再设置到imageView上去\n\n关于图片的缩放系数：http://jayfeng.com/2016/03/22/Android-Bitmap%E9%9D%A2%E9%9D%A2%E8%A7%82/\n\n\n","slug":"图标跟随主题色方案","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06ld5001tsfjfl7v8es7z","content":"<h1 id=\"Icon图标\"><a href=\"#Icon图标\" class=\"headerlink\" title=\"Icon图标\"></a>Icon图标</h1><ol>\n<li>部分是网络图标</li>\n<li>通过已有的图片处理成变色图片，方案就是作图的时候控制显示内容的透明度，   </li>\n</ol>\n<p>第一步：</p>\n<pre><code>Bitmap mColorBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\nCanvas mCanvas = new Canvas(mColorBitmap);\nPaint mPaint = new Paint();\nmPaint.setColor(mColor);  \n</code></pre><p>第二步：</p>\n<pre><code>//从原位图中提取只包含alpha的位图\nBitmap alphaBitmap = mBitmap.extractAlpha();\n//在画布上通过透明度的部分控制显示颜色\nmCanvas.drawBitmap(alphaBitmap, 0, 0, mPaint);\n</code></pre><ol>\n<li>使用把图片做成字体<br>其实这和第二种的原理是相同的,只不过是UI和Android系统帮我们做了 </li>\n</ol>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><h1 id=\"字体颜色\"><a href=\"#字体颜色\" class=\"headerlink\" title=\"字体颜色\"></a>字体颜色</h1><p>关于图片所占内存的大小  <a href=\"http://dev.qq.com/topic/591d61f56793d26660901b4e\" target=\"_blank\" rel=\"external\">http://dev.qq.com/topic/591d61f56793d26660901b4e</a></p>\n<p>#ImageBitmap 和倍率的关系</p>\n<p>如果不设置Density  直接把一个bitmap 设置到ImageVIew上去 就是默认density。<br>但是可能图片都是三倍图，这时候如果设置到2倍分辩率的手机上就会出现缩小的情况，这时候就要设置图片的density。<br>bitmap.setDensity(480);<br>然后再设置到imageView上去</p>\n<p>关于图片的缩放系数：<a href=\"http://jayfeng.com/2016/03/22/Android-Bitmap%E9%9D%A2%E9%9D%A2%E8%A7%82/\" target=\"_blank\" rel=\"external\">http://jayfeng.com/2016/03/22/Android-Bitmap%E9%9D%A2%E9%9D%A2%E8%A7%82/</a></p>\n","excerpt":"","more":"<h1 id=\"Icon图标\"><a href=\"#Icon图标\" class=\"headerlink\" title=\"Icon图标\"></a>Icon图标</h1><ol>\n<li>部分是网络图标</li>\n<li>通过已有的图片处理成变色图片，方案就是作图的时候控制显示内容的透明度，   </li>\n</ol>\n<p>第一步：</p>\n<pre><code>Bitmap mColorBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\nCanvas mCanvas = new Canvas(mColorBitmap);\nPaint mPaint = new Paint();\nmPaint.setColor(mColor);  \n</code></pre><p>第二步：</p>\n<pre><code>//从原位图中提取只包含alpha的位图\nBitmap alphaBitmap = mBitmap.extractAlpha();\n//在画布上通过透明度的部分控制显示颜色\nmCanvas.drawBitmap(alphaBitmap, 0, 0, mPaint);\n</code></pre><ol>\n<li>使用把图片做成字体<br>其实这和第二种的原理是相同的,只不过是UI和Android系统帮我们做了 </li>\n</ol>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><h1 id=\"字体颜色\"><a href=\"#字体颜色\" class=\"headerlink\" title=\"字体颜色\"></a>字体颜色</h1><p>关于图片所占内存的大小  <a href=\"http://dev.qq.com/topic/591d61f56793d26660901b4e\">http://dev.qq.com/topic/591d61f56793d26660901b4e</a></p>\n<p>#ImageBitmap 和倍率的关系</p>\n<p>如果不设置Density  直接把一个bitmap 设置到ImageVIew上去 就是默认density。<br>但是可能图片都是三倍图，这时候如果设置到2倍分辩率的手机上就会出现缩小的情况，这时候就要设置图片的density。<br>bitmap.setDensity(480);<br>然后再设置到imageView上去</p>\n<p>关于图片的缩放系数：<a href=\"http://jayfeng.com/2016/03/22/Android-Bitmap%E9%9D%A2%E9%9D%A2%E8%A7%82/\">http://jayfeng.com/2016/03/22/Android-Bitmap%E9%9D%A2%E9%9D%A2%E8%A7%82/</a></p>\n"},{"title":"又拍云图片显示优化","date":"2018-02-09T16:00:00.000Z","_content":"\n ## 1. 又拍云的图片尺寸问题\n \n又拍云会对我们上传的图片进行处理。然后会生成多种尺寸：110,160,210,240,320,480,640,720,1200。\n每种尺寸对应于不同的url。\neg：\nhttp://img2048.static.suishenyun.net/d62bb1e1bf1e2c6b8fb0dd004a952a01/4414fc28822e3643ff90a7e68305e12a.jpg!w480.jpg\n\n## 2. 简单的解决方案\n\n为了利用又拍云自动帮我们处理出来的不同尺寸图片。在每次加载图片的时候根据当前显示View的尺寸加载合适的尺寸\n\n\n### 2.1 这里有三个没解决的问题： \n\n1. 不同尺寸的图片会在sd卡上存不同cache，比如由于我们先加载了640尺寸的图片，后面加载480尺寸还是无法公用640尺寸的图片cache,导致还得重新请求一次网络。实际上我们可以通过处理得到480尺寸的图片。\n\n2. 对于发带图片帖子的这种逻辑处理逻辑处理不方便。因为上传图片后，很有可能不知道图片的显示尺寸。无法把这张本地图片放置到对应位置的cache上去（虽然我们现在上传上去后，会直接显示的是本地图片，但这个有点治标不治本。第二次进来时候或者下拉刷新后 还是会从网上load这张图片）。\n\n3. 图片尺寸的获取，不是所有的ImageView在setImageUrl时候都可以获取尺寸，有的量不到尺寸，也就是在一个还没有渲染 并且也没有设置固定size的ImageVIew上设置Url（比Adapter里面的初次createView  然后立即设置Url就会出现量不到尺寸的问题）\n\n总结一些：又拍云会帮我们处理出来不同尺寸的图片。在小的地方我们可以仅仅加载小尺寸的图片，提高了展示速度。但是对于同一张图片，在不同地方展示不同尺寸的逻辑处理不够完美。所以以前在wecal里面会发现一个问题：同一个头像，已经展示过了，在下一个页面里用另个尺寸展示的时候还是会有点慢。 \n\n## 3. 对于又拍云的图片完美解决方案\n\n核心需要在内存和sd卡缓存逻辑能够识别出不同尺寸的不同图片。也就是要每一url对应于一组cache。\n\n代码实现上就是要把当前的url的cache对应到一组cache 上去。\n![](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD01.png?raw=true)\n\n###  3.1 Memery cache逻辑\n对于内存cache 建议还是按照以前的逻辑走，但是可以加上对于一个尺寸的的图片可以使用相近已经缓存尺寸的图片。\n\n### 3.2 Disk cache逻辑\n对于Disk cache 。如果需要加载一个小尺寸的图片，但是发现只有大尺寸图片，我们可以直接使用大图压缩出小图，返回过去。\n![](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD02.png?raw=true)\n\n### 3.3 2G网络模式\n\n在低速网络情况下，对于disk cache，如果发现没有当前尺寸的图片的情况下，可以使用任意尺寸的缓存转化。\n\n## 5. 推荐一个图片压缩库  \n\nLuban：https://github.com/Curzibn/Luban      大小仅仅是15K\n\n根据我的测试一般可以在不明显影响图片展示效果的条件减少图片体积2/3。使用它后发图片备注速度飞快。（在wecal里面默认发送压缩后的图片，也提供发送原图的可选项）\n","source":"_posts/图片不同尺寸缓存的优化方案.md","raw":"title: 又拍云图片显示优化\ndate: 2018-2-10 \ncategories:\n- Android\ntags:\n- Android\n- 又拍云\n- 图片\n\n---\n\n ## 1. 又拍云的图片尺寸问题\n \n又拍云会对我们上传的图片进行处理。然后会生成多种尺寸：110,160,210,240,320,480,640,720,1200。\n每种尺寸对应于不同的url。\neg：\nhttp://img2048.static.suishenyun.net/d62bb1e1bf1e2c6b8fb0dd004a952a01/4414fc28822e3643ff90a7e68305e12a.jpg!w480.jpg\n\n## 2. 简单的解决方案\n\n为了利用又拍云自动帮我们处理出来的不同尺寸图片。在每次加载图片的时候根据当前显示View的尺寸加载合适的尺寸\n\n\n### 2.1 这里有三个没解决的问题： \n\n1. 不同尺寸的图片会在sd卡上存不同cache，比如由于我们先加载了640尺寸的图片，后面加载480尺寸还是无法公用640尺寸的图片cache,导致还得重新请求一次网络。实际上我们可以通过处理得到480尺寸的图片。\n\n2. 对于发带图片帖子的这种逻辑处理逻辑处理不方便。因为上传图片后，很有可能不知道图片的显示尺寸。无法把这张本地图片放置到对应位置的cache上去（虽然我们现在上传上去后，会直接显示的是本地图片，但这个有点治标不治本。第二次进来时候或者下拉刷新后 还是会从网上load这张图片）。\n\n3. 图片尺寸的获取，不是所有的ImageView在setImageUrl时候都可以获取尺寸，有的量不到尺寸，也就是在一个还没有渲染 并且也没有设置固定size的ImageVIew上设置Url（比Adapter里面的初次createView  然后立即设置Url就会出现量不到尺寸的问题）\n\n总结一些：又拍云会帮我们处理出来不同尺寸的图片。在小的地方我们可以仅仅加载小尺寸的图片，提高了展示速度。但是对于同一张图片，在不同地方展示不同尺寸的逻辑处理不够完美。所以以前在wecal里面会发现一个问题：同一个头像，已经展示过了，在下一个页面里用另个尺寸展示的时候还是会有点慢。 \n\n## 3. 对于又拍云的图片完美解决方案\n\n核心需要在内存和sd卡缓存逻辑能够识别出不同尺寸的不同图片。也就是要每一url对应于一组cache。\n\n代码实现上就是要把当前的url的cache对应到一组cache 上去。\n![](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD01.png?raw=true)\n\n###  3.1 Memery cache逻辑\n对于内存cache 建议还是按照以前的逻辑走，但是可以加上对于一个尺寸的的图片可以使用相近已经缓存尺寸的图片。\n\n### 3.2 Disk cache逻辑\n对于Disk cache 。如果需要加载一个小尺寸的图片，但是发现只有大尺寸图片，我们可以直接使用大图压缩出小图，返回过去。\n![](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD02.png?raw=true)\n\n### 3.3 2G网络模式\n\n在低速网络情况下，对于disk cache，如果发现没有当前尺寸的图片的情况下，可以使用任意尺寸的缓存转化。\n\n## 5. 推荐一个图片压缩库  \n\nLuban：https://github.com/Curzibn/Luban      大小仅仅是15K\n\n根据我的测试一般可以在不明显影响图片展示效果的条件减少图片体积2/3。使用它后发图片备注速度飞快。（在wecal里面默认发送压缩后的图片，也提供发送原图的可选项）\n","slug":"图片不同尺寸缓存的优化方案","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06ld8001ysfjftntw1olr","content":"<h2 id=\"1-又拍云的图片尺寸问题\"><a href=\"#1-又拍云的图片尺寸问题\" class=\"headerlink\" title=\"1. 又拍云的图片尺寸问题\"></a>1. 又拍云的图片尺寸问题</h2><p>又拍云会对我们上传的图片进行处理。然后会生成多种尺寸：110,160,210,240,320,480,640,720,1200。<br>每种尺寸对应于不同的url。<br>eg：<br><a href=\"http://img2048.static.suishenyun.net/d62bb1e1bf1e2c6b8fb0dd004a952a01/4414fc28822e3643ff90a7e68305e12a.jpg!w480.jpg\" target=\"_blank\" rel=\"external\">http://img2048.static.suishenyun.net/d62bb1e1bf1e2c6b8fb0dd004a952a01/4414fc28822e3643ff90a7e68305e12a.jpg!w480.jpg</a></p>\n<h2 id=\"2-简单的解决方案\"><a href=\"#2-简单的解决方案\" class=\"headerlink\" title=\"2. 简单的解决方案\"></a>2. 简单的解决方案</h2><p>为了利用又拍云自动帮我们处理出来的不同尺寸图片。在每次加载图片的时候根据当前显示View的尺寸加载合适的尺寸</p>\n<h3 id=\"2-1-这里有三个没解决的问题：\"><a href=\"#2-1-这里有三个没解决的问题：\" class=\"headerlink\" title=\"2.1 这里有三个没解决的问题：\"></a>2.1 这里有三个没解决的问题：</h3><ol>\n<li><p>不同尺寸的图片会在sd卡上存不同cache，比如由于我们先加载了640尺寸的图片，后面加载480尺寸还是无法公用640尺寸的图片cache,导致还得重新请求一次网络。实际上我们可以通过处理得到480尺寸的图片。</p>\n</li>\n<li><p>对于发带图片帖子的这种逻辑处理逻辑处理不方便。因为上传图片后，很有可能不知道图片的显示尺寸。无法把这张本地图片放置到对应位置的cache上去（虽然我们现在上传上去后，会直接显示的是本地图片，但这个有点治标不治本。第二次进来时候或者下拉刷新后 还是会从网上load这张图片）。</p>\n</li>\n<li><p>图片尺寸的获取，不是所有的ImageView在setImageUrl时候都可以获取尺寸，有的量不到尺寸，也就是在一个还没有渲染 并且也没有设置固定size的ImageVIew上设置Url（比Adapter里面的初次createView  然后立即设置Url就会出现量不到尺寸的问题）</p>\n</li>\n</ol>\n<p>总结一些：又拍云会帮我们处理出来不同尺寸的图片。在小的地方我们可以仅仅加载小尺寸的图片，提高了展示速度。但是对于同一张图片，在不同地方展示不同尺寸的逻辑处理不够完美。所以以前在wecal里面会发现一个问题：同一个头像，已经展示过了，在下一个页面里用另个尺寸展示的时候还是会有点慢。 </p>\n<h2 id=\"3-对于又拍云的图片完美解决方案\"><a href=\"#3-对于又拍云的图片完美解决方案\" class=\"headerlink\" title=\"3. 对于又拍云的图片完美解决方案\"></a>3. 对于又拍云的图片完美解决方案</h2><p>核心需要在内存和sd卡缓存逻辑能够识别出不同尺寸的不同图片。也就是要每一url对应于一组cache。</p>\n<p>代码实现上就是要把当前的url的cache对应到一组cache 上去。<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD01.png?raw=true\" alt=\"\"></p>\n<h3 id=\"3-1-Memery-cache逻辑\"><a href=\"#3-1-Memery-cache逻辑\" class=\"headerlink\" title=\"3.1 Memery cache逻辑\"></a>3.1 Memery cache逻辑</h3><p>对于内存cache 建议还是按照以前的逻辑走，但是可以加上对于一个尺寸的的图片可以使用相近已经缓存尺寸的图片。</p>\n<h3 id=\"3-2-Disk-cache逻辑\"><a href=\"#3-2-Disk-cache逻辑\" class=\"headerlink\" title=\"3.2 Disk cache逻辑\"></a>3.2 Disk cache逻辑</h3><p>对于Disk cache 。如果需要加载一个小尺寸的图片，但是发现只有大尺寸图片，我们可以直接使用大图压缩出小图，返回过去。<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD02.png?raw=true\" alt=\"\"></p>\n<h3 id=\"3-3-2G网络模式\"><a href=\"#3-3-2G网络模式\" class=\"headerlink\" title=\"3.3 2G网络模式\"></a>3.3 2G网络模式</h3><p>在低速网络情况下，对于disk cache，如果发现没有当前尺寸的图片的情况下，可以使用任意尺寸的缓存转化。</p>\n<h2 id=\"5-推荐一个图片压缩库\"><a href=\"#5-推荐一个图片压缩库\" class=\"headerlink\" title=\"5. 推荐一个图片压缩库\"></a>5. 推荐一个图片压缩库</h2><p>Luban：<a href=\"https://github.com/Curzibn/Luban\" target=\"_blank\" rel=\"external\">https://github.com/Curzibn/Luban</a>      大小仅仅是15K</p>\n<p>根据我的测试一般可以在不明显影响图片展示效果的条件减少图片体积2/3。使用它后发图片备注速度飞快。（在wecal里面默认发送压缩后的图片，也提供发送原图的可选项）</p>\n","excerpt":"","more":"<h2 id=\"1-又拍云的图片尺寸问题\"><a href=\"#1-又拍云的图片尺寸问题\" class=\"headerlink\" title=\"1. 又拍云的图片尺寸问题\"></a>1. 又拍云的图片尺寸问题</h2><p>又拍云会对我们上传的图片进行处理。然后会生成多种尺寸：110,160,210,240,320,480,640,720,1200。<br>每种尺寸对应于不同的url。<br>eg：<br><a href=\"http://img2048.static.suishenyun.net/d62bb1e1bf1e2c6b8fb0dd004a952a01/4414fc28822e3643ff90a7e68305e12a.jpg!w480.jpg\">http://img2048.static.suishenyun.net/d62bb1e1bf1e2c6b8fb0dd004a952a01/4414fc28822e3643ff90a7e68305e12a.jpg!w480.jpg</a></p>\n<h2 id=\"2-简单的解决方案\"><a href=\"#2-简单的解决方案\" class=\"headerlink\" title=\"2. 简单的解决方案\"></a>2. 简单的解决方案</h2><p>为了利用又拍云自动帮我们处理出来的不同尺寸图片。在每次加载图片的时候根据当前显示View的尺寸加载合适的尺寸</p>\n<h3 id=\"2-1-这里有三个没解决的问题：\"><a href=\"#2-1-这里有三个没解决的问题：\" class=\"headerlink\" title=\"2.1 这里有三个没解决的问题：\"></a>2.1 这里有三个没解决的问题：</h3><ol>\n<li><p>不同尺寸的图片会在sd卡上存不同cache，比如由于我们先加载了640尺寸的图片，后面加载480尺寸还是无法公用640尺寸的图片cache,导致还得重新请求一次网络。实际上我们可以通过处理得到480尺寸的图片。</p>\n</li>\n<li><p>对于发带图片帖子的这种逻辑处理逻辑处理不方便。因为上传图片后，很有可能不知道图片的显示尺寸。无法把这张本地图片放置到对应位置的cache上去（虽然我们现在上传上去后，会直接显示的是本地图片，但这个有点治标不治本。第二次进来时候或者下拉刷新后 还是会从网上load这张图片）。</p>\n</li>\n<li><p>图片尺寸的获取，不是所有的ImageView在setImageUrl时候都可以获取尺寸，有的量不到尺寸，也就是在一个还没有渲染 并且也没有设置固定size的ImageVIew上设置Url（比Adapter里面的初次createView  然后立即设置Url就会出现量不到尺寸的问题）</p>\n</li>\n</ol>\n<p>总结一些：又拍云会帮我们处理出来不同尺寸的图片。在小的地方我们可以仅仅加载小尺寸的图片，提高了展示速度。但是对于同一张图片，在不同地方展示不同尺寸的逻辑处理不够完美。所以以前在wecal里面会发现一个问题：同一个头像，已经展示过了，在下一个页面里用另个尺寸展示的时候还是会有点慢。 </p>\n<h2 id=\"3-对于又拍云的图片完美解决方案\"><a href=\"#3-对于又拍云的图片完美解决方案\" class=\"headerlink\" title=\"3. 对于又拍云的图片完美解决方案\"></a>3. 对于又拍云的图片完美解决方案</h2><p>核心需要在内存和sd卡缓存逻辑能够识别出不同尺寸的不同图片。也就是要每一url对应于一组cache。</p>\n<p>代码实现上就是要把当前的url的cache对应到一组cache 上去。<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD01.png?raw=true\" alt=\"\"></p>\n<h3 id=\"3-1-Memery-cache逻辑\"><a href=\"#3-1-Memery-cache逻辑\" class=\"headerlink\" title=\"3.1 Memery cache逻辑\"></a>3.1 Memery cache逻辑</h3><p>对于内存cache 建议还是按照以前的逻辑走，但是可以加上对于一个尺寸的的图片可以使用相近已经缓存尺寸的图片。</p>\n<h3 id=\"3-2-Disk-cache逻辑\"><a href=\"#3-2-Disk-cache逻辑\" class=\"headerlink\" title=\"3.2 Disk cache逻辑\"></a>3.2 Disk cache逻辑</h3><p>对于Disk cache 。如果需要加载一个小尺寸的图片，但是发现只有大尺寸图片，我们可以直接使用大图压缩出小图，返回过去。<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD02.png?raw=true\" alt=\"\"></p>\n<h3 id=\"3-3-2G网络模式\"><a href=\"#3-3-2G网络模式\" class=\"headerlink\" title=\"3.3 2G网络模式\"></a>3.3 2G网络模式</h3><p>在低速网络情况下，对于disk cache，如果发现没有当前尺寸的图片的情况下，可以使用任意尺寸的缓存转化。</p>\n<h2 id=\"5-推荐一个图片压缩库\"><a href=\"#5-推荐一个图片压缩库\" class=\"headerlink\" title=\"5. 推荐一个图片压缩库\"></a>5. 推荐一个图片压缩库</h2><p>Luban：<a href=\"https://github.com/Curzibn/Luban\">https://github.com/Curzibn/Luban</a>      大小仅仅是15K</p>\n<p>根据我的测试一般可以在不明显影响图片展示效果的条件减少图片体积2/3。使用它后发图片备注速度飞快。（在wecal里面默认发送压缩后的图片，也提供发送原图的可选项）</p>\n"},{"title":"数据库踩坑和调试","date":"2017-03-31T16:00:00.000Z","_content":"\n# 数据库\n## Android数据库设计\n1. 冗余字段设计，表设计要空出2到3个冗余字段  \n2. 不要过多的关联查询，外键约束不要多了  \n3. 设计要优先考虑易用性 ，容易升级，性能方面主要要通过应用层来掌控  \n4. 适当的分库可以有效避免数据库被锁住。（sqlite的文件锁） \n\n## Android DB操作技巧\n1. 对于经常要使用的DB不需要关闭，一般全局保存一个静态的SQLiteDatabase（Writable的），而且是在Application oncreate 就初始化好.  \n2. 由于Application  没有destroy的回调，这里我们一般会做一个ActivityStack，然后在Activity初始化和destory 时候入栈和出栈来控制界面的显示逻辑,当检测到栈为空的时候就可以认为要退出应用了。\n3. 能一次取完数据，不要分次取（虽然可能取得数据量有一定优化，但是分次太耗时，尽量交给上层做）\n4. DataBase is locked，导致数据取不出来。 解决方向有以下几点：  \n第1点：在获取databse时候加一个锁    \n第2点：分库，对于相互关联若的数据进行分库处理     \n第3点：数据库不要关闭,并且尝试分开存writeable 和 readable两个静态的DB    \n## 数据库调试  \n### 第一步通过AS自带的Android monitor  把数据库导出来  \n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E8%AF%9501.png?raw=true)\n### 第二步通过Sqlite professional   \n查看数据库的结构可以具体查看到每一张表的详细信息  \n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E8%AF%9502.png?raw=true)\n也可以通过query工具栏，执行基本的命令行操作。\n\n\nSqlite基本命令：http://www.runoob.com/sqlite/sqlite-trigger.html\n","source":"_posts/数据库.md","raw":"title: 数据库踩坑和调试\ndate: 2017-4-1 \ncategories:\n- Android\ntags:\n- Android\n- 数据库\n\n---\n\n# 数据库\n## Android数据库设计\n1. 冗余字段设计，表设计要空出2到3个冗余字段  \n2. 不要过多的关联查询，外键约束不要多了  \n3. 设计要优先考虑易用性 ，容易升级，性能方面主要要通过应用层来掌控  \n4. 适当的分库可以有效避免数据库被锁住。（sqlite的文件锁） \n\n## Android DB操作技巧\n1. 对于经常要使用的DB不需要关闭，一般全局保存一个静态的SQLiteDatabase（Writable的），而且是在Application oncreate 就初始化好.  \n2. 由于Application  没有destroy的回调，这里我们一般会做一个ActivityStack，然后在Activity初始化和destory 时候入栈和出栈来控制界面的显示逻辑,当检测到栈为空的时候就可以认为要退出应用了。\n3. 能一次取完数据，不要分次取（虽然可能取得数据量有一定优化，但是分次太耗时，尽量交给上层做）\n4. DataBase is locked，导致数据取不出来。 解决方向有以下几点：  \n第1点：在获取databse时候加一个锁    \n第2点：分库，对于相互关联若的数据进行分库处理     \n第3点：数据库不要关闭,并且尝试分开存writeable 和 readable两个静态的DB    \n## 数据库调试  \n### 第一步通过AS自带的Android monitor  把数据库导出来  \n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E8%AF%9501.png?raw=true)\n### 第二步通过Sqlite professional   \n查看数据库的结构可以具体查看到每一张表的详细信息  \n![see](https://github.com/liuyicheng3/learning-summary/blob/master/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E8%AF%9502.png?raw=true)\n也可以通过query工具栏，执行基本的命令行操作。\n\n\nSqlite基本命令：http://www.runoob.com/sqlite/sqlite-trigger.html\n","slug":"数据库","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06ldd0021sfjf4g0sditg","content":"<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"Android数据库设计\"><a href=\"#Android数据库设计\" class=\"headerlink\" title=\"Android数据库设计\"></a>Android数据库设计</h2><ol>\n<li>冗余字段设计，表设计要空出2到3个冗余字段  </li>\n<li>不要过多的关联查询，外键约束不要多了  </li>\n<li>设计要优先考虑易用性 ，容易升级，性能方面主要要通过应用层来掌控  </li>\n<li>适当的分库可以有效避免数据库被锁住。（sqlite的文件锁） </li>\n</ol>\n<h2 id=\"Android-DB操作技巧\"><a href=\"#Android-DB操作技巧\" class=\"headerlink\" title=\"Android DB操作技巧\"></a>Android DB操作技巧</h2><ol>\n<li>对于经常要使用的DB不需要关闭，一般全局保存一个静态的SQLiteDatabase（Writable的），而且是在Application oncreate 就初始化好.  </li>\n<li>由于Application  没有destroy的回调，这里我们一般会做一个ActivityStack，然后在Activity初始化和destory 时候入栈和出栈来控制界面的显示逻辑,当检测到栈为空的时候就可以认为要退出应用了。</li>\n<li>能一次取完数据，不要分次取（虽然可能取得数据量有一定优化，但是分次太耗时，尽量交给上层做）</li>\n<li>DataBase is locked，导致数据取不出来。 解决方向有以下几点：<br>第1点：在获取databse时候加一个锁<br>第2点：分库，对于相互关联若的数据进行分库处理<br>第3点：数据库不要关闭,并且尝试分开存writeable 和 readable两个静态的DB    <h2 id=\"数据库调试\"><a href=\"#数据库调试\" class=\"headerlink\" title=\"数据库调试\"></a>数据库调试</h2><h3 id=\"第一步通过AS自带的Android-monitor-把数据库导出来\"><a href=\"#第一步通过AS自带的Android-monitor-把数据库导出来\" class=\"headerlink\" title=\"第一步通过AS自带的Android monitor  把数据库导出来\"></a>第一步通过AS自带的Android monitor  把数据库导出来</h3><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E8%AF%9501.png?raw=true\" alt=\"see\"><h3 id=\"第二步通过Sqlite-professional\"><a href=\"#第二步通过Sqlite-professional\" class=\"headerlink\" title=\"第二步通过Sqlite professional\"></a>第二步通过Sqlite professional</h3>查看数据库的结构可以具体查看到每一张表的详细信息<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E8%AF%9502.png?raw=true\" alt=\"see\"><br>也可以通过query工具栏，执行基本的命令行操作。</li>\n</ol>\n<p>Sqlite基本命令：<a href=\"http://www.runoob.com/sqlite/sqlite-trigger.html\" target=\"_blank\" rel=\"external\">http://www.runoob.com/sqlite/sqlite-trigger.html</a></p>\n","excerpt":"","more":"<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"Android数据库设计\"><a href=\"#Android数据库设计\" class=\"headerlink\" title=\"Android数据库设计\"></a>Android数据库设计</h2><ol>\n<li>冗余字段设计，表设计要空出2到3个冗余字段  </li>\n<li>不要过多的关联查询，外键约束不要多了  </li>\n<li>设计要优先考虑易用性 ，容易升级，性能方面主要要通过应用层来掌控  </li>\n<li>适当的分库可以有效避免数据库被锁住。（sqlite的文件锁） </li>\n</ol>\n<h2 id=\"Android-DB操作技巧\"><a href=\"#Android-DB操作技巧\" class=\"headerlink\" title=\"Android DB操作技巧\"></a>Android DB操作技巧</h2><ol>\n<li>对于经常要使用的DB不需要关闭，一般全局保存一个静态的SQLiteDatabase（Writable的），而且是在Application oncreate 就初始化好.  </li>\n<li>由于Application  没有destroy的回调，这里我们一般会做一个ActivityStack，然后在Activity初始化和destory 时候入栈和出栈来控制界面的显示逻辑,当检测到栈为空的时候就可以认为要退出应用了。</li>\n<li>能一次取完数据，不要分次取（虽然可能取得数据量有一定优化，但是分次太耗时，尽量交给上层做）</li>\n<li>DataBase is locked，导致数据取不出来。 解决方向有以下几点：<br>第1点：在获取databse时候加一个锁<br>第2点：分库，对于相互关联若的数据进行分库处理<br>第3点：数据库不要关闭,并且尝试分开存writeable 和 readable两个静态的DB    <h2 id=\"数据库调试\"><a href=\"#数据库调试\" class=\"headerlink\" title=\"数据库调试\"></a>数据库调试</h2><h3 id=\"第一步通过AS自带的Android-monitor-把数据库导出来\"><a href=\"#第一步通过AS自带的Android-monitor-把数据库导出来\" class=\"headerlink\" title=\"第一步通过AS自带的Android monitor  把数据库导出来\"></a>第一步通过AS自带的Android monitor  把数据库导出来</h3><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E8%AF%9501.png?raw=true\" alt=\"see\"><h3 id=\"第二步通过Sqlite-professional\"><a href=\"#第二步通过Sqlite-professional\" class=\"headerlink\" title=\"第二步通过Sqlite professional\"></a>第二步通过Sqlite professional</h3>查看数据库的结构可以具体查看到每一张表的详细信息<br><img src=\"https://github.com/liuyicheng3/learning-summary/blob/master/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E8%AF%9502.png?raw=true\" alt=\"see\"><br>也可以通过query工具栏，执行基本的命令行操作。</li>\n</ol>\n<p>Sqlite基本命令：<a href=\"http://www.runoob.com/sqlite/sqlite-trigger.html\">http://www.runoob.com/sqlite/sqlite-trigger.html</a></p>\n"},{"title":"沉浸式的实现方案","date":"2018-02-13T16:00:00.000Z","_content":"\n# Step 1：  \n把状态栏设置为透明\n\n\n        if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.LOLLIPOP&&!Build.BRAND.equalsIgnoreCase(\"huawei\")){/**5.0及以上且不是华为,\n                因为华为5.0以上系统已经全屏但是状态栏黑色改不掉*/\n            Window window = getWindow();\n            window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS\n                    | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);\n            window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION\n                    | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);\n            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n            if(Build.VERSION.SDK_INT>= Build.VERSION_CODES.M){\n                window.setStatusBarColor(Color.TRANSPARENT);\n                if(Build.MANUFACTURER.toLowerCase().contains(\"xiaomi\")) {\n                    setMiuiStatusBarDarkMode(true);\n                }\n            }else{\n                window.setStatusBarColor(Color.argb(0x80,0x00,0x00,0x00));\n            }\n            \n        }else{/**5.0以下，4.0及以上*/\n            Window win = getWindow();\n            WindowManager.LayoutParams winParams = win.getAttributes();\n            int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;\n            winParams.flags |= bits;\n            win.setAttributes(winParams);\n        }\n        /**由于MIUI 6修改过所以系统方法无法设置状态栏字体颜色无效，需要使用该方法设置\n        *ps:mui上设置状态栏字体颜色为深色\n        *\n        */\n        public void setMiuiStatusBarDarkMode(boolean isdarkmode) {\n        Class<? extends Window> clazz = this.getWindow().getClass();\n        try {\n            int darkModeFlag = 0;\n            Class<?> layoutParams = Class.forName(\"android.view.MiuiWindowManager$LayoutParams\");\n            Field field = layoutParams.getField(\"EXTRA_FLAG_STATUS_BAR_DARK_MODE\");\n            darkModeFlag = field.getInt(layoutParams);\n            Method extraFlagField = clazz.getMethod(\"setExtraFlags\", int.class, int.class);\n            extraFlagField.invoke(this.getWindow(), isdarkmode ? darkModeFlag : 0, darkModeFlag);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n\n## Step 2：  \n设置绘制区域\n\n        rootView.setFitsSystemWindows(true);\n        rootView.setClipToPadding(true);\n\n\n这样rootView就顶上头部去了，但是有个副作用就是界面显示区域也扩展下面的虚拟按键后面了，所以要对于alignparentbottom的功能栏，就不能直接放到rootView里面，必须放到与rootView外面。这样功能栏就不会被底部的虚拟按键盖住（这里不要考虑计算虚拟按键的高度，已经是否有虚拟按键，华为手机可以通过手势动态展开或者收起虚拟按键）\n\n## 注意机型： \n1. nexus固定死的虚拟按键\n2. 华为和小米Mix可以使用手势控制的虚拟按键\n\n\n","source":"_posts/沉浸式.md","raw":"title: 沉浸式的实现方案\ndate: 2018-2-14 \ncategories:\n- Android\ntags:\n- Android\n- 沉浸式\n\n---\n\n# Step 1：  \n把状态栏设置为透明\n\n\n        if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.LOLLIPOP&&!Build.BRAND.equalsIgnoreCase(\"huawei\")){/**5.0及以上且不是华为,\n                因为华为5.0以上系统已经全屏但是状态栏黑色改不掉*/\n            Window window = getWindow();\n            window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS\n                    | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);\n            window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION\n                    | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);\n            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n            if(Build.VERSION.SDK_INT>= Build.VERSION_CODES.M){\n                window.setStatusBarColor(Color.TRANSPARENT);\n                if(Build.MANUFACTURER.toLowerCase().contains(\"xiaomi\")) {\n                    setMiuiStatusBarDarkMode(true);\n                }\n            }else{\n                window.setStatusBarColor(Color.argb(0x80,0x00,0x00,0x00));\n            }\n            \n        }else{/**5.0以下，4.0及以上*/\n            Window win = getWindow();\n            WindowManager.LayoutParams winParams = win.getAttributes();\n            int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;\n            winParams.flags |= bits;\n            win.setAttributes(winParams);\n        }\n        /**由于MIUI 6修改过所以系统方法无法设置状态栏字体颜色无效，需要使用该方法设置\n        *ps:mui上设置状态栏字体颜色为深色\n        *\n        */\n        public void setMiuiStatusBarDarkMode(boolean isdarkmode) {\n        Class<? extends Window> clazz = this.getWindow().getClass();\n        try {\n            int darkModeFlag = 0;\n            Class<?> layoutParams = Class.forName(\"android.view.MiuiWindowManager$LayoutParams\");\n            Field field = layoutParams.getField(\"EXTRA_FLAG_STATUS_BAR_DARK_MODE\");\n            darkModeFlag = field.getInt(layoutParams);\n            Method extraFlagField = clazz.getMethod(\"setExtraFlags\", int.class, int.class);\n            extraFlagField.invoke(this.getWindow(), isdarkmode ? darkModeFlag : 0, darkModeFlag);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n\n## Step 2：  \n设置绘制区域\n\n        rootView.setFitsSystemWindows(true);\n        rootView.setClipToPadding(true);\n\n\n这样rootView就顶上头部去了，但是有个副作用就是界面显示区域也扩展下面的虚拟按键后面了，所以要对于alignparentbottom的功能栏，就不能直接放到rootView里面，必须放到与rootView外面。这样功能栏就不会被底部的虚拟按键盖住（这里不要考虑计算虚拟按键的高度，已经是否有虚拟按键，华为手机可以通过手势动态展开或者收起虚拟按键）\n\n## 注意机型： \n1. nexus固定死的虚拟按键\n2. 华为和小米Mix可以使用手势控制的虚拟按键\n\n\n","slug":"沉浸式","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06ldg0026sfjf45ike5ie","content":"<h1 id=\"Step-1：\"><a href=\"#Step-1：\" class=\"headerlink\" title=\"Step 1：\"></a>Step 1：</h1><p>把状态栏设置为透明</p>\n<pre><code>    if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.LOLLIPOP&amp;&amp;!Build.BRAND.equalsIgnoreCase(&quot;huawei&quot;)){/**5.0及以上且不是华为,\n            因为华为5.0以上系统已经全屏但是状态栏黑色改不掉*/\n        Window window = getWindow();\n        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS\n                | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);\n        window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION\n                | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);\n        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n        if(Build.VERSION.SDK_INT&gt;= Build.VERSION_CODES.M){\n            window.setStatusBarColor(Color.TRANSPARENT);\n            if(Build.MANUFACTURER.toLowerCase().contains(&quot;xiaomi&quot;)) {\n                setMiuiStatusBarDarkMode(true);\n            }\n        }else{\n            window.setStatusBarColor(Color.argb(0x80,0x00,0x00,0x00));\n        }\n\n    }else{/**5.0以下，4.0及以上*/\n        Window win = getWindow();\n        WindowManager.LayoutParams winParams = win.getAttributes();\n        int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;\n        winParams.flags |= bits;\n        win.setAttributes(winParams);\n    }\n    /**由于MIUI 6修改过所以系统方法无法设置状态栏字体颜色无效，需要使用该方法设置\n    *ps:mui上设置状态栏字体颜色为深色\n    *\n    */\n    public void setMiuiStatusBarDarkMode(boolean isdarkmode) {\n    Class&lt;? extends Window&gt; clazz = this.getWindow().getClass();\n    try {\n        int darkModeFlag = 0;\n        Class&lt;?&gt; layoutParams = Class.forName(&quot;android.view.MiuiWindowManager$LayoutParams&quot;);\n        Field field = layoutParams.getField(&quot;EXTRA_FLAG_STATUS_BAR_DARK_MODE&quot;);\n        darkModeFlag = field.getInt(layoutParams);\n        Method extraFlagField = clazz.getMethod(&quot;setExtraFlags&quot;, int.class, int.class);\n        extraFlagField.invoke(this.getWindow(), isdarkmode ? darkModeFlag : 0, darkModeFlag);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n</code></pre><h2 id=\"Step-2：\"><a href=\"#Step-2：\" class=\"headerlink\" title=\"Step 2：\"></a>Step 2：</h2><p>设置绘制区域</p>\n<pre><code>rootView.setFitsSystemWindows(true);\nrootView.setClipToPadding(true);\n</code></pre><p>这样rootView就顶上头部去了，但是有个副作用就是界面显示区域也扩展下面的虚拟按键后面了，所以要对于alignparentbottom的功能栏，就不能直接放到rootView里面，必须放到与rootView外面。这样功能栏就不会被底部的虚拟按键盖住（这里不要考虑计算虚拟按键的高度，已经是否有虚拟按键，华为手机可以通过手势动态展开或者收起虚拟按键）</p>\n<h2 id=\"注意机型：\"><a href=\"#注意机型：\" class=\"headerlink\" title=\"注意机型：\"></a>注意机型：</h2><ol>\n<li>nexus固定死的虚拟按键</li>\n<li>华为和小米Mix可以使用手势控制的虚拟按键</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"Step-1：\"><a href=\"#Step-1：\" class=\"headerlink\" title=\"Step 1：\"></a>Step 1：</h1><p>把状态栏设置为透明</p>\n<pre><code>    if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.LOLLIPOP&amp;&amp;!Build.BRAND.equalsIgnoreCase(&quot;huawei&quot;)){/**5.0及以上且不是华为,\n            因为华为5.0以上系统已经全屏但是状态栏黑色改不掉*/\n        Window window = getWindow();\n        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS\n                | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);\n        window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION\n                | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);\n        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);\n        if(Build.VERSION.SDK_INT&gt;= Build.VERSION_CODES.M){\n            window.setStatusBarColor(Color.TRANSPARENT);\n            if(Build.MANUFACTURER.toLowerCase().contains(&quot;xiaomi&quot;)) {\n                setMiuiStatusBarDarkMode(true);\n            }\n        }else{\n            window.setStatusBarColor(Color.argb(0x80,0x00,0x00,0x00));\n        }\n\n    }else{/**5.0以下，4.0及以上*/\n        Window win = getWindow();\n        WindowManager.LayoutParams winParams = win.getAttributes();\n        int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;\n        winParams.flags |= bits;\n        win.setAttributes(winParams);\n    }\n    /**由于MIUI 6修改过所以系统方法无法设置状态栏字体颜色无效，需要使用该方法设置\n    *ps:mui上设置状态栏字体颜色为深色\n    *\n    */\n    public void setMiuiStatusBarDarkMode(boolean isdarkmode) {\n    Class&lt;? extends Window&gt; clazz = this.getWindow().getClass();\n    try {\n        int darkModeFlag = 0;\n        Class&lt;?&gt; layoutParams = Class.forName(&quot;android.view.MiuiWindowManager$LayoutParams&quot;);\n        Field field = layoutParams.getField(&quot;EXTRA_FLAG_STATUS_BAR_DARK_MODE&quot;);\n        darkModeFlag = field.getInt(layoutParams);\n        Method extraFlagField = clazz.getMethod(&quot;setExtraFlags&quot;, int.class, int.class);\n        extraFlagField.invoke(this.getWindow(), isdarkmode ? darkModeFlag : 0, darkModeFlag);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n</code></pre><h2 id=\"Step-2：\"><a href=\"#Step-2：\" class=\"headerlink\" title=\"Step 2：\"></a>Step 2：</h2><p>设置绘制区域</p>\n<pre><code>rootView.setFitsSystemWindows(true);\nrootView.setClipToPadding(true);\n</code></pre><p>这样rootView就顶上头部去了，但是有个副作用就是界面显示区域也扩展下面的虚拟按键后面了，所以要对于alignparentbottom的功能栏，就不能直接放到rootView里面，必须放到与rootView外面。这样功能栏就不会被底部的虚拟按键盖住（这里不要考虑计算虚拟按键的高度，已经是否有虚拟按键，华为手机可以通过手势动态展开或者收起虚拟按键）</p>\n<h2 id=\"注意机型：\"><a href=\"#注意机型：\" class=\"headerlink\" title=\"注意机型：\"></a>注意机型：</h2><ol>\n<li>nexus固定死的虚拟按键</li>\n<li>华为和小米Mix可以使用手势控制的虚拟按键</li>\n</ol>\n"},{"title":"混淆写法","date":"2015-11-01T12:10:33.000Z","_content":"\n\n-keepclassmembers class ** {\n    public void onEvent*(**);\n}\n\n只保护 public void onEvent*(**)的方法不被重命名\n\n-keepattributes Signature\n\n\n-keep class okio.** {*;}\n\n\n-keep class android.support.v4.app.NotificationCompat**{\n    public *;\n}\n\n\n-keep class com.veda.lyc.Utils{ static *;}  \n保持里面的静态方法不被混淆\n\nkeep的几个选项\n\n\n| Keep        | From being removed or renamed   |  From being renamed  |\n| --------   | -----:  | :----:  |\n| Classes and class members     | -keep |   -keepnames     |\n| Class members only        |   -keepclassmembers   |   -keepclassmembernames   |\n| \t-keepclassmembers\t-keepclassmembernames\nClasses and class members, if class members present       |    -keepclasseswithmembers    |  -keepclasseswithmembernames  |\n\n\n参考资料\nhttp://blog.csdn.net/sudic_niu/article/details/7921548","source":"_posts/混淆写法.md","raw":"title: 混淆写法\ndate: 2015-11-01 20:10:33\ncategories:\n- 打包\ntags:\n- Android\n---\n\n\n-keepclassmembers class ** {\n    public void onEvent*(**);\n}\n\n只保护 public void onEvent*(**)的方法不被重命名\n\n-keepattributes Signature\n\n\n-keep class okio.** {*;}\n\n\n-keep class android.support.v4.app.NotificationCompat**{\n    public *;\n}\n\n\n-keep class com.veda.lyc.Utils{ static *;}  \n保持里面的静态方法不被混淆\n\nkeep的几个选项\n\n\n| Keep        | From being removed or renamed   |  From being renamed  |\n| --------   | -----:  | :----:  |\n| Classes and class members     | -keep |   -keepnames     |\n| Class members only        |   -keepclassmembers   |   -keepclassmembernames   |\n| \t-keepclassmembers\t-keepclassmembernames\nClasses and class members, if class members present       |    -keepclasseswithmembers    |  -keepclasseswithmembernames  |\n\n\n参考资料\nhttp://blog.csdn.net/sudic_niu/article/details/7921548","slug":"混淆写法","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06ldj0029sfjf39fjwg91","content":"<p>-keepclassmembers class <strong> {<br>    public void onEvent*(</strong>);<br>}</p>\n<p>只保护 public void onEvent<em>(*</em>)的方法不被重命名</p>\n<p>-keepattributes Signature</p>\n<p>-keep class okio.<em>* {</em>;}</p>\n<p>-keep class android.support.v4.app.NotificationCompat<em>*{<br>    public </em>;<br>}</p>\n<p>-keep class com.veda.lyc.Utils{ static *;}<br>保持里面的静态方法不被混淆</p>\n<p>keep的几个选项</p>\n<table>\n<thead>\n<tr>\n<th>Keep</th>\n<th style=\"text-align:right\">From being removed or renamed</th>\n<th style=\"text-align:center\">From being renamed</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Classes and class members</td>\n<td style=\"text-align:right\">-keep</td>\n<td style=\"text-align:center\">-keepnames</td>\n</tr>\n<tr>\n<td>Class members only</td>\n<td style=\"text-align:right\">-keepclassmembers</td>\n<td style=\"text-align:center\">-keepclassmembernames</td>\n</tr>\n<tr>\n<td>-keepclassmembers    -keepclassmembernames</td>\n</tr>\n</tbody>\n</table>\n<p>Classes and class members, if class members present       |    -keepclasseswithmembers    |  -keepclasseswithmembernames  |</p>\n<p>参考资料<br><a href=\"http://blog.csdn.net/sudic_niu/article/details/7921548\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/sudic_niu/article/details/7921548</a></p>\n","excerpt":"","more":"<p>-keepclassmembers class <strong> {<br>    public void onEvent*(</strong>);<br>}</p>\n<p>只保护 public void onEvent<em>(*</em>)的方法不被重命名</p>\n<p>-keepattributes Signature</p>\n<p>-keep class okio.<em>* {</em>;}</p>\n<p>-keep class android.support.v4.app.NotificationCompat<em>*{<br>    public </em>;<br>}</p>\n<p>-keep class com.veda.lyc.Utils{ static *;}<br>保持里面的静态方法不被混淆</p>\n<p>keep的几个选项</p>\n<table>\n<thead>\n<tr>\n<th>Keep</th>\n<th style=\"text-align:right\">From being removed or renamed</th>\n<th style=\"text-align:center\">From being renamed</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Classes and class members</td>\n<td style=\"text-align:right\">-keep</td>\n<td style=\"text-align:center\">-keepnames</td>\n</tr>\n<tr>\n<td>Class members only</td>\n<td style=\"text-align:right\">-keepclassmembers</td>\n<td style=\"text-align:center\">-keepclassmembernames</td>\n</tr>\n<tr>\n<td>-keepclassmembers    -keepclassmembernames</td>\n</tr>\n</tbody>\n</table>\n<p>Classes and class members, if class members present       |    -keepclasseswithmembers    |  -keepclasseswithmembernames  |</p>\n<p>参考资料<br><a href=\"http://blog.csdn.net/sudic_niu/article/details/7921548\">http://blog.csdn.net/sudic_niu/article/details/7921548</a></p>\n"},{"title":"点赞爱心动画","date":"2017-10-09T16:00:00.000Z","_content":"\n# 场景   \n 实现直播房间点赞爱心动画（不是送礼物的动画）  \n 难点：流畅的飘爱心\n\n# 1. 方案1  \n直接使用animator做动画\n参考资料： https://github.com/Yasic/QQBubbleView  \n\n\n### 1.1. 优化方向：\n\n1. 削峰\n2. 不要每次都inflate layout，尝试模拟listview的recycleBin 对用跑完动画的View 重新赋值初始化\n\n\n## 2. 方案2：\n\n直接在View上绘制爱心  \n参考资料：https://github.com/HomHomLin/Android-DivergeView\n核心就是一个while循环，不断计算当前爱心的位置\n\n        while (mRunning) {\n            if (mQueen == null) {\n                continue;\n            }\n            if (mIsDrawing) {\n                //如果正在绘制，不要处理数据\n                continue;\n            }\n            dealQueen();\n            dealDiverge();\n            mIsDrawing = true;\n            postInvalidate();\n        }\n        \n在dealQueen里面处理正在等待走动画的点赞  \n\n    if (mQueen.size() > 0 && now - mLastAddTime > mQueenDuration) {\n            mLastAddTime = System.currentTimeMillis();\n            DivergeInfo divergeInfo = null;\n            if (mDeadPool.size() > 0) {\n                //死池里面有空闲的divergeNode\n                divergeInfo = mDeadPool.get(0);\n                mDeadPool.remove(0);\n            }\n            if (divergeInfo == null) {\n                divergeInfo = createDivergeNode(mQueen.get(0));\n            }\n            divergeInfo.reset();\n            divergeInfo.mType = mQueen.get(0);\n            mDivergeInfos.add(divergeInfo);\n            mQueen.remove(0);\n        }\n\n在dealDiverge里面计算已经在走动画的爱心的位置  \n\n     for (int i = 0; i < mDivergeInfos.size(); i++) {\n            DivergeInfo divergeInfo = mDivergeInfos.get(i);\n            float timeLeft = 1.0F - divergeInfo.mDuration;\n            divergeInfo.mDuration += mDuration;\n            float x, y;\n            //二次贝塞尔\n            float time1 = timeLeft * timeLeft;\n            float time2 = 2 * timeLeft * divergeInfo.mDuration;\n            float time3 = divergeInfo.mDuration * divergeInfo.mDuration;\n            x = time1 * (mPtStart.x)\n                    + time2 * (divergeInfo.mBreakPoint.x)\n                    + time3 * (divergeInfo.mEndPoint.x);\n\n            divergeInfo.mX = x;\n\n            y = time1 * (mPtStart.y)\n                    + time2 * (divergeInfo.mBreakPoint.y)\n                    + time3 * (divergeInfo.mEndPoint.y);\n\n            divergeInfo.mY = y;\n\n            if (divergeInfo.mY <= divergeInfo.mEndPoint.y) {\n                mDivergeInfos.remove(i);\n                mDeadPool.add(divergeInfo);\n                i--;\n                continue;\n            }\n        }\n\nonDraw方法\n\n      for (DivergeInfo divergeInfo : mDivergeInfos) {\n                mPaint.setAlpha((int) (255 * divergeInfo.mY / mPtStart.y));\n                Bitmap bm = mDivergeViewProvider.getBitmap(divergeInfo.mType);\n                float originCenterX = divergeInfo.mX + bm.getWidth() / 2;\n                float originCenterY = divergeInfo.mY + bm.getHeight() / 2;\n                float scaleWidth, scaleHeight;               \n                scaleWidth = bm.getWidth();\n                scaleHeight = bm.getHeight();\n                RectF destRect = new RectF(originCenterX - scaleWidth / 2, originCenterY - scaleHeight / 2,\n                        originCenterX + scaleWidth / 2, originCenterY + scaleHeight / 2);\n                canvas.drawBitmap(bm, null\n                        , destRect,\n                        mPaint);\n            }\n       mIsDrawing = false;\n       \nps：映客的点赞爱心就是这么实现的（映客是本地点赞出爱心，这个直接分析元素会失败，可以进入直播后，断网然后分析元素）\n\n### 2.1. 优化方向：\n1. 停止爱心动画的时机（什么时候可以停止while循环）\n2. 削峰：Android 每隔 16.6 ms 刷新一次屏幕，可以根据这个计算一次主流机型阈值\n\n\n\n\n都需要利用到削峰\n\n\n\n\n# 额外知识点\n二阶贝塞尔曲线公式：\n![二阶](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D317/sign=9aefef4b08f79052eb1f413f3bf2d738/11385343fbf2b21129581916cb8065380cd78e70.jpg)    \n\n三阶贝塞尔曲线公式： \n![三阶](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D421/sign=9a6521eab8014a90853e47bf98763971/f603918fa0ec08fad54f8dff58ee3d6d55fbda1f.jpg)    \n\n\n在线演示：http://myst729.github.io/bezier-curve/\n","source":"_posts/点赞爱心动画.md","raw":"title: 点赞爱心动画\ndate: 2017-10-10 \ncategories:\n- Android\ntags:\n- Android\n- 爱心动画\n---\n\n# 场景   \n 实现直播房间点赞爱心动画（不是送礼物的动画）  \n 难点：流畅的飘爱心\n\n# 1. 方案1  \n直接使用animator做动画\n参考资料： https://github.com/Yasic/QQBubbleView  \n\n\n### 1.1. 优化方向：\n\n1. 削峰\n2. 不要每次都inflate layout，尝试模拟listview的recycleBin 对用跑完动画的View 重新赋值初始化\n\n\n## 2. 方案2：\n\n直接在View上绘制爱心  \n参考资料：https://github.com/HomHomLin/Android-DivergeView\n核心就是一个while循环，不断计算当前爱心的位置\n\n        while (mRunning) {\n            if (mQueen == null) {\n                continue;\n            }\n            if (mIsDrawing) {\n                //如果正在绘制，不要处理数据\n                continue;\n            }\n            dealQueen();\n            dealDiverge();\n            mIsDrawing = true;\n            postInvalidate();\n        }\n        \n在dealQueen里面处理正在等待走动画的点赞  \n\n    if (mQueen.size() > 0 && now - mLastAddTime > mQueenDuration) {\n            mLastAddTime = System.currentTimeMillis();\n            DivergeInfo divergeInfo = null;\n            if (mDeadPool.size() > 0) {\n                //死池里面有空闲的divergeNode\n                divergeInfo = mDeadPool.get(0);\n                mDeadPool.remove(0);\n            }\n            if (divergeInfo == null) {\n                divergeInfo = createDivergeNode(mQueen.get(0));\n            }\n            divergeInfo.reset();\n            divergeInfo.mType = mQueen.get(0);\n            mDivergeInfos.add(divergeInfo);\n            mQueen.remove(0);\n        }\n\n在dealDiverge里面计算已经在走动画的爱心的位置  \n\n     for (int i = 0; i < mDivergeInfos.size(); i++) {\n            DivergeInfo divergeInfo = mDivergeInfos.get(i);\n            float timeLeft = 1.0F - divergeInfo.mDuration;\n            divergeInfo.mDuration += mDuration;\n            float x, y;\n            //二次贝塞尔\n            float time1 = timeLeft * timeLeft;\n            float time2 = 2 * timeLeft * divergeInfo.mDuration;\n            float time3 = divergeInfo.mDuration * divergeInfo.mDuration;\n            x = time1 * (mPtStart.x)\n                    + time2 * (divergeInfo.mBreakPoint.x)\n                    + time3 * (divergeInfo.mEndPoint.x);\n\n            divergeInfo.mX = x;\n\n            y = time1 * (mPtStart.y)\n                    + time2 * (divergeInfo.mBreakPoint.y)\n                    + time3 * (divergeInfo.mEndPoint.y);\n\n            divergeInfo.mY = y;\n\n            if (divergeInfo.mY <= divergeInfo.mEndPoint.y) {\n                mDivergeInfos.remove(i);\n                mDeadPool.add(divergeInfo);\n                i--;\n                continue;\n            }\n        }\n\nonDraw方法\n\n      for (DivergeInfo divergeInfo : mDivergeInfos) {\n                mPaint.setAlpha((int) (255 * divergeInfo.mY / mPtStart.y));\n                Bitmap bm = mDivergeViewProvider.getBitmap(divergeInfo.mType);\n                float originCenterX = divergeInfo.mX + bm.getWidth() / 2;\n                float originCenterY = divergeInfo.mY + bm.getHeight() / 2;\n                float scaleWidth, scaleHeight;               \n                scaleWidth = bm.getWidth();\n                scaleHeight = bm.getHeight();\n                RectF destRect = new RectF(originCenterX - scaleWidth / 2, originCenterY - scaleHeight / 2,\n                        originCenterX + scaleWidth / 2, originCenterY + scaleHeight / 2);\n                canvas.drawBitmap(bm, null\n                        , destRect,\n                        mPaint);\n            }\n       mIsDrawing = false;\n       \nps：映客的点赞爱心就是这么实现的（映客是本地点赞出爱心，这个直接分析元素会失败，可以进入直播后，断网然后分析元素）\n\n### 2.1. 优化方向：\n1. 停止爱心动画的时机（什么时候可以停止while循环）\n2. 削峰：Android 每隔 16.6 ms 刷新一次屏幕，可以根据这个计算一次主流机型阈值\n\n\n\n\n都需要利用到削峰\n\n\n\n\n# 额外知识点\n二阶贝塞尔曲线公式：\n![二阶](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D317/sign=9aefef4b08f79052eb1f413f3bf2d738/11385343fbf2b21129581916cb8065380cd78e70.jpg)    \n\n三阶贝塞尔曲线公式： \n![三阶](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D421/sign=9a6521eab8014a90853e47bf98763971/f603918fa0ec08fad54f8dff58ee3d6d55fbda1f.jpg)    \n\n\n在线演示：http://myst729.github.io/bezier-curve/\n","slug":"点赞爱心动画","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06ldk002dsfjf25jgvh0v","content":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p> 实现直播房间点赞爱心动画（不是送礼物的动画）<br> 难点：流畅的飘爱心</p>\n<h1 id=\"1-方案1\"><a href=\"#1-方案1\" class=\"headerlink\" title=\"1. 方案1\"></a>1. 方案1</h1><p>直接使用animator做动画<br>参考资料： <a href=\"https://github.com/Yasic/QQBubbleView\" target=\"_blank\" rel=\"external\">https://github.com/Yasic/QQBubbleView</a>  </p>\n<h3 id=\"1-1-优化方向：\"><a href=\"#1-1-优化方向：\" class=\"headerlink\" title=\"1.1. 优化方向：\"></a>1.1. 优化方向：</h3><ol>\n<li>削峰</li>\n<li>不要每次都inflate layout，尝试模拟listview的recycleBin 对用跑完动画的View 重新赋值初始化</li>\n</ol>\n<h2 id=\"2-方案2：\"><a href=\"#2-方案2：\" class=\"headerlink\" title=\"2. 方案2：\"></a>2. 方案2：</h2><p>直接在View上绘制爱心<br>参考资料：<a href=\"https://github.com/HomHomLin/Android-DivergeView\" target=\"_blank\" rel=\"external\">https://github.com/HomHomLin/Android-DivergeView</a><br>核心就是一个while循环，不断计算当前爱心的位置</p>\n<pre><code>while (mRunning) {\n    if (mQueen == null) {\n        continue;\n    }\n    if (mIsDrawing) {\n        //如果正在绘制，不要处理数据\n        continue;\n    }\n    dealQueen();\n    dealDiverge();\n    mIsDrawing = true;\n    postInvalidate();\n}\n</code></pre><p>在dealQueen里面处理正在等待走动画的点赞  </p>\n<pre><code>if (mQueen.size() &gt; 0 &amp;&amp; now - mLastAddTime &gt; mQueenDuration) {\n        mLastAddTime = System.currentTimeMillis();\n        DivergeInfo divergeInfo = null;\n        if (mDeadPool.size() &gt; 0) {\n            //死池里面有空闲的divergeNode\n            divergeInfo = mDeadPool.get(0);\n            mDeadPool.remove(0);\n        }\n        if (divergeInfo == null) {\n            divergeInfo = createDivergeNode(mQueen.get(0));\n        }\n        divergeInfo.reset();\n        divergeInfo.mType = mQueen.get(0);\n        mDivergeInfos.add(divergeInfo);\n        mQueen.remove(0);\n    }\n</code></pre><p>在dealDiverge里面计算已经在走动画的爱心的位置  </p>\n<pre><code>for (int i = 0; i &lt; mDivergeInfos.size(); i++) {\n       DivergeInfo divergeInfo = mDivergeInfos.get(i);\n       float timeLeft = 1.0F - divergeInfo.mDuration;\n       divergeInfo.mDuration += mDuration;\n       float x, y;\n       //二次贝塞尔\n       float time1 = timeLeft * timeLeft;\n       float time2 = 2 * timeLeft * divergeInfo.mDuration;\n       float time3 = divergeInfo.mDuration * divergeInfo.mDuration;\n       x = time1 * (mPtStart.x)\n               + time2 * (divergeInfo.mBreakPoint.x)\n               + time3 * (divergeInfo.mEndPoint.x);\n\n       divergeInfo.mX = x;\n\n       y = time1 * (mPtStart.y)\n               + time2 * (divergeInfo.mBreakPoint.y)\n               + time3 * (divergeInfo.mEndPoint.y);\n\n       divergeInfo.mY = y;\n\n       if (divergeInfo.mY &lt;= divergeInfo.mEndPoint.y) {\n           mDivergeInfos.remove(i);\n           mDeadPool.add(divergeInfo);\n           i--;\n           continue;\n       }\n   }\n</code></pre><p>onDraw方法</p>\n<pre><code>for (DivergeInfo divergeInfo : mDivergeInfos) {\n          mPaint.setAlpha((int) (255 * divergeInfo.mY / mPtStart.y));\n          Bitmap bm = mDivergeViewProvider.getBitmap(divergeInfo.mType);\n          float originCenterX = divergeInfo.mX + bm.getWidth() / 2;\n          float originCenterY = divergeInfo.mY + bm.getHeight() / 2;\n          float scaleWidth, scaleHeight;               \n          scaleWidth = bm.getWidth();\n          scaleHeight = bm.getHeight();\n          RectF destRect = new RectF(originCenterX - scaleWidth / 2, originCenterY - scaleHeight / 2,\n                  originCenterX + scaleWidth / 2, originCenterY + scaleHeight / 2);\n          canvas.drawBitmap(bm, null\n                  , destRect,\n                  mPaint);\n      }\n mIsDrawing = false;\n</code></pre><p>ps：映客的点赞爱心就是这么实现的（映客是本地点赞出爱心，这个直接分析元素会失败，可以进入直播后，断网然后分析元素）</p>\n<h3 id=\"2-1-优化方向：\"><a href=\"#2-1-优化方向：\" class=\"headerlink\" title=\"2.1. 优化方向：\"></a>2.1. 优化方向：</h3><ol>\n<li>停止爱心动画的时机（什么时候可以停止while循环）</li>\n<li>削峰：Android 每隔 16.6 ms 刷新一次屏幕，可以根据这个计算一次主流机型阈值</li>\n</ol>\n<p>都需要利用到削峰</p>\n<h1 id=\"额外知识点\"><a href=\"#额外知识点\" class=\"headerlink\" title=\"额外知识点\"></a>额外知识点</h1><p>二阶贝塞尔曲线公式：<br><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D317/sign=9aefef4b08f79052eb1f413f3bf2d738/11385343fbf2b21129581916cb8065380cd78e70.jpg\" alt=\"二阶\">    </p>\n<p>三阶贝塞尔曲线公式：<br><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D421/sign=9a6521eab8014a90853e47bf98763971/f603918fa0ec08fad54f8dff58ee3d6d55fbda1f.jpg\" alt=\"三阶\">    </p>\n<p>在线演示：<a href=\"http://myst729.github.io/bezier-curve/\" target=\"_blank\" rel=\"external\">http://myst729.github.io/bezier-curve/</a></p>\n","excerpt":"","more":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p> 实现直播房间点赞爱心动画（不是送礼物的动画）<br> 难点：流畅的飘爱心</p>\n<h1 id=\"1-方案1\"><a href=\"#1-方案1\" class=\"headerlink\" title=\"1. 方案1\"></a>1. 方案1</h1><p>直接使用animator做动画<br>参考资料： <a href=\"https://github.com/Yasic/QQBubbleView\">https://github.com/Yasic/QQBubbleView</a>  </p>\n<h3 id=\"1-1-优化方向：\"><a href=\"#1-1-优化方向：\" class=\"headerlink\" title=\"1.1. 优化方向：\"></a>1.1. 优化方向：</h3><ol>\n<li>削峰</li>\n<li>不要每次都inflate layout，尝试模拟listview的recycleBin 对用跑完动画的View 重新赋值初始化</li>\n</ol>\n<h2 id=\"2-方案2：\"><a href=\"#2-方案2：\" class=\"headerlink\" title=\"2. 方案2：\"></a>2. 方案2：</h2><p>直接在View上绘制爱心<br>参考资料：<a href=\"https://github.com/HomHomLin/Android-DivergeView\">https://github.com/HomHomLin/Android-DivergeView</a><br>核心就是一个while循环，不断计算当前爱心的位置</p>\n<pre><code>while (mRunning) {\n    if (mQueen == null) {\n        continue;\n    }\n    if (mIsDrawing) {\n        //如果正在绘制，不要处理数据\n        continue;\n    }\n    dealQueen();\n    dealDiverge();\n    mIsDrawing = true;\n    postInvalidate();\n}\n</code></pre><p>在dealQueen里面处理正在等待走动画的点赞  </p>\n<pre><code>if (mQueen.size() &gt; 0 &amp;&amp; now - mLastAddTime &gt; mQueenDuration) {\n        mLastAddTime = System.currentTimeMillis();\n        DivergeInfo divergeInfo = null;\n        if (mDeadPool.size() &gt; 0) {\n            //死池里面有空闲的divergeNode\n            divergeInfo = mDeadPool.get(0);\n            mDeadPool.remove(0);\n        }\n        if (divergeInfo == null) {\n            divergeInfo = createDivergeNode(mQueen.get(0));\n        }\n        divergeInfo.reset();\n        divergeInfo.mType = mQueen.get(0);\n        mDivergeInfos.add(divergeInfo);\n        mQueen.remove(0);\n    }\n</code></pre><p>在dealDiverge里面计算已经在走动画的爱心的位置  </p>\n<pre><code>for (int i = 0; i &lt; mDivergeInfos.size(); i++) {\n       DivergeInfo divergeInfo = mDivergeInfos.get(i);\n       float timeLeft = 1.0F - divergeInfo.mDuration;\n       divergeInfo.mDuration += mDuration;\n       float x, y;\n       //二次贝塞尔\n       float time1 = timeLeft * timeLeft;\n       float time2 = 2 * timeLeft * divergeInfo.mDuration;\n       float time3 = divergeInfo.mDuration * divergeInfo.mDuration;\n       x = time1 * (mPtStart.x)\n               + time2 * (divergeInfo.mBreakPoint.x)\n               + time3 * (divergeInfo.mEndPoint.x);\n\n       divergeInfo.mX = x;\n\n       y = time1 * (mPtStart.y)\n               + time2 * (divergeInfo.mBreakPoint.y)\n               + time3 * (divergeInfo.mEndPoint.y);\n\n       divergeInfo.mY = y;\n\n       if (divergeInfo.mY &lt;= divergeInfo.mEndPoint.y) {\n           mDivergeInfos.remove(i);\n           mDeadPool.add(divergeInfo);\n           i--;\n           continue;\n       }\n   }\n</code></pre><p>onDraw方法</p>\n<pre><code>for (DivergeInfo divergeInfo : mDivergeInfos) {\n          mPaint.setAlpha((int) (255 * divergeInfo.mY / mPtStart.y));\n          Bitmap bm = mDivergeViewProvider.getBitmap(divergeInfo.mType);\n          float originCenterX = divergeInfo.mX + bm.getWidth() / 2;\n          float originCenterY = divergeInfo.mY + bm.getHeight() / 2;\n          float scaleWidth, scaleHeight;               \n          scaleWidth = bm.getWidth();\n          scaleHeight = bm.getHeight();\n          RectF destRect = new RectF(originCenterX - scaleWidth / 2, originCenterY - scaleHeight / 2,\n                  originCenterX + scaleWidth / 2, originCenterY + scaleHeight / 2);\n          canvas.drawBitmap(bm, null\n                  , destRect,\n                  mPaint);\n      }\n mIsDrawing = false;\n</code></pre><p>ps：映客的点赞爱心就是这么实现的（映客是本地点赞出爱心，这个直接分析元素会失败，可以进入直播后，断网然后分析元素）</p>\n<h3 id=\"2-1-优化方向：\"><a href=\"#2-1-优化方向：\" class=\"headerlink\" title=\"2.1. 优化方向：\"></a>2.1. 优化方向：</h3><ol>\n<li>停止爱心动画的时机（什么时候可以停止while循环）</li>\n<li>削峰：Android 每隔 16.6 ms 刷新一次屏幕，可以根据这个计算一次主流机型阈值</li>\n</ol>\n<p>都需要利用到削峰</p>\n<h1 id=\"额外知识点\"><a href=\"#额外知识点\" class=\"headerlink\" title=\"额外知识点\"></a>额外知识点</h1><p>二阶贝塞尔曲线公式：<br><img src=\"https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D317/sign=9aefef4b08f79052eb1f413f3bf2d738/11385343fbf2b21129581916cb8065380cd78e70.jpg\" alt=\"二阶\">    </p>\n<p>三阶贝塞尔曲线公式：<br><img src=\"https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D421/sign=9a6521eab8014a90853e47bf98763971/f603918fa0ec08fad54f8dff58ee3d6d55fbda1f.jpg\" alt=\"三阶\">    </p>\n<p>在线演示：<a href=\"http://myst729.github.io/bezier-curve/\">http://myst729.github.io/bezier-curve/</a></p>\n"},{"title":"数据统计和分析","date":"2018-02-14T16:00:00.000Z","_content":"\n\n# 1. Umeng高阶功能：  \n\n## 1.1 umeng 在线参数    \n可以用于 初始化接口以及A/B测试 \n（现在已经更新为plus  原在线参数功能不再接入新的App   http://bbs.umeng.comthread-15553-1-1.html）\n\n\n## 1.2 Umeng 用户时长分析\n用户参与度 > 使用时长：  \n可以具体分析到某一天的ge个使用时长用户的占比  (可以选择一个月前同一天对比)  \n单次使用时长的过短就说明首页的分发，效果差。\n\n\n## 1.3 用户活跃度  \n留存分析 > 用户活跃度:  \n具体看一天各个用户群体的占比情况\n（看几天活跃用户）\n\n## 1.4 功能使用\n页面访问路径：看到用户的访问路径\n自定义事件\n\n\n\n# 2. growingIO  \n号称无埋点，但是要收费\n\n## 2.1 热区 \n可以具体看到一个界面的用户点击的热点区域\n\n\n# 3. 自定义pv统计\n核心点在与统计用户看见了哪些东西\n## 3.1 长容器统计\n 1. 在容器停止滚动时候查看view的在屏幕的显示区域是在屏幕范围内  \n \n         view.getLocationOnScreen(locations);  \n\n露出1/3即可算看见了\n\n2. 滚动停止就统计一次（如果一直不滚动就始终算1一次pv），另外10s只统计一次（防止用户来回滚动）","source":"_posts/用户数据统计和行为分析.md","raw":"title: 数据统计和分析\ndate: 2018-2-15 \ncategories:\n- Android\ntags:\n- Android\n- 数据统计\n- 运营\n\n---\n\n\n# 1. Umeng高阶功能：  \n\n## 1.1 umeng 在线参数    \n可以用于 初始化接口以及A/B测试 \n（现在已经更新为plus  原在线参数功能不再接入新的App   http://bbs.umeng.comthread-15553-1-1.html）\n\n\n## 1.2 Umeng 用户时长分析\n用户参与度 > 使用时长：  \n可以具体分析到某一天的ge个使用时长用户的占比  (可以选择一个月前同一天对比)  \n单次使用时长的过短就说明首页的分发，效果差。\n\n\n## 1.3 用户活跃度  \n留存分析 > 用户活跃度:  \n具体看一天各个用户群体的占比情况\n（看几天活跃用户）\n\n## 1.4 功能使用\n页面访问路径：看到用户的访问路径\n自定义事件\n\n\n\n# 2. growingIO  \n号称无埋点，但是要收费\n\n## 2.1 热区 \n可以具体看到一个界面的用户点击的热点区域\n\n\n# 3. 自定义pv统计\n核心点在与统计用户看见了哪些东西\n## 3.1 长容器统计\n 1. 在容器停止滚动时候查看view的在屏幕的显示区域是在屏幕范围内  \n \n         view.getLocationOnScreen(locations);  \n\n露出1/3即可算看见了\n\n2. 滚动停止就统计一次（如果一直不滚动就始终算1一次pv），另外10s只统计一次（防止用户来回滚动）","slug":"用户数据统计和行为分析","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06ldn002hsfjfaam1a5u4","content":"<h1 id=\"1-Umeng高阶功能：\"><a href=\"#1-Umeng高阶功能：\" class=\"headerlink\" title=\"1. Umeng高阶功能：\"></a>1. Umeng高阶功能：</h1><h2 id=\"1-1-umeng-在线参数\"><a href=\"#1-1-umeng-在线参数\" class=\"headerlink\" title=\"1.1 umeng 在线参数\"></a>1.1 umeng 在线参数</h2><p>可以用于 初始化接口以及A/B测试<br>（现在已经更新为plus  原在线参数功能不再接入新的App   <a href=\"http://bbs.umeng.comthread-15553-1-1.html）\" target=\"_blank\" rel=\"external\">http://bbs.umeng.comthread-15553-1-1.html）</a></p>\n<h2 id=\"1-2-Umeng-用户时长分析\"><a href=\"#1-2-Umeng-用户时长分析\" class=\"headerlink\" title=\"1.2 Umeng 用户时长分析\"></a>1.2 Umeng 用户时长分析</h2><p>用户参与度 &gt; 使用时长：<br>可以具体分析到某一天的ge个使用时长用户的占比  (可以选择一个月前同一天对比)<br>单次使用时长的过短就说明首页的分发，效果差。</p>\n<h2 id=\"1-3-用户活跃度\"><a href=\"#1-3-用户活跃度\" class=\"headerlink\" title=\"1.3 用户活跃度\"></a>1.3 用户活跃度</h2><p>留存分析 &gt; 用户活跃度:<br>具体看一天各个用户群体的占比情况<br>（看几天活跃用户）</p>\n<h2 id=\"1-4-功能使用\"><a href=\"#1-4-功能使用\" class=\"headerlink\" title=\"1.4 功能使用\"></a>1.4 功能使用</h2><p>页面访问路径：看到用户的访问路径<br>自定义事件</p>\n<h1 id=\"2-growingIO\"><a href=\"#2-growingIO\" class=\"headerlink\" title=\"2. growingIO\"></a>2. growingIO</h1><p>号称无埋点，但是要收费</p>\n<h2 id=\"2-1-热区\"><a href=\"#2-1-热区\" class=\"headerlink\" title=\"2.1 热区\"></a>2.1 热区</h2><p>可以具体看到一个界面的用户点击的热点区域</p>\n<h1 id=\"3-自定义pv统计\"><a href=\"#3-自定义pv统计\" class=\"headerlink\" title=\"3. 自定义pv统计\"></a>3. 自定义pv统计</h1><p>核心点在与统计用户看见了哪些东西</p>\n<h2 id=\"3-1-长容器统计\"><a href=\"#3-1-长容器统计\" class=\"headerlink\" title=\"3.1 长容器统计\"></a>3.1 长容器统计</h2><ol>\n<li><p>在容器停止滚动时候查看view的在屏幕的显示区域是在屏幕范围内  </p>\n<pre><code>view.getLocationOnScreen(locations);  \n</code></pre></li>\n</ol>\n<p>露出1/3即可算看见了</p>\n<ol>\n<li>滚动停止就统计一次（如果一直不滚动就始终算1一次pv），另外10s只统计一次（防止用户来回滚动）</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"1-Umeng高阶功能：\"><a href=\"#1-Umeng高阶功能：\" class=\"headerlink\" title=\"1. Umeng高阶功能：\"></a>1. Umeng高阶功能：</h1><h2 id=\"1-1-umeng-在线参数\"><a href=\"#1-1-umeng-在线参数\" class=\"headerlink\" title=\"1.1 umeng 在线参数\"></a>1.1 umeng 在线参数</h2><p>可以用于 初始化接口以及A/B测试<br>（现在已经更新为plus  原在线参数功能不再接入新的App   <a href=\"http://bbs.umeng.comthread-15553-1-1.html）\">http://bbs.umeng.comthread-15553-1-1.html）</a></p>\n<h2 id=\"1-2-Umeng-用户时长分析\"><a href=\"#1-2-Umeng-用户时长分析\" class=\"headerlink\" title=\"1.2 Umeng 用户时长分析\"></a>1.2 Umeng 用户时长分析</h2><p>用户参与度 &gt; 使用时长：<br>可以具体分析到某一天的ge个使用时长用户的占比  (可以选择一个月前同一天对比)<br>单次使用时长的过短就说明首页的分发，效果差。</p>\n<h2 id=\"1-3-用户活跃度\"><a href=\"#1-3-用户活跃度\" class=\"headerlink\" title=\"1.3 用户活跃度\"></a>1.3 用户活跃度</h2><p>留存分析 &gt; 用户活跃度:<br>具体看一天各个用户群体的占比情况<br>（看几天活跃用户）</p>\n<h2 id=\"1-4-功能使用\"><a href=\"#1-4-功能使用\" class=\"headerlink\" title=\"1.4 功能使用\"></a>1.4 功能使用</h2><p>页面访问路径：看到用户的访问路径<br>自定义事件</p>\n<h1 id=\"2-growingIO\"><a href=\"#2-growingIO\" class=\"headerlink\" title=\"2. growingIO\"></a>2. growingIO</h1><p>号称无埋点，但是要收费</p>\n<h2 id=\"2-1-热区\"><a href=\"#2-1-热区\" class=\"headerlink\" title=\"2.1 热区\"></a>2.1 热区</h2><p>可以具体看到一个界面的用户点击的热点区域</p>\n<h1 id=\"3-自定义pv统计\"><a href=\"#3-自定义pv统计\" class=\"headerlink\" title=\"3. 自定义pv统计\"></a>3. 自定义pv统计</h1><p>核心点在与统计用户看见了哪些东西</p>\n<h2 id=\"3-1-长容器统计\"><a href=\"#3-1-长容器统计\" class=\"headerlink\" title=\"3.1 长容器统计\"></a>3.1 长容器统计</h2><ol>\n<li><p>在容器停止滚动时候查看view的在屏幕的显示区域是在屏幕范围内  </p>\n<pre><code>view.getLocationOnScreen(locations);  \n</code></pre></li>\n</ol>\n<p>露出1/3即可算看见了</p>\n<ol>\n<li>滚动停止就统计一次（如果一直不滚动就始终算1一次pv），另外10s只统计一次（防止用户来回滚动）</li>\n</ol>\n"},{"title":"生成分享图片","date":"2018-02-09T16:00:00.000Z","_content":"\n\n## 方法1\n### 1.1 截取Activity  \n\n     public static Bitmap takeScreenShot(Activity activity) {\n            View view = activity.getWindow().getDecorView();\n            if (view == null) {\n                return null;\n            }\n            view.setDrawingCacheEnabled(true);\n            view.buildDrawingCache();\n            Bitmap b1 = view.getDrawingCache();\n            if (b1 == null) {\n                return null;\n            }\n            // 获取状态栏高度\n            Rect frame = new Rect();\n            activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);\n            int statusBarHeight = frame.top;\n\n            // 获取屏幕长和高\n            int width = activity.getWindowManager().getDefaultDisplay().getWidth();\n\n            Bitmap b = Bitmap.createBitmap(b1, 0, statusBarHeight, width, b1.getHeight() - statusBarHeight);\n            view.destroyDrawingCache();\n            b1.recycle();\n            return b;\n        }\n\n### 1.3 截取ViewGroup\n\n     public static Bitmap takeScreenShotView(LinnerLayout viewGroup) {\n            Bitmap bitmap = null;\n            if (viewGroup != null) {\n                int h = 0;\n                for (int i = 0; i < viewGroup.getChildCount(); i++) {\n                    h += viewGroup.getChildAt(i).getHeight();\n                }\n                if (viewGroup.getHeight() > h) {\n                    h = viewGroup.getHeight();\n                }\n                bitmap = Bitmap.createBitmap(viewGroup.getWidth(), h, Config.ARGB_8888);\n                final Canvas c = new Canvas(bitmap);\n                c.drawColor(Color.WHITE);\n                viewGroup.draw(c);\n            }\n            return bitmap;\n        }\n\n## 方法2  \n自己生成bitmap绘制，这个地方由于自己绘制的比较麻烦，一般就是在一张图片上绘制一些文字即可\n\n\n\n\n\n## 方法3\n生成未加载的布局文件的分享图片\n\n\n         View targetView = LayoutInflater.from(mActivity).inflate(R.layout.view_share, null);\n         targetView.measure(View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY),      View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY));\n         targetView.layout(0, 0, width, height);\n         bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Config.ARGB_8888);\n         Canvas canvas = new Canvas(bitmap);\n         canvas.drawColor(Color.WHITE);\n         view.draw(canvas);\n\n核心是布局文件没有加载，也即没有measure和layout 就无法进行绘制（实际上一个view之所以能被绘制上去就是因为父容器measure和layout了它）才能进行绘制\n\n一个知识点： view 不是不可以在后台线程修改的，而是需只有原始创建这个视图层次(view hierachy)的线程才能修改它的视图(view)\n\n\n## 扩展思维  \n如何生成listview和recycleView的截屏   \n### 方案1 \n原理：我们可以知道第一个和最后一个view在屏幕上的位置，也可以获取获取整个屏幕的截图，所谓我们可以滑动一屏截取一屏(我们可以估算出一屏大约有多少元素，滚动固定长度即可)的内容，然后最后拼接出来  \n\n### 方案2\n原理：可以逐个生成itemView的bitmap（采用方法3），然后拼接出来\n\n","source":"_posts/生成分享图片.md","raw":"title: 生成分享图片\ndate: 2018-2-10 \ncategories:\n- Android\ntags:\n- Android\n- 分享图片\n\n---\n\n\n## 方法1\n### 1.1 截取Activity  \n\n     public static Bitmap takeScreenShot(Activity activity) {\n            View view = activity.getWindow().getDecorView();\n            if (view == null) {\n                return null;\n            }\n            view.setDrawingCacheEnabled(true);\n            view.buildDrawingCache();\n            Bitmap b1 = view.getDrawingCache();\n            if (b1 == null) {\n                return null;\n            }\n            // 获取状态栏高度\n            Rect frame = new Rect();\n            activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);\n            int statusBarHeight = frame.top;\n\n            // 获取屏幕长和高\n            int width = activity.getWindowManager().getDefaultDisplay().getWidth();\n\n            Bitmap b = Bitmap.createBitmap(b1, 0, statusBarHeight, width, b1.getHeight() - statusBarHeight);\n            view.destroyDrawingCache();\n            b1.recycle();\n            return b;\n        }\n\n### 1.3 截取ViewGroup\n\n     public static Bitmap takeScreenShotView(LinnerLayout viewGroup) {\n            Bitmap bitmap = null;\n            if (viewGroup != null) {\n                int h = 0;\n                for (int i = 0; i < viewGroup.getChildCount(); i++) {\n                    h += viewGroup.getChildAt(i).getHeight();\n                }\n                if (viewGroup.getHeight() > h) {\n                    h = viewGroup.getHeight();\n                }\n                bitmap = Bitmap.createBitmap(viewGroup.getWidth(), h, Config.ARGB_8888);\n                final Canvas c = new Canvas(bitmap);\n                c.drawColor(Color.WHITE);\n                viewGroup.draw(c);\n            }\n            return bitmap;\n        }\n\n## 方法2  \n自己生成bitmap绘制，这个地方由于自己绘制的比较麻烦，一般就是在一张图片上绘制一些文字即可\n\n\n\n\n\n## 方法3\n生成未加载的布局文件的分享图片\n\n\n         View targetView = LayoutInflater.from(mActivity).inflate(R.layout.view_share, null);\n         targetView.measure(View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY),      View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY));\n         targetView.layout(0, 0, width, height);\n         bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Config.ARGB_8888);\n         Canvas canvas = new Canvas(bitmap);\n         canvas.drawColor(Color.WHITE);\n         view.draw(canvas);\n\n核心是布局文件没有加载，也即没有measure和layout 就无法进行绘制（实际上一个view之所以能被绘制上去就是因为父容器measure和layout了它）才能进行绘制\n\n一个知识点： view 不是不可以在后台线程修改的，而是需只有原始创建这个视图层次(view hierachy)的线程才能修改它的视图(view)\n\n\n## 扩展思维  \n如何生成listview和recycleView的截屏   \n### 方案1 \n原理：我们可以知道第一个和最后一个view在屏幕上的位置，也可以获取获取整个屏幕的截图，所谓我们可以滑动一屏截取一屏(我们可以估算出一屏大约有多少元素，滚动固定长度即可)的内容，然后最后拼接出来  \n\n### 方案2\n原理：可以逐个生成itemView的bitmap（采用方法3），然后拼接出来\n\n","slug":"生成分享图片","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06ldp002jsfjfjtm7qyjq","content":"<h2 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><h3 id=\"1-1-截取Activity\"><a href=\"#1-1-截取Activity\" class=\"headerlink\" title=\"1.1 截取Activity\"></a>1.1 截取Activity</h3><pre><code>public static Bitmap takeScreenShot(Activity activity) {\n       View view = activity.getWindow().getDecorView();\n       if (view == null) {\n           return null;\n       }\n       view.setDrawingCacheEnabled(true);\n       view.buildDrawingCache();\n       Bitmap b1 = view.getDrawingCache();\n       if (b1 == null) {\n           return null;\n       }\n       // 获取状态栏高度\n       Rect frame = new Rect();\n       activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);\n       int statusBarHeight = frame.top;\n\n       // 获取屏幕长和高\n       int width = activity.getWindowManager().getDefaultDisplay().getWidth();\n\n       Bitmap b = Bitmap.createBitmap(b1, 0, statusBarHeight, width, b1.getHeight() - statusBarHeight);\n       view.destroyDrawingCache();\n       b1.recycle();\n       return b;\n   }\n</code></pre><h3 id=\"1-3-截取ViewGroup\"><a href=\"#1-3-截取ViewGroup\" class=\"headerlink\" title=\"1.3 截取ViewGroup\"></a>1.3 截取ViewGroup</h3><pre><code>public static Bitmap takeScreenShotView(LinnerLayout viewGroup) {\n       Bitmap bitmap = null;\n       if (viewGroup != null) {\n           int h = 0;\n           for (int i = 0; i &lt; viewGroup.getChildCount(); i++) {\n               h += viewGroup.getChildAt(i).getHeight();\n           }\n           if (viewGroup.getHeight() &gt; h) {\n               h = viewGroup.getHeight();\n           }\n           bitmap = Bitmap.createBitmap(viewGroup.getWidth(), h, Config.ARGB_8888);\n           final Canvas c = new Canvas(bitmap);\n           c.drawColor(Color.WHITE);\n           viewGroup.draw(c);\n       }\n       return bitmap;\n   }\n</code></pre><h2 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><p>自己生成bitmap绘制，这个地方由于自己绘制的比较麻烦，一般就是在一张图片上绘制一些文字即可</p>\n<h2 id=\"方法3\"><a href=\"#方法3\" class=\"headerlink\" title=\"方法3\"></a>方法3</h2><p>生成未加载的布局文件的分享图片</p>\n<pre><code>View targetView = LayoutInflater.from(mActivity).inflate(R.layout.view_share, null);\ntargetView.measure(View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY),      View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY));\ntargetView.layout(0, 0, width, height);\nbitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Config.ARGB_8888);\nCanvas canvas = new Canvas(bitmap);\ncanvas.drawColor(Color.WHITE);\nview.draw(canvas);\n</code></pre><p>核心是布局文件没有加载，也即没有measure和layout 就无法进行绘制（实际上一个view之所以能被绘制上去就是因为父容器measure和layout了它）才能进行绘制</p>\n<p>一个知识点： view 不是不可以在后台线程修改的，而是需只有原始创建这个视图层次(view hierachy)的线程才能修改它的视图(view)</p>\n<h2 id=\"扩展思维\"><a href=\"#扩展思维\" class=\"headerlink\" title=\"扩展思维\"></a>扩展思维</h2><p>如何生成listview和recycleView的截屏   </p>\n<h3 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h3><p>原理：我们可以知道第一个和最后一个view在屏幕上的位置，也可以获取获取整个屏幕的截图，所谓我们可以滑动一屏截取一屏(我们可以估算出一屏大约有多少元素，滚动固定长度即可)的内容，然后最后拼接出来  </p>\n<h3 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h3><p>原理：可以逐个生成itemView的bitmap（采用方法3），然后拼接出来</p>\n","excerpt":"","more":"<h2 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><h3 id=\"1-1-截取Activity\"><a href=\"#1-1-截取Activity\" class=\"headerlink\" title=\"1.1 截取Activity\"></a>1.1 截取Activity</h3><pre><code>public static Bitmap takeScreenShot(Activity activity) {\n       View view = activity.getWindow().getDecorView();\n       if (view == null) {\n           return null;\n       }\n       view.setDrawingCacheEnabled(true);\n       view.buildDrawingCache();\n       Bitmap b1 = view.getDrawingCache();\n       if (b1 == null) {\n           return null;\n       }\n       // 获取状态栏高度\n       Rect frame = new Rect();\n       activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);\n       int statusBarHeight = frame.top;\n\n       // 获取屏幕长和高\n       int width = activity.getWindowManager().getDefaultDisplay().getWidth();\n\n       Bitmap b = Bitmap.createBitmap(b1, 0, statusBarHeight, width, b1.getHeight() - statusBarHeight);\n       view.destroyDrawingCache();\n       b1.recycle();\n       return b;\n   }\n</code></pre><h3 id=\"1-3-截取ViewGroup\"><a href=\"#1-3-截取ViewGroup\" class=\"headerlink\" title=\"1.3 截取ViewGroup\"></a>1.3 截取ViewGroup</h3><pre><code>public static Bitmap takeScreenShotView(LinnerLayout viewGroup) {\n       Bitmap bitmap = null;\n       if (viewGroup != null) {\n           int h = 0;\n           for (int i = 0; i &lt; viewGroup.getChildCount(); i++) {\n               h += viewGroup.getChildAt(i).getHeight();\n           }\n           if (viewGroup.getHeight() &gt; h) {\n               h = viewGroup.getHeight();\n           }\n           bitmap = Bitmap.createBitmap(viewGroup.getWidth(), h, Config.ARGB_8888);\n           final Canvas c = new Canvas(bitmap);\n           c.drawColor(Color.WHITE);\n           viewGroup.draw(c);\n       }\n       return bitmap;\n   }\n</code></pre><h2 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><p>自己生成bitmap绘制，这个地方由于自己绘制的比较麻烦，一般就是在一张图片上绘制一些文字即可</p>\n<h2 id=\"方法3\"><a href=\"#方法3\" class=\"headerlink\" title=\"方法3\"></a>方法3</h2><p>生成未加载的布局文件的分享图片</p>\n<pre><code>View targetView = LayoutInflater.from(mActivity).inflate(R.layout.view_share, null);\ntargetView.measure(View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY),      View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY));\ntargetView.layout(0, 0, width, height);\nbitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Config.ARGB_8888);\nCanvas canvas = new Canvas(bitmap);\ncanvas.drawColor(Color.WHITE);\nview.draw(canvas);\n</code></pre><p>核心是布局文件没有加载，也即没有measure和layout 就无法进行绘制（实际上一个view之所以能被绘制上去就是因为父容器measure和layout了它）才能进行绘制</p>\n<p>一个知识点： view 不是不可以在后台线程修改的，而是需只有原始创建这个视图层次(view hierachy)的线程才能修改它的视图(view)</p>\n<h2 id=\"扩展思维\"><a href=\"#扩展思维\" class=\"headerlink\" title=\"扩展思维\"></a>扩展思维</h2><p>如何生成listview和recycleView的截屏   </p>\n<h3 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h3><p>原理：我们可以知道第一个和最后一个view在屏幕上的位置，也可以获取获取整个屏幕的截图，所谓我们可以滑动一屏截取一屏(我们可以估算出一屏大约有多少元素，滚动固定长度即可)的内容，然后最后拼接出来  </p>\n<h3 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h3><p>原理：可以逐个生成itemView的bitmap（采用方法3），然后拼接出来</p>\n"},{"title":"热补丁","date":"2015-11-01T12:10:33.000Z","_content":"\n\n## 核心两个部分\n### 1. hook部分  \nhook部分主要是使用反射调用补丁里面的内容\n\nhook部分的本质是提供对补丁方法调用的封装（主工程无法直接实例和调用补丁的方法），每次调用都是通过反射调用，传入activity，handler，callback进去。\n\n### 2. 补丁部分\n补丁实际上是java代码转的dex  \n它的工作有两种：网络取数据，构造生成view\n\n\n补丁部分构造view是通过hook部分传过来activity，然后用代码动态构造view，不涉及到任何布局文件，资源文件。  \n\n\n\n## hook的初始化及调用过程\n1. 初始化DexClassLoader  \n        \n        classLoader = new DexClassLoader(dexApkFilePath\n                    + dexName + \".apk\", context.getDir(\"dex\", Context.MODE_PRIVATE).getAbsolutePath(), null,\n                    context.getClassLoader().getParent());\n                    \n2. load补丁相应的class  \n        \n        controllerClass = classLoader.loadClass(\"com.nico.Controller\");\n\n3. 初始化构造函数\n        controllerConstrucor = controllerClass.getConstructor(new Class[]{Context.class, String.class, boolean.class});\n\n4. 实例化补丁里面的类\n    \n        controllerInstance = controllerConstrucor.newInstance(new Object[]{mContext});\n\n5. 通过初始化的实例controllerInstance来调用里面的方法  \n        \n        Method initController = controllerClass.getDeclaredMethod(\"initController\", new Class[]{String.class, String.class, String.class});\n        initController.setAccessible(true);\n        initController.invoke(controllerInstance, new Object[]{paramsA, paramsB, paramsC});\n\n## 补丁的升级\n\n1. 校验是否有新的版本升级\n2. 把新的补丁下载到本地sd卡中去\n3. 解压补丁到data/data/app.pkg/app_dex目录  \nZipManager.extNativeZipFile(mContext,\n                            mContext.getResources().getAssets().open(Utils.ZIP_NAME),\n                            cachePath, dexApkFilePath, lastVersion)\n4. 重新走一遍补丁的实例化过程（从DexLoader开始）\n\n## 坑\n1. 第一次安装，补丁放到asset目录下面\n2. 由于里面传入了activity，要注意销毁补丁里面的强引用\n\n## 其他\ndexclassloader : 可以加载apk文件中的字节码\npathclassloader : 只能加载文件目录下的apk文件中的classes\n\n## To Be Continue\n1. load补丁里面的资源文件 ,通过反射调用AssetManger里面的资源文件，把ID设置上去 \n\n            AssetManager assetManager = AssetManager.class.newInstance();  \n            Method addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class);  \n            addAssetPath.invoke(assetManager, libPath);  \n            Resources superRes = super.getResources();  \n            mRes = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());\n            \n2. 尝试使用mvp模式，把controllor从activity里面剥离开来，让所有contollor可以被热补丁，这要处理起来（可以把整个app轻量化）\n\n\n\n## 参考资料\n\nhttp://blog.csdn.net/wwj_748/article/details/46349781\n\nhttp://blog.csdn.net/yuanzeyao/article/details/42390431\n\nhttp://blog.csdn.net/u010386612/article/details/51077291\n\n\nhttp://blog.csdn.net/cn_foolishman/article/details/46874811\n","source":"_posts/简易java热补丁.md","raw":"title: 热补丁\ndate: 2015-11-01 20:10:33\ncategories:\n- Android\ntags:\n- Android\n- 热补丁\n---\n\n\n## 核心两个部分\n### 1. hook部分  \nhook部分主要是使用反射调用补丁里面的内容\n\nhook部分的本质是提供对补丁方法调用的封装（主工程无法直接实例和调用补丁的方法），每次调用都是通过反射调用，传入activity，handler，callback进去。\n\n### 2. 补丁部分\n补丁实际上是java代码转的dex  \n它的工作有两种：网络取数据，构造生成view\n\n\n补丁部分构造view是通过hook部分传过来activity，然后用代码动态构造view，不涉及到任何布局文件，资源文件。  \n\n\n\n## hook的初始化及调用过程\n1. 初始化DexClassLoader  \n        \n        classLoader = new DexClassLoader(dexApkFilePath\n                    + dexName + \".apk\", context.getDir(\"dex\", Context.MODE_PRIVATE).getAbsolutePath(), null,\n                    context.getClassLoader().getParent());\n                    \n2. load补丁相应的class  \n        \n        controllerClass = classLoader.loadClass(\"com.nico.Controller\");\n\n3. 初始化构造函数\n        controllerConstrucor = controllerClass.getConstructor(new Class[]{Context.class, String.class, boolean.class});\n\n4. 实例化补丁里面的类\n    \n        controllerInstance = controllerConstrucor.newInstance(new Object[]{mContext});\n\n5. 通过初始化的实例controllerInstance来调用里面的方法  \n        \n        Method initController = controllerClass.getDeclaredMethod(\"initController\", new Class[]{String.class, String.class, String.class});\n        initController.setAccessible(true);\n        initController.invoke(controllerInstance, new Object[]{paramsA, paramsB, paramsC});\n\n## 补丁的升级\n\n1. 校验是否有新的版本升级\n2. 把新的补丁下载到本地sd卡中去\n3. 解压补丁到data/data/app.pkg/app_dex目录  \nZipManager.extNativeZipFile(mContext,\n                            mContext.getResources().getAssets().open(Utils.ZIP_NAME),\n                            cachePath, dexApkFilePath, lastVersion)\n4. 重新走一遍补丁的实例化过程（从DexLoader开始）\n\n## 坑\n1. 第一次安装，补丁放到asset目录下面\n2. 由于里面传入了activity，要注意销毁补丁里面的强引用\n\n## 其他\ndexclassloader : 可以加载apk文件中的字节码\npathclassloader : 只能加载文件目录下的apk文件中的classes\n\n## To Be Continue\n1. load补丁里面的资源文件 ,通过反射调用AssetManger里面的资源文件，把ID设置上去 \n\n            AssetManager assetManager = AssetManager.class.newInstance();  \n            Method addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class);  \n            addAssetPath.invoke(assetManager, libPath);  \n            Resources superRes = super.getResources();  \n            mRes = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());\n            \n2. 尝试使用mvp模式，把controllor从activity里面剥离开来，让所有contollor可以被热补丁，这要处理起来（可以把整个app轻量化）\n\n\n\n## 参考资料\n\nhttp://blog.csdn.net/wwj_748/article/details/46349781\n\nhttp://blog.csdn.net/yuanzeyao/article/details/42390431\n\nhttp://blog.csdn.net/u010386612/article/details/51077291\n\n\nhttp://blog.csdn.net/cn_foolishman/article/details/46874811\n","slug":"简易java热补丁","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06ldr002nsfjftcrvbwph","content":"<h2 id=\"核心两个部分\"><a href=\"#核心两个部分\" class=\"headerlink\" title=\"核心两个部分\"></a>核心两个部分</h2><h3 id=\"1-hook部分\"><a href=\"#1-hook部分\" class=\"headerlink\" title=\"1. hook部分\"></a>1. hook部分</h3><p>hook部分主要是使用反射调用补丁里面的内容</p>\n<p>hook部分的本质是提供对补丁方法调用的封装（主工程无法直接实例和调用补丁的方法），每次调用都是通过反射调用，传入activity，handler，callback进去。</p>\n<h3 id=\"2-补丁部分\"><a href=\"#2-补丁部分\" class=\"headerlink\" title=\"2. 补丁部分\"></a>2. 补丁部分</h3><p>补丁实际上是java代码转的dex<br>它的工作有两种：网络取数据，构造生成view</p>\n<p>补丁部分构造view是通过hook部分传过来activity，然后用代码动态构造view，不涉及到任何布局文件，资源文件。  </p>\n<h2 id=\"hook的初始化及调用过程\"><a href=\"#hook的初始化及调用过程\" class=\"headerlink\" title=\"hook的初始化及调用过程\"></a>hook的初始化及调用过程</h2><ol>\n<li><p>初始化DexClassLoader  </p>\n<pre><code>classLoader = new DexClassLoader(dexApkFilePath\n            + dexName + &quot;.apk&quot;, context.getDir(&quot;dex&quot;, Context.MODE_PRIVATE).getAbsolutePath(), null,\n            context.getClassLoader().getParent());\n</code></pre></li>\n<li><p>load补丁相应的class  </p>\n<pre><code>controllerClass = classLoader.loadClass(&quot;com.nico.Controller&quot;);\n</code></pre></li>\n<li><p>初始化构造函数</p>\n<pre><code>controllerConstrucor = controllerClass.getConstructor(new Class[]{Context.class, String.class, boolean.class});\n</code></pre></li>\n<li><p>实例化补丁里面的类</p>\n<pre><code>controllerInstance = controllerConstrucor.newInstance(new Object[]{mContext});\n</code></pre></li>\n<li><p>通过初始化的实例controllerInstance来调用里面的方法  </p>\n<pre><code>Method initController = controllerClass.getDeclaredMethod(&quot;initController&quot;, new Class[]{String.class, String.class, String.class});\ninitController.setAccessible(true);\ninitController.invoke(controllerInstance, new Object[]{paramsA, paramsB, paramsC});\n</code></pre></li>\n</ol>\n<h2 id=\"补丁的升级\"><a href=\"#补丁的升级\" class=\"headerlink\" title=\"补丁的升级\"></a>补丁的升级</h2><ol>\n<li>校验是否有新的版本升级</li>\n<li>把新的补丁下载到本地sd卡中去</li>\n<li>解压补丁到data/data/app.pkg/app_dex目录<br>ZipManager.extNativeZipFile(mContext,<pre><code>mContext.getResources().getAssets().open(Utils.ZIP_NAME),\ncachePath, dexApkFilePath, lastVersion)\n</code></pre></li>\n<li>重新走一遍补丁的实例化过程（从DexLoader开始）</li>\n</ol>\n<h2 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h2><ol>\n<li>第一次安装，补丁放到asset目录下面</li>\n<li>由于里面传入了activity，要注意销毁补丁里面的强引用</li>\n</ol>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>dexclassloader : 可以加载apk文件中的字节码<br>pathclassloader : 只能加载文件目录下的apk文件中的classes</p>\n<h2 id=\"To-Be-Continue\"><a href=\"#To-Be-Continue\" class=\"headerlink\" title=\"To Be Continue\"></a>To Be Continue</h2><ol>\n<li><p>load补丁里面的资源文件 ,通过反射调用AssetManger里面的资源文件，把ID设置上去 </p>\n<pre><code>AssetManager assetManager = AssetManager.class.newInstance();  \nMethod addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);  \naddAssetPath.invoke(assetManager, libPath);  \nResources superRes = super.getResources();  \nmRes = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());\n</code></pre></li>\n<li><p>尝试使用mvp模式，把controllor从activity里面剥离开来，让所有contollor可以被热补丁，这要处理起来（可以把整个app轻量化）</p>\n</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.csdn.net/wwj_748/article/details/46349781\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/wwj_748/article/details/46349781</a></p>\n<p><a href=\"http://blog.csdn.net/yuanzeyao/article/details/42390431\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/yuanzeyao/article/details/42390431</a></p>\n<p><a href=\"http://blog.csdn.net/u010386612/article/details/51077291\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u010386612/article/details/51077291</a></p>\n<p><a href=\"http://blog.csdn.net/cn_foolishman/article/details/46874811\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/cn_foolishman/article/details/46874811</a></p>\n","excerpt":"","more":"<h2 id=\"核心两个部分\"><a href=\"#核心两个部分\" class=\"headerlink\" title=\"核心两个部分\"></a>核心两个部分</h2><h3 id=\"1-hook部分\"><a href=\"#1-hook部分\" class=\"headerlink\" title=\"1. hook部分\"></a>1. hook部分</h3><p>hook部分主要是使用反射调用补丁里面的内容</p>\n<p>hook部分的本质是提供对补丁方法调用的封装（主工程无法直接实例和调用补丁的方法），每次调用都是通过反射调用，传入activity，handler，callback进去。</p>\n<h3 id=\"2-补丁部分\"><a href=\"#2-补丁部分\" class=\"headerlink\" title=\"2. 补丁部分\"></a>2. 补丁部分</h3><p>补丁实际上是java代码转的dex<br>它的工作有两种：网络取数据，构造生成view</p>\n<p>补丁部分构造view是通过hook部分传过来activity，然后用代码动态构造view，不涉及到任何布局文件，资源文件。  </p>\n<h2 id=\"hook的初始化及调用过程\"><a href=\"#hook的初始化及调用过程\" class=\"headerlink\" title=\"hook的初始化及调用过程\"></a>hook的初始化及调用过程</h2><ol>\n<li><p>初始化DexClassLoader  </p>\n<pre><code>classLoader = new DexClassLoader(dexApkFilePath\n            + dexName + &quot;.apk&quot;, context.getDir(&quot;dex&quot;, Context.MODE_PRIVATE).getAbsolutePath(), null,\n            context.getClassLoader().getParent());\n</code></pre></li>\n<li><p>load补丁相应的class  </p>\n<pre><code>controllerClass = classLoader.loadClass(&quot;com.nico.Controller&quot;);\n</code></pre></li>\n<li><p>初始化构造函数</p>\n<pre><code>controllerConstrucor = controllerClass.getConstructor(new Class[]{Context.class, String.class, boolean.class});\n</code></pre></li>\n<li><p>实例化补丁里面的类</p>\n<pre><code>controllerInstance = controllerConstrucor.newInstance(new Object[]{mContext});\n</code></pre></li>\n<li><p>通过初始化的实例controllerInstance来调用里面的方法  </p>\n<pre><code>Method initController = controllerClass.getDeclaredMethod(&quot;initController&quot;, new Class[]{String.class, String.class, String.class});\ninitController.setAccessible(true);\ninitController.invoke(controllerInstance, new Object[]{paramsA, paramsB, paramsC});\n</code></pre></li>\n</ol>\n<h2 id=\"补丁的升级\"><a href=\"#补丁的升级\" class=\"headerlink\" title=\"补丁的升级\"></a>补丁的升级</h2><ol>\n<li>校验是否有新的版本升级</li>\n<li>把新的补丁下载到本地sd卡中去</li>\n<li>解压补丁到data/data/app.pkg/app_dex目录<br>ZipManager.extNativeZipFile(mContext,<pre><code>mContext.getResources().getAssets().open(Utils.ZIP_NAME),\ncachePath, dexApkFilePath, lastVersion)\n</code></pre></li>\n<li>重新走一遍补丁的实例化过程（从DexLoader开始）</li>\n</ol>\n<h2 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h2><ol>\n<li>第一次安装，补丁放到asset目录下面</li>\n<li>由于里面传入了activity，要注意销毁补丁里面的强引用</li>\n</ol>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>dexclassloader : 可以加载apk文件中的字节码<br>pathclassloader : 只能加载文件目录下的apk文件中的classes</p>\n<h2 id=\"To-Be-Continue\"><a href=\"#To-Be-Continue\" class=\"headerlink\" title=\"To Be Continue\"></a>To Be Continue</h2><ol>\n<li><p>load补丁里面的资源文件 ,通过反射调用AssetManger里面的资源文件，把ID设置上去 </p>\n<pre><code>AssetManager assetManager = AssetManager.class.newInstance();  \nMethod addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);  \naddAssetPath.invoke(assetManager, libPath);  \nResources superRes = super.getResources();  \nmRes = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());\n</code></pre></li>\n<li><p>尝试使用mvp模式，把controllor从activity里面剥离开来，让所有contollor可以被热补丁，这要处理起来（可以把整个app轻量化）</p>\n</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.csdn.net/wwj_748/article/details/46349781\">http://blog.csdn.net/wwj_748/article/details/46349781</a></p>\n<p><a href=\"http://blog.csdn.net/yuanzeyao/article/details/42390431\">http://blog.csdn.net/yuanzeyao/article/details/42390431</a></p>\n<p><a href=\"http://blog.csdn.net/u010386612/article/details/51077291\">http://blog.csdn.net/u010386612/article/details/51077291</a></p>\n<p><a href=\"http://blog.csdn.net/cn_foolishman/article/details/46874811\">http://blog.csdn.net/cn_foolishman/article/details/46874811</a></p>\n"},{"title":"首页Cache导致崩溃","date":"2018-02-13T12:10:33.000Z","_content":"\n# 场景  \n由于首页cache错误导致Crash，然后每次启动都必crash（因为首先读取的是cache）  \n# 方案  \n## step1：全局crash 捕获  \n    实现UncaughtExceptionHandler\n    \n    \n\tmDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\n\tThread.setDefaultUncaughtExceptionHandler(this);\n\t \n\t \n参考资料: http://blog.csdn.net/luck_apple/article/details/7768064\n\n## step2: 记录\n记录crash 信息到本地（时间,连续次数）\n\n## step3: 第一个界面判断\n如果判断连续次数达到一定数量，直接跳往BugFix界面，上传错误信息，同时服务器配合打热补丁\n这个地方需要区别错误类型进行更细致的修复\n","source":"_posts/首页崩溃解决方案.md","raw":"title: 首页Cache导致崩溃\ndate: 2018-2-13 20:10:33\ncategories:\n- Android\ntags:\n- Android\n- 崩溃\n\n---\n\n# 场景  \n由于首页cache错误导致Crash，然后每次启动都必crash（因为首先读取的是cache）  \n# 方案  \n## step1：全局crash 捕获  \n    实现UncaughtExceptionHandler\n    \n    \n\tmDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\n\tThread.setDefaultUncaughtExceptionHandler(this);\n\t \n\t \n参考资料: http://blog.csdn.net/luck_apple/article/details/7768064\n\n## step2: 记录\n记录crash 信息到本地（时间,连续次数）\n\n## step3: 第一个界面判断\n如果判断连续次数达到一定数量，直接跳往BugFix界面，上传错误信息，同时服务器配合打热补丁\n这个地方需要区别错误类型进行更细致的修复\n","slug":"首页崩溃解决方案","published":1,"updated":"2018-03-04T16:20:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjed06lds002qsfjfw08dsodx","content":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>由于首页cache错误导致Crash，然后每次启动都必crash（因为首先读取的是cache）  </p>\n<h1 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h1><h2 id=\"step1：全局crash-捕获\"><a href=\"#step1：全局crash-捕获\" class=\"headerlink\" title=\"step1：全局crash 捕获\"></a>step1：全局crash 捕获</h2><pre><code>实现UncaughtExceptionHandler\n\n\nmDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\nThread.setDefaultUncaughtExceptionHandler(this);\n</code></pre><p>参考资料: <a href=\"http://blog.csdn.net/luck_apple/article/details/7768064\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/luck_apple/article/details/7768064</a></p>\n<h2 id=\"step2-记录\"><a href=\"#step2-记录\" class=\"headerlink\" title=\"step2: 记录\"></a>step2: 记录</h2><p>记录crash 信息到本地（时间,连续次数）</p>\n<h2 id=\"step3-第一个界面判断\"><a href=\"#step3-第一个界面判断\" class=\"headerlink\" title=\"step3: 第一个界面判断\"></a>step3: 第一个界面判断</h2><p>如果判断连续次数达到一定数量，直接跳往BugFix界面，上传错误信息，同时服务器配合打热补丁<br>这个地方需要区别错误类型进行更细致的修复</p>\n","excerpt":"","more":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>由于首页cache错误导致Crash，然后每次启动都必crash（因为首先读取的是cache）  </p>\n<h1 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h1><h2 id=\"step1：全局crash-捕获\"><a href=\"#step1：全局crash-捕获\" class=\"headerlink\" title=\"step1：全局crash 捕获\"></a>step1：全局crash 捕获</h2><pre><code>实现UncaughtExceptionHandler\n\n\nmDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\nThread.setDefaultUncaughtExceptionHandler(this);\n</code></pre><p>参考资料: <a href=\"http://blog.csdn.net/luck_apple/article/details/7768064\">http://blog.csdn.net/luck_apple/article/details/7768064</a></p>\n<h2 id=\"step2-记录\"><a href=\"#step2-记录\" class=\"headerlink\" title=\"step2: 记录\"></a>step2: 记录</h2><p>记录crash 信息到本地（时间,连续次数）</p>\n<h2 id=\"step3-第一个界面判断\"><a href=\"#step3-第一个界面判断\" class=\"headerlink\" title=\"step3: 第一个界面判断\"></a>step3: 第一个界面判断</h2><p>如果判断连续次数达到一定数量，直接跳往BugFix界面，上传错误信息，同时服务器配合打热补丁<br>这个地方需要区别错误类型进行更细致的修复</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjed06lb10005sfjf6ijgd6pt","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06lbc000asfjfxsorcumd"},{"post_id":"cjed06lam0000sfjf5db2oz96","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06lbg000esfjfuyixdx8m"},{"post_id":"cjed06lb30006sfjf2nmryn83","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06lbu000hsfjfjg53donp"},{"post_id":"cjed06lb70009sfjfq4nhc9nd","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06lby000msfjfjg67g4hs"},{"post_id":"cjed06lar0001sfjfgjmveyws","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06lc0000osfjfqti0i2xt"},{"post_id":"cjed06lbd000bsfjfbjpxlx4v","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06lc3000rsfjf7nal7vbt"},{"post_id":"cjed06laz0004sfjf59mm7ayd","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06lc6000vsfjfvy5el4zu"},{"post_id":"cjed06lbu000isfjf8lna899k","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06lca000zsfjfidjou10k"},{"post_id":"cjed06lbh000fsfjfnsimc2p1","category_id":"cjed06lbx000lsfjfcdp0eq9f","_id":"cjed06lcd0013sfjf4i90w04f"},{"post_id":"cjed06lc4000ssfjfld0ym3i5","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06lce0017sfjflzm85vfk"},{"post_id":"cjed06lc7000wsfjfaabhb1ck","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06lch001bsfjfa0nxob76"},{"post_id":"cjed06lby000nsfjfn1twsy0l","category_id":"cjed06lbx000lsfjfcdp0eq9f","_id":"cjed06lck001esfjf28r8gm8n"},{"post_id":"cjed06lcd0014sfjfavjthtfy","category_id":"cjed06lcc0011sfjflpxed7om","_id":"cjed06lcn001jsfjf0w367k73"},{"post_id":"cjed06lc0000psfjfhkgrl5zs","category_id":"cjed06lcc0011sfjflpxed7om","_id":"cjed06lct001msfjf7couy4m8"},{"post_id":"cjed06lca0010sfjfhtssbd9c","category_id":"cjed06lcc0011sfjflpxed7om","_id":"cjed06ld2001qsfjf0uhprbti"},{"post_id":"cjed06lcl001gsfjfb12kcw6i","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ld5001ssfjf9ue7nwqf"},{"post_id":"cjed06lcf0018sfjfmu04hl4x","category_id":"cjed06lcm001hsfjfhm1ekoyb","_id":"cjed06ld8001xsfjfn7tp51m9"},{"post_id":"cjed06lcw001nsfjfueo2pb81","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ldc0020sfjfer2l30jz"},{"post_id":"cjed06lci001csfjfkdvllyz6","category_id":"cjed06ld0001psfjfbubxea1o","_id":"cjed06ldg0025sfjfzdhsd6wb"},{"post_id":"cjed06ld5001tsfjfl7v8es7z","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ldi0028sfjfagic9k25"},{"post_id":"cjed06ld8001ysfjftntw1olr","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ldk002bsfjffrmwpjk4"},{"post_id":"cjed06lco001ksfjf8rh4eg9c","category_id":"cjed06ld0001psfjfbubxea1o","_id":"cjed06ldn002gsfjfu1fdd1lm"},{"post_id":"cjed06ldd0021sfjf4g0sditg","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ldp002isfjf6nn5g2js"},{"post_id":"cjed06ldg0026sfjf45ike5ie","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ldr002lsfjfa3ccgbpy"},{"post_id":"cjed06ld2001rsfjfixdjcdfc","category_id":"cjed06ldf0024sfjfngv39yug","_id":"cjed06lds002osfjf5nkeziq7"},{"post_id":"cjed06ldk002dsfjf25jgvh0v","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ldu002ssfjfjnrkbxgr"},{"post_id":"cjed06ldn002hsfjfaam1a5u4","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ldu002usfjf9kzqmjud"},{"post_id":"cjed06ldp002jsfjfjtm7qyjq","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ldv002xsfjfwg45aomm"},{"post_id":"cjed06ldj0029sfjf39fjwg91","category_id":"cjed06ldm002esfjfxpl1ooj2","_id":"cjed06ldv002zsfjfzhy17itp"},{"post_id":"cjed06ldr002nsfjftcrvbwph","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ldw0032sfjfwiztvjuj"},{"post_id":"cjed06lds002qsfjfw08dsodx","category_id":"cjed06law0002sfjf5wqwekzw","_id":"cjed06ldx0034sfjfctvkziyv"}],"PostTag":[{"post_id":"cjed06lam0000sfjf5db2oz96","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06lbi000gsfjff6t9o2ep"},{"post_id":"cjed06lam0000sfjf5db2oz96","tag_id":"cjed06lb50008sfjf4yk6k741","_id":"cjed06lbw000jsfjfl2c8k0rp"},{"post_id":"cjed06lar0001sfjfgjmveyws","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06lc5000usfjf57b1nr8k"},{"post_id":"cjed06lar0001sfjfgjmveyws","tag_id":"cjed06lb50008sfjf4yk6k741","_id":"cjed06lc8000xsfjfwbho2i4w"},{"post_id":"cjed06laz0004sfjf59mm7ayd","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06lcc0012sfjfkzbczvm9"},{"post_id":"cjed06lc7000wsfjfaabhb1ck","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06lce0015sfjf5erpchjn"},{"post_id":"cjed06lb10005sfjf6ijgd6pt","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06lch001asfjfry1ac1yn"},{"post_id":"cjed06lb10005sfjf6ijgd6pt","tag_id":"cjed06lc9000ysfjfnktiyyqk","_id":"cjed06lcj001dsfjfmktyghfo"},{"post_id":"cjed06lb30006sfjf2nmryn83","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06lcn001isfjf7jad3w7v"},{"post_id":"cjed06lb30006sfjf2nmryn83","tag_id":"cjed06lce0016sfjfvlvy7oyv","_id":"cjed06lcs001lsfjfy4tvo5uq"},{"post_id":"cjed06ld2001rsfjfixdjcdfc","tag_id":"cjed06lc9000ysfjfnktiyyqk","_id":"cjed06ld7001vsfjfdhvu115n"},{"post_id":"cjed06ld2001rsfjfixdjcdfc","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06ldc001zsfjfqum7364f"},{"post_id":"cjed06lb70009sfjfq4nhc9nd","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06ldf0023sfjfnn1wgpvq"},{"post_id":"cjed06lb70009sfjfq4nhc9nd","tag_id":"cjed06lck001fsfjfvq8sic0x","_id":"cjed06ldi0027sfjfsmu6tpji"},{"post_id":"cjed06lb70009sfjfq4nhc9nd","tag_id":"cjed06lcz001osfjf4fmb3y47","_id":"cjed06ldk002asfjf0aiglh60"},{"post_id":"cjed06ldj0029sfjf39fjwg91","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06ldn002fsfjfgggqp6ml"},{"post_id":"cjed06lbd000bsfjfbjpxlx4v","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06ldr002msfjf5jkxff1c"},{"post_id":"cjed06lbd000bsfjfbjpxlx4v","tag_id":"cjed06ld7001usfjfxkzov6ud","_id":"cjed06lds002psfjfot5gsyxy"},{"post_id":"cjed06lbd000bsfjfbjpxlx4v","tag_id":"cjed06ldf0022sfjfmyqj9tp3","_id":"cjed06ldu002tsfjfeq5mkz0c"},{"post_id":"cjed06lbd000bsfjfbjpxlx4v","tag_id":"cjed06ldk002csfjfjcejjt05","_id":"cjed06ldu002vsfjftfej6663"},{"post_id":"cjed06lbh000fsfjfnsimc2p1","tag_id":"cjed06ldq002ksfjfxw3ut9b5","_id":"cjed06ldv002ysfjf1zzmg4vb"},{"post_id":"cjed06lbh000fsfjfnsimc2p1","tag_id":"cjed06lc9000ysfjfnktiyyqk","_id":"cjed06ldw0030sfjfxq7tgsdw"},{"post_id":"cjed06lbu000isfjf8lna899k","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06ldx0033sfjf6xn21rtq"},{"post_id":"cjed06lbu000isfjf8lna899k","tag_id":"cjed06ldv002wsfjfaoh1bqx3","_id":"cjed06ldx0035sfjf6t550n0v"},{"post_id":"cjed06lby000nsfjfn1twsy0l","tag_id":"cjed06ldw0031sfjf6zb0d3ze","_id":"cjed06ldy0037sfjf0l1nyuoi"},{"post_id":"cjed06lc0000psfjfhkgrl5zs","tag_id":"cjed06ldq002ksfjfxw3ut9b5","_id":"cjed06ldy0039sfjfw9u9v1kh"},{"post_id":"cjed06lc4000ssfjfld0ym3i5","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06ldz003csfjfn1ju01jq"},{"post_id":"cjed06lc4000ssfjfld0ym3i5","tag_id":"cjed06ldy0038sfjf8324bl0c","_id":"cjed06le0003dsfjfe2noo60i"},{"post_id":"cjed06lc4000ssfjfld0ym3i5","tag_id":"cjed06ldz003asfjfzzfjo5nb","_id":"cjed06le0003fsfjfpgiyqigp"},{"post_id":"cjed06lca0010sfjfhtssbd9c","tag_id":"cjed06ldz003bsfjfelrrfre2","_id":"cjed06le1003hsfjff85ftlha"},{"post_id":"cjed06lca0010sfjfhtssbd9c","tag_id":"cjed06ldq002ksfjfxw3ut9b5","_id":"cjed06le2003isfjfya006aos"},{"post_id":"cjed06lcd0014sfjfavjthtfy","tag_id":"cjed06ldq002ksfjfxw3ut9b5","_id":"cjed06le2003ksfjfmuv56sov"},{"post_id":"cjed06lcf0018sfjfmu04hl4x","tag_id":"cjed06le2003jsfjf3pyrsydz","_id":"cjed06le3003msfjfbo1l1b5h"},{"post_id":"cjed06lci001csfjfkdvllyz6","tag_id":"cjed06le3003lsfjf25dvecdm","_id":"cjed06le5003psfjfhwzti1w6"},{"post_id":"cjed06lci001csfjfkdvllyz6","tag_id":"cjed06le3003nsfjfl5q2u46m","_id":"cjed06le5003qsfjfpy552gwd"},{"post_id":"cjed06lcl001gsfjfb12kcw6i","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06le7003tsfjfdb6xt9w0"},{"post_id":"cjed06lcl001gsfjfb12kcw6i","tag_id":"cjed06ldy0038sfjf8324bl0c","_id":"cjed06le7003usfjfk14w1ogk"},{"post_id":"cjed06lcl001gsfjfb12kcw6i","tag_id":"cjed06le5003rsfjfsd8fnaky","_id":"cjed06le7003wsfjf7xf1eq1p"},{"post_id":"cjed06lco001ksfjf8rh4eg9c","tag_id":"cjed06le3003lsfjf25dvecdm","_id":"cjed06le8003ysfjffvajsqek"},{"post_id":"cjed06lco001ksfjf8rh4eg9c","tag_id":"cjed06le7003vsfjf9gkvk6wr","_id":"cjed06le9003zsfjfgnbvl19y"},{"post_id":"cjed06lcw001nsfjfueo2pb81","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06le90041sfjfvdmohofa"},{"post_id":"cjed06lcw001nsfjfueo2pb81","tag_id":"cjed06le7003xsfjfly2coiex","_id":"cjed06le90042sfjfkr0yjvcl"},{"post_id":"cjed06ld5001tsfjfl7v8es7z","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06le90044sfjf52wfzcpi"},{"post_id":"cjed06ld5001tsfjfl7v8es7z","tag_id":"cjed06le90040sfjfltaa5ca4","_id":"cjed06le90045sfjfilpn0sz2"},{"post_id":"cjed06ld8001ysfjftntw1olr","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06lea0048sfjfmbg5mg6n"},{"post_id":"cjed06ld8001ysfjftntw1olr","tag_id":"cjed06le90043sfjfg16sdz7y","_id":"cjed06lea0049sfjf0m5ywrth"},{"post_id":"cjed06ld8001ysfjftntw1olr","tag_id":"cjed06lea0046sfjf2r0ae44j","_id":"cjed06leb004bsfjf86wb92yx"},{"post_id":"cjed06ldd0021sfjf4g0sditg","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06leb004csfjf19rue91i"},{"post_id":"cjed06ldd0021sfjf4g0sditg","tag_id":"cjed06lea0047sfjfzfjmqkwo","_id":"cjed06leb004esfjf4lf3gk4w"},{"post_id":"cjed06ldg0026sfjf45ike5ie","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06leb004fsfjfy9r7x473"},{"post_id":"cjed06ldg0026sfjf45ike5ie","tag_id":"cjed06lea004asfjfskm8qzb1","_id":"cjed06leb004hsfjf9ncykrpm"},{"post_id":"cjed06ldk002dsfjf25jgvh0v","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06lec004isfjfb5ip8ueh"},{"post_id":"cjed06ldk002dsfjf25jgvh0v","tag_id":"cjed06leb004dsfjflbu6bygi","_id":"cjed06lec004jsfjfcvs04j3e"},{"post_id":"cjed06ldn002hsfjfaam1a5u4","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06led004msfjfygj7716e"},{"post_id":"cjed06ldn002hsfjfaam1a5u4","tag_id":"cjed06leb004gsfjfhzy8hdjr","_id":"cjed06led004nsfjffayl823i"},{"post_id":"cjed06ldn002hsfjfaam1a5u4","tag_id":"cjed06lec004ksfjfx8dspox9","_id":"cjed06lee004psfjftn2vtr5a"},{"post_id":"cjed06ldp002jsfjfjtm7qyjq","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06lee004qsfjfls0n5doj"},{"post_id":"cjed06ldp002jsfjfjtm7qyjq","tag_id":"cjed06led004lsfjfuqlxun50","_id":"cjed06leg004ssfjfl0t25zzm"},{"post_id":"cjed06ldr002nsfjftcrvbwph","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06leg004tsfjffnqln2zg"},{"post_id":"cjed06ldr002nsfjftcrvbwph","tag_id":"cjed06led004osfjfuxs4xai7","_id":"cjed06leg004usfjf8bhleutn"},{"post_id":"cjed06lds002qsfjfw08dsodx","tag_id":"cjed06laz0003sfjfn64ibeth","_id":"cjed06leg004vsfjfx2rbb7ws"},{"post_id":"cjed06lds002qsfjfw08dsodx","tag_id":"cjed06lee004rsfjfmfthiulo","_id":"cjed06leg004wsfjfazqxchk6"}],"Tag":[{"name":"Android","_id":"cjed06laz0003sfjfn64ibeth"},{"name":"AMS","_id":"cjed06lb50008sfjf4yk6k741"},{"name":"打包","_id":"cjed06lc9000ysfjfnktiyyqk"},{"name":"模块化","_id":"cjed06lce0016sfjfvlvy7oyv"},{"name":"指标","_id":"cjed06lck001fsfjfvq8sic0x"},{"name":"广告计费","_id":"cjed06lcz001osfjf4fmb3y47"},{"name":"eventbus3.0","_id":"cjed06ld7001usfjfxkzov6ud"},{"name":"注解","_id":"cjed06ldf0022sfjfmyqj9tp3"},{"name":"APT","_id":"cjed06ldk002csfjfjcejjt05"},{"name":"工具","_id":"cjed06ldq002ksfjfxw3ut9b5"},{"name":"性能监控","_id":"cjed06ldv002wsfjfaoh1bqx3"},{"name":"网络层","_id":"cjed06ldw0031sfjf6zb0d3ze"},{"name":"全屏模式","_id":"cjed06ldy0038sfjf8324bl0c"},{"name":"键盘","_id":"cjed06ldz003asfjfzzfjo5nb"},{"name":"github","_id":"cjed06ldz003bsfjfelrrfre2"},{"name":"ios入门","_id":"cjed06le2003jsfjf3pyrsydz"},{"name":"Python","_id":"cjed06le3003lsfjf25dvecdm"},{"name":"xml","_id":"cjed06le3003nsfjfl5q2u46m"},{"name":"AdjustResize","_id":"cjed06le5003rsfjfsd8fnaky"},{"name":"公众号爬取","_id":"cjed06le7003vsfjf9gkvk6wr"},{"name":"性能分析","_id":"cjed06le7003xsfjfly2coiex"},{"name":"主题色","_id":"cjed06le90040sfjfltaa5ca4"},{"name":"又拍云","_id":"cjed06le90043sfjfg16sdz7y"},{"name":"图片","_id":"cjed06lea0046sfjf2r0ae44j"},{"name":"数据库","_id":"cjed06lea0047sfjfzfjmqkwo"},{"name":"沉浸式","_id":"cjed06lea004asfjfskm8qzb1"},{"name":"爱心动画","_id":"cjed06leb004dsfjflbu6bygi"},{"name":"数据统计","_id":"cjed06leb004gsfjfhzy8hdjr"},{"name":"运营","_id":"cjed06lec004ksfjfx8dspox9"},{"name":"分享图片","_id":"cjed06led004lsfjfuqlxun50"},{"name":"热补丁","_id":"cjed06led004osfjfuxs4xai7"},{"name":"崩溃","_id":"cjed06lee004rsfjfmfthiulo"}]}}