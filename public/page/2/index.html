<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Nico随笔">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Nico随笔">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nico随笔">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title> Nico随笔 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Nico随笔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/okhttp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/okhttp/" itemprop="url">
                  okhttp源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="okttp-解析（okio以后再讲-So-ignore-Sink-Source）"><a href="#okttp-解析（okio以后再讲-So-ignore-Sink-Source）" class="headerlink" title="okttp 解析（okio以后再讲  So   ignore  Sink   Source）"></a>okttp 解析（okio以后再讲  So   ignore  Sink   Source）</h1><h2 id="Interface：OkhttpClient（singleton）-Request-Response"><a href="#Interface：OkhttpClient（singleton）-Request-Response" class="headerlink" title="Interface：OkhttpClient（singleton）  Request  Response"></a>Interface：OkhttpClient（singleton）  Request  Response</h2><h2 id="主要由以下三部分-组成"><a href="#主要由以下三部分-组成" class="headerlink" title="主要由以下三部分 组成"></a>主要由以下三部分 组成</h2><h3 id="1-任务调度：-核心类disruptor（singleton）"><a href="#1-任务调度：-核心类disruptor（singleton）" class="headerlink" title="1. 任务调度： 核心类disruptor（singleton）"></a>1. 任务调度： 核心类disruptor（singleton）</h3><p>a. 线程池<br>b. 队列</p>
<pre><code>/** Ready async calls in the order they&apos;ll be run. */
private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();

/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */
private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();

/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */
 private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();
</code></pre><p>(由于okhttp两种 运行模式   sync  和async）</p>
<h3 id="2-网络请求"><a href="#2-网络请求" class="headerlink" title="2. 网络请求"></a>2. 网络请求</h3><ul>
<li>核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） </li>
<li>每个请求会生成一个Request  </li>
<li>然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  </li>
</ul>
<p>okhttp一个请求的完整流程图<br> <img src="http://blog.piasy.com/img/201607/okhttp_full_process.png" alt="image"></p>
<p>在realcall的execute方法中会调用     </p>
<pre><code>client.dispatcher().executed(this);//问题1  
Response result = getResponseWithInterceptorChain(false);//问题2  
</code></pre><p>获得请求结果.<br>现在看问题1  在这里面干了写什么<br>其实就是 dispatcher记录任务而已 ，没有任何执行方法<br>核心在问题2中<br>她会  </p>
<pre><code>Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
return chain.proceed(originalRequest);
</code></pre><p>也就是生成拦截器 ，并用这个拦截器启动这个请求<br>继续进入proceed 可以看到<br>进入了ApplicationInterceptorChain的getresponse方法<br>开始构造HttpEngine    </p>
<pre><code>engine.sendRequest();//问题21
engine.readResponse();//问题22
</code></pre><p>在问题21中其实就是  Rfc 标准的一种 实现  </p>
<pre><code>InternalCache responseCache = Internal.instance.internalCache(client);
Response cacheCandidate = responseCache != null
    ? responseCache.get(request)
    : null;
</code></pre><p>就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache<br>这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程<br>当取到值后还要根据http cache的rfc标准  判断  是否合理能使用<br>new CacheStrategy.Factory(now, request, cacheCandidate).get();<br>在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  </p>
<p>这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）</p>
<pre><code>if (etag != null) {
  conditionalRequestBuilder.header(&quot;If-None-Match&quot;, etag);
} else if (lastModified != null) {
  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, lastModifiedString);
} else if (servedDate != null) {
  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, servedDateString);
}

Request conditionalRequest = conditionalRequestBuilder.build();
</code></pre><p>这是请求前的工作<br>现在开始发送请求</p>
<pre><code>httpStream = connect();
httpStream.setHttpEngine(this);
</code></pre><p>这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）</p>
<pre><code>streamAllocation.newStream(client.connectTimeoutMillis(),
client.readTimeoutMillis(), client.writeTimeoutMillis(),
client.retryOnConnectionFailure(), doExtensiveHealthChecks);
</code></pre><p>解决的问题 是socket连接重用和  route<br>先是从连接池中找</p>
<pre><code>// Attempt to get a connection from the pool.
 RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);
 if (pooledConnection != null) {
   this.connection = pooledConnection;
   return pooledConnection;
 }
</code></pre><p>如果没有的话就看route可以重用嘛</p>
<pre><code> if (selectedRoute == null) {
  selectedRoute = routeSelector.next();
  synchronized (connectionPool) {
    route = selectedRoute;
  }
}
RealConnection newConnection = new RealConnection(selectedRoute);
acquire(newConnection);
</code></pre><p>（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止</p>
<pre><code>RouteDatabase里的Set&lt;Route&gt; failedRoutes = new LinkedHashSet&lt;&gt;()）
</code></pre><p>弄完之后就是放如   </p>
<pre><code>Internal.instance.put(connectionPool, newConnection);
</code></pre><p>连接池中  方便下次继续使用<br>下一步 就是建立socket连接的过程</p>
<pre><code> newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
    connectionRetryEnabled);
routeDatabase().connected(newConnection.route());
</code></pre><p>跟进去 就是</p>
<pre><code>connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
</code></pre><p>继续</p>
<pre><code> try {
  Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
} catch (ConnectException e) {
  throw new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress());
}
source = Okio.buffer(Okio.source(rawSocket));
sink = Okio.buffer(Okio.sink(rawSocket));
</code></pre><p>连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的<br>然后才是真正发送这个请求的过程</p>
<pre><code>httpStream.writeRequestHeaders(networkRequest);
requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);
</code></pre><p>继续跟进</p>
<pre><code> httpEngine.writingRequestHeaders();
  String requestLine = RequestLine.get(
    request, httpEngine.getConnection().route().proxy().type());
writeRequest(request.headers(), requestLine);
</code></pre><p>》》</p>
<pre><code>** Returns bytes of a request header for sending on an HTTP transport. */
public void writeRequest(Headers headers, String requestLine) throws IOException {
if (state != STATE_IDLE) throw new IllegalStateException(&quot;state: &quot; + state);
sink.writeUtf8(requestLine).writeUtf8(&quot;\r\n&quot;);
for (int i = 0, size = headers.size(); i &lt; size; i++) {
  sink.writeUtf8(headers.name(i))
      .writeUtf8(&quot;: &quot;)
      .writeUtf8(headers.value(i))
      .writeUtf8(&quot;\r\n&quot;);
}
sink.writeUtf8(&quot;\r\n&quot;);
state = STATE_OPEN_REQUEST_BODY;
}
</code></pre><p>读过程<br>就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink</p>
<p>到此 请求reponse的工作做完了<br>现在 如果是需要真正发送网络请求就也就是问题22</p>
<pre><code>networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
</code></pre><p>》》</p>
<pre><code>engin.readResponse
</code></pre><p>》》</p>
<pre><code>// Write the request body to the socket.
if (requestBodyOut != null) {
  if (bufferedRequestBody != null) {
    // This also closes the wrapped requestBodyOut.
    bufferedRequestBody.close();
  } else {
    requestBodyOut.close();
  }
  if (requestBodyOut instanceof RetryableSink) {
    httpStream.writeRequestBody((RetryableSink) requestBodyOut);
  }
}

networkResponse = readNetworkResponse();
</code></pre><p>》》</p>
<pre><code>Response readNetworkResponse() throws IOException {
httpStream.finishRequest();

Response networkResponse = httpStream.readResponseHeaders()
    .request(networkRequest)
    .handshake(streamAllocation.connection().handshake())
    .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
    .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
    .build();

if (!forWebSocket) {
  networkResponse = networkResponse.newBuilder()
      .body(httpStream.openResponseBody(networkResponse))
      .build();
}

if (&quot;close&quot;.equalsIgnoreCase(networkResponse.request().header(&quot;Connection&quot;))
    || &quot;close&quot;.equalsIgnoreCase(networkResponse.header(&quot;Connection&quot;))) {
  streamAllocation.noNewStreams();
}

return networkResponse;
</code></pre><p>  }</p>
<p>解析和返回</p>
<pre><code> Response response = engine.getResponse();


//tobe continue（已经 cache过程 请求重试过程）
 Request followUp = engine.followUpRequest();
</code></pre><h3 id="3-cache管理"><a href="#3-cache管理" class="headerlink" title="3. cache管理"></a>3. cache管理</h3><p>最后附上 相关的http请求cache的rfc内容<br> <img src="https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg" alt="image"></p>
<h3 id="每个状态的详细说明如下："><a href="#每个状态的详细说明如下：" class="headerlink" title="每个状态的详细说明如下："></a>每个状态的详细说明如下：</h3><h4 id="1-Last-Modified"><a href="#1-Last-Modified" class="headerlink" title="1. Last-Modified"></a>1. Last-Modified</h4><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：<br>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT<br>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：<br>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT<br>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。<br>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  </p>
<h4 id="2-Etag工作原理"><a href="#2-Etag工作原理" class="headerlink" title="2. Etag工作原理"></a>2. Etag工作原理</h4><p>HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：<br>Etag:“5d8c72a5edda8d6a:3239″<br>客户端的查询更新格式是这样的：<br>If-None-Match:“5d8c72a5edda8d6a:3239″<br>如果ETag没改变，则返回状态304。<br>即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″<br>标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。<br>If-None-Match:“5d8c72a5edda8d6a:3239“<br>,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  </p>
<h4 id="3-Expires"><a href="#3-Expires" class="headerlink" title="3. Expires"></a>3. Expires</h4><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT<br>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  </p>
<h4 id="4-Last-Modified和Expires"><a href="#4-Last-Modified和Expires" class="headerlink" title="4. Last-Modified和Expires"></a>4. Last-Modified和Expires</h4><p>Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  </p>
<h4 id="5-Etag和Expires"><a href="#5-Etag和Expires" class="headerlink" title="5. Etag和Expires"></a>5. Etag和Expires</h4><p>如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  </p>
<h4 id="6-Last-Modified和Etag"><a href="#6-Last-Modified和Etag" class="headerlink" title="6. Last-Modified和Etag"></a>6. Last-Modified和Etag</h4><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败<br>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)<br>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存<br>过程如下:  </p>
<ul>
<li>客户端请求一个页面（A）。  </li>
<li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。  </li>
<li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  </li>
<li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  </li>
<li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  </li>
</ul>
<p>备注：   </p>
<ul>
<li>Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  </li>
<li>WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  </li>
<li>客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  </li>
<li>通过上述值到服务器端检查，判断文件是否继续缓存；  </li>
</ul>
<h4 id="7-关于-Cache-Control-max-age-秒-和-Expires"><a href="#7-关于-Cache-Control-max-age-秒-和-Expires" class="headerlink" title="7.关于 Cache-Control: max-age=秒 和 Expires"></a>7.关于 Cache-Control: max-age=秒 和 Expires</h4><p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。<br>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。<br>Expires =max-age +   “每次下载时的当前的request时间”<br>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/动态往apk写入信息/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/动态往apk写入信息/" itemprop="url">
                  快速打包方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android快速打包/" itemprop="url" rel="index">
                    <span itemprop="name">Android快速打包</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="往apk文件里面动态添加信息的两种方法。"><a href="#往apk文件里面动态添加信息的两种方法。" class="headerlink" title="往apk文件里面动态添加信息的两种方法。"></a>往apk文件里面动态添加信息的两种方法。</h1><p>（都需要保留安装时候的apk文件）</p>
<ol>
<li>方案一：往meta_info里面添加文件,写入参数信息</li>
<li>方案二：在apk这个文件的comment信息里面添加需要传入的信息  </li>
</ol>
<h2 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h2><p>参考：<a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="external">http://tech.meituan.com/mt-apk-packaging.html</a><br>主要代表：美团<br>原理：meta_info（里面存的就是签名信息）里面的文件不参与签名，修改后，apk不需要签名 </p>
<h2 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h2><p>参考：<a href="http://blog.csdn.net/kongpinde/article/details/51518466" target="_blank" rel="external">http://blog.csdn.net/kongpinde/article/details/51518466</a><br>主要代表：天猫、豌豆荚<br>原理：apk就是一个zip压缩包。而zip包有个comment区域，可以往里面写入信息，而不对apk的安装产生影响<br>zip 文件的末尾有一个 Central Directory Record 区域，其末尾包含一个 File comment 区域，可以存放一些数据，所以 File comment 是 zip 文件一部分，如果可以正确的修改这个部分，就可以在不破坏压缩包、不用重新打包的的前提下快速的给 Apk 文件写入自己想要的数据。</p>
<p>comment 是在 Central Directory Record 末尾储存的，可以将数据直接写在这里，下表是 header 末尾的结构。<br> <img src="https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment.png" alt="image"><br>从表中可以看到定义 comment 长度的字段位于 comment 之前。</p>
<p>这里我们需要自定义 comment，在自定义 comment 内容的后面添加一个区域储存 comment 的长度，结构如下图。<br><img src="https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment_structure.png" alt="image"></p>
<h3 id="Server动态生成apk"><a href="#Server动态生成apk" class="headerlink" title="Server动态生成apk"></a>Server动态生成apk</h3><p>这一部分可以在本地或服务端进行，需要定义一个长度为 2 的 byte[] 来储存 comment 的长度，直接使用 Java 的 api 就可以把 comment 和 comment 的长度写到 Apk 的末尾，代码如下：</p>
<pre><code>public static void writeApk(File file, String comment) {
    ZipFile zipFile = null;
    ByteArrayOutputStream outputStream = null;
    RandomAccessFile accessFile = null;
    try {
        zipFile = new ZipFile(file);
        String zipComment = zipFile.getComment();
        // 判断comment区域是否已经有数据了
        if (zipComment != null)
            return;
        byte[] byteComment = comment.getBytes();
        outputStream = new ByteArrayOutputStream();
        // 将数据写入输出流
        outputStream.write(byteComment);
        // 紧接着写入数据大小
        outputStream.write(short2Stream((short) byteComment.length));
            byte[] data = outputStream.toByteArray();
        accessFile = new RandomAccessFile(file, &quot;rw&quot;);
        // 跳到comment区域
        accessFile.seek(file.length() - 2);
        // 先写入数据大小
        accessFile.write(short2Stream((short) data.length));
        // 写入数据
        accessFile.write(data);
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (zipFile != null)
                zipFile.close();
            if (outputStream != null)
                outputStream.close();
            if (accessFile != null)
                accessFile.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
private static byte[] short2Stream(short data) {
    ByteBuffer buffer = ByteBuffer.allocate(2);
    buffer.order(ByteOrder.LITTLE_ENDIAN);
    buffer.putShort(data);
    buffer.flip();
    return buffer.array();
}
</code></pre><h3 id="客户端解析apk数据："><a href="#客户端解析apk数据：" class="headerlink" title="客户端解析apk数据："></a>客户端解析apk数据：</h3><pre><code>private static String readApk(Context context) {
    // 获取文件路径
    File file = new File(context.getPackageCodePath());
    byte[] bytes = null;
    RandomAccessFile accessFile = null;
    try {
        accessFile = new RandomAccessFile(file, &quot;r&quot;);
        long index = accessFile.length();
        bytes = new byte[2];
        // 获取comment文件的位置
        index = index - bytes.length;
        accessFile.seek(index);
        // 获取comment中写入数据的大小byte类型
        accessFile.readFully(bytes);
        // 将byte转换成大小
        int contentLength = stream2Short(bytes, 0);
        // 创建byte[]数据大小来存储写入的数据
        bytes = new byte[contentLength];
        index = index - bytes.length;
        accessFile.seek(index);
        // 读取数据
        accessFile.readFully(bytes);
        return new String(bytes, &quot;utf-8&quot;);
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (accessFile != null) {
            try {
                accessFile.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return null;
}


private static short stream2Short(byte[] stream, int offset) {
    ByteBuffer buffer = ByteBuffer.allocate(2);
    buffer.order(ByteOrder.LITTLE_ENDIAN);
    buffer.put(stream[offset]);
    buffer.put(stream[offset + 1]);
    return buffer.getShort(0);
}
</code></pre><h1 id="apk的安装过程"><a href="#apk的安装过程" class="headerlink" title="apk的安装过程"></a>apk的安装过程</h1><ol>
<li>复制APK安装包到data/app目录下（所以安装完成后，即使把sd卡中的apk删除也没关系）;</li>
<li>解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录;</li>
<li>并data/data目录下创建对应的应用数据目录。</li>
</ol>
<h2 id="应用安装涉及到如下几个目录："><a href="#应用安装涉及到如下几个目录：" class="headerlink" title="应用安装涉及到如下几个目录："></a>应用安装涉及到如下几个目录：</h2><p>system/app —————系统自带的应用程序，获得adb root权限才能删除</p>
<p>data/app  —————用户程序安装的目录。安装时把                                                                                                      apk文件复制到此目录<br>data/data —————存放应用程序的数据<br>data/dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)</p>
<h2 id="app卸载"><a href="#app卸载" class="headerlink" title="app卸载"></a>app卸载</h2><p>删除安装过程中在上述三个目录下创建的文件及目录。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/性能优化篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/性能优化篇/" itemprop="url">
                  Android 性能检测与优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="手机端："><a href="#手机端：" class="headerlink" title="手机端："></a>手机端：</h1><h2 id="开发者选项"><a href="#开发者选项" class="headerlink" title="开发者选项"></a>开发者选项</h2><ol>
<li><p>绘图》 显示布局边界</p>
</li>
<li><p>硬件加速渲染 》调试GPU过渡绘制  要打开</p>
</li>
</ol>
<ol>
<li><p>监控》启用严格模式</p>
</li>
<li><p>GPU呈现模式分析  可以对照颜色表找出耗时出在那一部分<br><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/GPU%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F.jpg?raw=true" alt="image"></p>
</li>
</ol>
<h1 id="电脑端："><a href="#电脑端：" class="headerlink" title="电脑端："></a>电脑端：</h1><ol>
<li><p>查看MemoryMonitor  ，查看页面内存波动（对于listview ）</p>
</li>
<li><p>tools》android》android  device  monistor<br>（其实它就是把android sdk中tools下面的很多功能聚合起来；  如ddms，uiautomatorviewer，monitor等功能聚合起来，但是好像没有集成hierarchyviewer的功能）</p>
</li>
<li><p>查看录制页面变化时候的cpu耗时<br>开始录制》选中进程，点击红色方框左边的按钮，然后点击红色方框里右侧的按钮录制正式开始，需要结束时，再点击右侧按钮结束，就会有结果自动生成<br><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6.png?raw=true" alt="image"></p>
<p>分析结果》录制实际上是一个采样的过程，可以看图中红色方框里面最耗时的几个方法，基本上可以定位到程序的问题<br><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6_2.png?raw=true" alt="image"></p>
</li>
<li>查看布局层次，以及每一层的绘制时间，目的是减小层次<br>入口是在：tools 下面 hierarchyviewer  查看每个层次的绘制时间（这个好像必须在模拟器上看）</li>
</ol>
<h1 id="分析卡的原因"><a href="#分析卡的原因" class="headerlink" title="分析卡的原因"></a>分析卡的原因</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.cnblogs.com/krislight1105/p/5352500.html" target="_blank" rel="external">http://www.cnblogs.com/krislight1105/p/5352500.html</a><br><a href="http://blog.csdn.net/wangbaochu/article/details/50396512" target="_blank" rel="external">http://blog.csdn.net/wangbaochu/article/details/50396512</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/混淆写法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/混淆写法/" itemprop="url">
                  混淆写法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/打包/" itemprop="url" rel="index">
                    <span itemprop="name">打包</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>-keepclassmembers class <strong> {<br>    public void onEvent*(</strong>);<br>}</p>
<p>只保护 public void onEvent<em>(*</em>)的方法不被重命名</p>
<p>-keepattributes Signature</p>
<p>-keep class okio.<em>* {</em>;}</p>
<p>-keep class android.support.v4.app.NotificationCompat<em>*{<br>    public </em>;<br>}</p>
<p>-keep class com.veda.lyc.Utils{ static *;}<br>保持里面的静态方法不被混淆</p>
<p>keep的几个选项</p>
<table>
<thead>
<tr>
<th>Keep</th>
<th style="text-align:right">From being removed or renamed</th>
<th style="text-align:center">From being renamed</th>
</tr>
</thead>
<tbody>
<tr>
<td>Classes and class members</td>
<td style="text-align:right">-keep</td>
<td style="text-align:center">-keepnames</td>
</tr>
<tr>
<td>Class members only</td>
<td style="text-align:right">-keepclassmembers</td>
<td style="text-align:center">-keepclassmembernames</td>
</tr>
<tr>
<td>-keepclassmembers    -keepclassmembernames</td>
</tr>
</tbody>
</table>
<p>Classes and class members, if class members present       |    -keepclasseswithmembers    |  -keepclasseswithmembernames  |</p>
<p>参考资料<br><a href="http://blog.csdn.net/sudic_niu/article/details/7921548" target="_blank" rel="external">http://blog.csdn.net/sudic_niu/article/details/7921548</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/热补丁_part0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/热补丁_part0/" itemprop="url">
                  热补丁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于java的热补丁逻辑"><a href="#基于java的热补丁逻辑" class="headerlink" title="基于java的热补丁逻辑"></a>基于java的热补丁逻辑</h1><h2 id="核心两个部分"><a href="#核心两个部分" class="headerlink" title="核心两个部分"></a>核心两个部分</h2><h3 id="1-hook部分"><a href="#1-hook部分" class="headerlink" title="1. hook部分"></a>1. hook部分</h3><p>hook部分主要是使用反射调用补丁里面的内容</p>
<p>hook部分的本质是提供对补丁方法调用的封装（主工程无法直接实例和调用补丁的方法），每次调用都是通过反射调用，传入activity，handler，callback进去。</p>
<h3 id="2-补丁部分"><a href="#2-补丁部分" class="headerlink" title="2. 补丁部分"></a>2. 补丁部分</h3><p>补丁实际上是java代码转的dex<br>它的工作有两种：网络取数据，构造生成view</p>
<p>补丁部分构造view是通过hook部分传过来activity，然后用代码动态构造view，不涉及到任何布局文件，资源文件。  </p>
<h2 id="hook的初始化及调用过程"><a href="#hook的初始化及调用过程" class="headerlink" title="hook的初始化及调用过程"></a>hook的初始化及调用过程</h2><ol>
<li><p>初始化DexClassLoader<br>classLoader = new DexClassLoader(dexApkFilePath</p>
<pre><code>+ dexName + &quot;.apk&quot;, context.getDir(&quot;dex&quot;, Context.MODE_PRIVATE).getAbsolutePath(), null,
context.getClassLoader().getParent());
</code></pre></li>
<li><p>load补丁相应的class<br>controllerClass = classLoader.loadClass(“com.nico.Controller”);</p>
</li>
<li><p>初始化构造函数<br>controllerConstrucor = controllerClass.getConstructor(new Class[]{Context.class, String.class, boolean.class});</p>
</li>
<li><p>实例化补丁里面的类<br>controllerInstance = controllerConstrucor.newInstance(new Object[]{mContext});</p>
</li>
<li><p>通过初始化的实例controllerInstance来调用里面的方法<br>Method initController = controllerClass.getDeclaredMethod(“initController”, new Class[]{String.class, String.class, String.class});</p>
<pre><code>initController.setAccessible(true);
initController.invoke(controllerInstance, new Object[]{paramsA, paramsB, paramsC});
</code></pre></li>
</ol>
<h2 id="补丁的升级"><a href="#补丁的升级" class="headerlink" title="补丁的升级"></a>补丁的升级</h2><ol>
<li>校验是否有新的版本升级</li>
<li>把新的补丁下载到本地sd卡中去</li>
<li>解压补丁到data/data/app.pkg/app_dex目录<br>ZipManager.extNativeZipFile(mContext,<pre><code>mContext.getResources().getAssets().open(Utils.ZIP_NAME),
cachePath, dexApkFilePath, lastVersion)
</code></pre></li>
<li>重新走一遍补丁的实例化过程（从DexLoader开始）</li>
</ol>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ol>
<li>第一次安装，补丁放到asset目录下面</li>
<li>由于里面传入了activity，要注意销毁补丁里面的强引用</li>
</ol>
<h2 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h2><ol>
<li><p>load补丁里面的资源文件 ,通过反射调用AssetManger里面的资源文件，把ID设置上去 </p>
<p>AssetManager assetManager = AssetManager.class.newInstance();  </p>
<pre><code>Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);  
addAssetPath.invoke(assetManager, libPath);  
Resources superRes = super.getResources();  
mRes = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());
</code></pre></li>
<li><p>尝试使用mvp模式，把controllor从activity里面剥离开来，让所有contollor可以被热补丁，这要处理起来（可以把整个app轻量化）</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/wwj_748/article/details/46349781" target="_blank" rel="external">http://blog.csdn.net/wwj_748/article/details/46349781</a></p>
<p><a href="http://blog.csdn.net/yuanzeyao/article/details/42390431" target="_blank" rel="external">http://blog.csdn.net/yuanzeyao/article/details/42390431</a></p>
<p><a href="http://blog.csdn.net/u010386612/article/details/51077291" target="_blank" rel="external">http://blog.csdn.net/u010386612/article/details/51077291</a></p>
<p><a href="http://blog.csdn.net/cn_foolishman/article/details/46874811" target="_blank" rel="external">http://blog.csdn.net/cn_foolishman/article/details/46874811</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/never_forget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/never_forget/" itemprop="url">
                  立个flag 不要忘记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/其它/" itemprop="url" rel="index">
                    <span itemprop="name">其它</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>StickyHeaderListView  头部悬停  吸附的控件</p>
<p>java  bitmap的实现  <a href="http://blog.csdn.net/xia744510124/article/details/51509285" target="_blank" rel="external">http://blog.csdn.net/xia744510124/article/details/51509285</a></p>
<p>0x00000001</p>
<p>HideOnListViewListener</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true"
               alt="Liuycheng" />
          <p class="site-author-name" itemprop="name">Liuycheng</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuycheng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
